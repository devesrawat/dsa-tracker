<!DOCTYPE html>
<html>

<head>
    <title>DSA Patterns</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Devesh Rawat <devsrawt@gmail.com>">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <link rel="stylesheet" href="style.css?v=dracula2">
    <script src="script.js?v=dracula2"></script>
    <!-- PrismJS for Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</head>

<body for="html-export">
    <div class="crossnote markdown-preview  ">
        <h1 id="dsa-mastery-progressive-pattern-guide">ğŸ¯ DSA MASTERY: PROGRESSIVE PATTERN GUIDE</h1>
        <p><strong>A weapon to conquer Data Structures &amp; Algorithms through pattern recognition and progressive
                learning</strong></p>
        <hr />
        <h2 id="learning-progression-philosophy">ğŸ“š Learning Progression Philosophy</h2>
        <p>This guide is organized so each pattern builds upon previous knowledge. <strong>Follow this order for maximum
                momentum:</strong></p>
        <pre>
ğŸ¯ OPTIMIZED LEARNING PATH
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PHASE 1: FOUNDATION (Week 1-2)
â”œâ”€ Pattern 0: Prerequisites â”€â”€â”€â”€â”€â”€â–º Big-O, complexity, interview tricks
â””â”€ Pattern 1: Arrays & Hashing â”€â”€â”€â–º Core data manipulation

PHASE 2: POINTER TECHNIQUES (Week 2-3)
â”œâ”€ Pattern 2: Two Pointers â”€â”€â”€â”€â”€â”€â”€â–º Converging pointers on arrays
â”œâ”€ Pattern 3: Sliding Window â”€â”€â”€â”€â”€â–º Variable-size window (extends two pointers)
â””â”€ Pattern 6: Linked Lists â”€â”€â”€â”€â”€â”€â”€â–º Pointer manipulation on nodes
    â””â”€ WHY HERE? Same mental model as two pointers!

PHASE 3: SEARCHING & STACK (Week 3-4)
â”œâ”€ Pattern 4: Binary Search â”€â”€â”€â”€â”€â”€â–º Divide and eliminate
â””â”€ Pattern 5: Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º LIFO + monotonic patterns

PHASE 4: TREES & RECURSION (Week 4-6) â­ CRITICAL PHASE
â”œâ”€ Pattern 12: Binary Trees â”€â”€â”€â”€â”€â”€â–º Recursion mastery through traversals
â”œâ”€ Pattern 13: Tries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Specialized tree structure
â””â”€ Pattern 11: Heaps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Complete binary tree (priority queue)
    â””â”€ WHY HERE? Heaps ARE trees!

PHASE 5: GRAPHS & EXPLORATION (Week 6-8)
â”œâ”€ Pattern 15: Graphs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º BFS/DFS generalized from trees
â””â”€ Pattern 14: Backtracking â”€â”€â”€â”€â”€â”€â–º Systematic exploration with pruning
    â””â”€ WHY HERE? Uses DFS exploration pattern!

PHASE 6: OPTIMIZATION PATTERNS (Week 8-9)
â”œâ”€ Pattern 7: Greedy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Local optimal choices
â”œâ”€ Pattern 8: Intervals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Sorting + greedy
â”œâ”€ Pattern 9: Bit Manipulation â”€â”€â”€â–º Low-level optimizations
â””â”€ Pattern 10: Math & Geometry â”€â”€â”€â–º Mathematical techniques

PHASE 7: DYNAMIC PROGRAMMING (Week 9-11) â­ HARDEST PHASE
â”œâ”€ Pattern 16: Dynamic Programming â–º Optimal substructure (needs recursion!)
â””â”€ Pattern 17: Divide & Conquer â”€â”€â–º Split, solve, merge

PHASE 8: INTERVIEW ESSENTIALS (Week 11-12)
â”œâ”€ Pattern 18: Design Questions â”€â”€â–º Combines all patterns
â””â”€ Interview Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Company prep, survival guide

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        </pre>
        <p><strong>Key Dependencies:</strong></p>
        <ul>
            <li>ğŸ”— <strong>Linked Lists after Two Pointers</strong> - Same pointer intuition</li>
            <li>ğŸŒ³ <strong>Heaps in Trees phase</strong> - Heaps are binary trees!</li>
            <li>ğŸ” <strong>Backtracking after Trees</strong> - Uses DFS exploration</li>
            <li>ğŸ’ <strong>DP last</strong> - Requires recursion mastery from Phase 4</li>
        </ul>
        <hr />
        <h2 id="how-to-use-this-guide">How to Use This Guide</h2>
        <ol>
            <li><strong>Master Prerequisites</strong>: Don't skip phases - each builds on the last</li>
            <li><strong>Learn the WHY</strong>: Understand when and why to use each pattern</li>
            <li><strong>Memorize Templates</strong>: Each pattern has 2-3 core templates</li>
            <li><strong>Practice Deliberately</strong>: Start with Easy, identify the pattern before coding</li>
            <li><strong>Review Traps</strong>: Learn from common mistakes</li>
            <li><strong>Space/Time Analysis</strong>: Always analyze complexity</li>
            <li><strong>Revisit</strong>: Come back after 48 hours, 1 week, 1 month</li>
        </ol>
        <hr />
        <h1 id="pattern-0-foundation-prerequisites">PATTERN 0: FOUNDATION PREREQUISITES ğŸ“</h1>
        <p><strong>Master These Before Diving Into Patterns</strong></p>
        <h2 id="time-space-complexity-analysis">Time/Space Complexity Analysis</h2>
        <p><strong>MUST KNOW - This is asked in 100% of technical interviews</strong></p>
        <h3 id="big-o-hierarchy">Big-O Hierarchy (Fastest to Slowest)</h3>
        <pre>O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(2^n) < O(n!)

Practical Examples:
â”œâ”€ O(1): HashMap lookup, array index access
â”œâ”€ O(log n): Binary search, balanced BST lookup
â”œâ”€ O(n): Linear scan, single loop
â”œâ”€ O(n log n): Merge sort, heap sort, efficient sorting
â”œâ”€ O(nÂ²): Nested loops, brute force pairs
â”œâ”€ O(2^n): Subsets, recursive fibonacci (naive)
â””â”€ O(n!): Permutations, traveling salesman brute force
        </pre>
        <h3 id="space-complexity-types">Space Complexity Types</h3>
        <pre><code class="language-python"># INPUT SPACE vs AUXILIARY SPACE
def example():
    """
    IMPORTANT DISTINCTION:
    - Input Space: Memory used by input (usually not counted)
    - Auxiliary Space: Extra memory your algorithm uses

    When interviewer says "O(1) space", they mean auxiliary space
    """
    # O(n) input space (the array), O(1) auxiliary space
    def find_max(arr):
        maximum = arr[0]  # Only O(1) extra variable
        for num in arr:
            maximum = max(maximum, num)
        return maximum

    # O(n) auxiliary space - we create new data structure
    def duplicate_array(arr):
        return arr[:]  # Creates copy = O(n) extra space
</code></pre>
        <h3 id="amortized-analysis">Amortized Analysis</h3>
        <pre><code class="language-python"># AMORTIZED O(1) - Critical for Dynamic Arrays
def understand_amortized():
    """
    ArrayList/Python list resize:
    - Usually O(1) append
    - Occasionally O(n) when resize needed
    - Amortized: O(1) over many operations

    INTERVIEW TRAP: Know when to say "amortized O(1)"
    Examples:
    - list.append() in Python: Amortized O(1)
    - HashMap insert: Amortized O(1) (due to rehashing)
    """
    # Amortized analysis example
    arr = []
    for i in range(n):  # n appends
        arr.append(i)   # Each amortized O(1)
    # Total: O(n), not O(nÂ²)
</code></pre>
        <h3 id="best-average-worst-cases">Best/Average/Worst Cases</h3>
        <pre>
Algorithm Analysis Cases:
â”œâ”€ Best Case: Usually less useful (too optimistic)
â”œâ”€ Average Case: What you typically expect
â””â”€ Worst Case: What interviewers care about most

Examples:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Algorithm   â”‚ Best     â”‚ Average  â”‚ Worst    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Quick Sort  â”‚ O(n lg n)â”‚ O(n lg n)â”‚ O(nÂ²)    â”‚
â”‚ Binary Searchâ”‚ O(1)    â”‚ O(log n) â”‚ O(log n) â”‚
â”‚ Hash Lookup â”‚ O(1)     â”‚ O(1)     â”‚ O(n)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        </pre>
        <h2 id="common-interview-tricks">Common Interview Tricks & Techniques</h2>
        <h3 id="two-pointer-variants">Two Pointer Variants to Master</h3>
        <pre><code class="language-python"># CONFLICTING TWO POINTERS (Trapping Rain Water Approach)
def trap_rain_water(height):
    """
    ADVANCED PATTERN: When answer depends on both sides
    Track maximum from left AND right simultaneously

    Used in: Trapping Rain Water, Container With Most Water
    """
    if not height:
        return 0

    left, right = 0, len(height) - 1
    left_max, right_max = height[left], height[right]
    water = 0

    while left &lt; right:
        if left_max &lt; right_max:
            left += 1
            left_max = max(left_max, height[left])
            water += left_max - height[left]
        else:
            right -= 1
            right_max = max(right_max, height[right])
            water += right_max - height[right]

    return water
</code></pre>
        <h3 id="complexity-reduction-patterns">Complexity Reduction Patterns</h3>
        <pre>
Common Optimization Patterns:
â”œâ”€ O(nÂ²) â†’ O(n): Use HashMap for lookup
â”œâ”€ O(nÂ²) â†’ O(n log n): Sort + Two Pointers
â”œâ”€ O(n) â†’ O(log n): Binary Search on sorted data
â”œâ”€ O(2^n) â†’ O(n*2^n): Bitmask DP
â””â”€ O(n!) â†’ O(n*2^n): Bitmask DP for permutations
        </pre>
        <hr />
        <h1 id="phase-1-foundation">PHASE 1: FOUNDATION ğŸ—ï¸</h1>
        <h2 id="1-arrays-hashing">1. ARRAYS &amp; HASHING ğŸ”‘</h2>
        <p><span style="background: #2563eb; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em;">ğŸ“Œ
                WEEK 1-2</span> <strong>Difficulty:</strong> <span style="color: green">â˜…â˜†â˜†</span> | <strong>Foundation
                Level</strong></p>
        <h3 id="core-concept">Core Concept</h3>
        <p>Transform O(nÂ²) brute force into O(n) using hash tables for instant lookups. Think: "Do I need to remember
            what I've seen?"</p>
        <h3 id="when-to-use">When to Use</h3>
        <ul>
            <li>âœ… Counting frequencies/occurrences</li>
            <li>âœ… Detecting duplicates/anagrams</li>
            <li>âœ… Finding complements (two sum pattern)</li>
            <li>âœ… Grouping related items</li>
            <li>âœ… Mapping indices to values</li>
            <li><strong>Signal Words:</strong> "unique", "frequency", "group by", "find pair that sums to"</li>
        </ul>
        <h3 id="sub-patterns">Sub-Patterns</h3>
        <h4 id="11-frequency-counter-pattern">1.1 Frequency Counter Pattern</h4>
        <p><strong>Use Case:</strong> Count occurrences, find majority elements, top K frequent</p>
        <pre><code class="language-python">from collections import Counter

        def top_k_frequent(nums, k):
            # O(n) time, O(n) space
            count = Counter(nums)
            # Counter returns most common in O(n log k) for heap
            return [num for num, freq in count.most_common(k)]

        # Alternative: Bucket sort for O(n)
        def top_k_bucket(nums, k):
            count = Counter(nums)
            buckets = [[] for _ in range(len(nums) + 1)]
            for num, freq in count.items():
                buckets[freq].append(num)

            result = []
            for i in range(len(buckets) - 1, 0, -1):
                result.extend(buckets[i])
                if len(result) &gt;= k:
                    return result[:k]
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="12-index-mapping-pattern-two-sum-family">1.2 Index Mapping Pattern (Two Sum Family)</h4>
        <p><strong>Use Case:</strong> Find pairs, triplets that meet conditions</p>
        <pre><code class="language-python">def two_sum(nums, target):
            &quot;&quot;&quot;
            Store what we've seen with indices
            Key insight: target - current = complement we need
            &quot;&quot;&quot;
            seen = {}  # value: index
            for i, num in enumerate(nums):
                complement = target - num
                if complement in seen:
                    return [seen[complement], i]
                seen[num] = i
            return []

        def two_sum_all_pairs(nums, target):
            &quot;&quot;&quot;Find ALL pairs (not indices)&quot;&quot;&quot;
            seen = set()
            pairs = set()
            for num in nums:
                complement = target - num
                if complement in seen:
                    pairs.add((min(num, complement), max(num, complement)))
                seen.add(num)
            return list(pairs)
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="13-grouping-pattern-anagrams-etc">1.3 Grouping Pattern (Anagrams, etc.)</h4>
        <p><strong>Use Case:</strong> Group items by some computed key</p>
        <pre><code class="language-python">from collections import defaultdict

        def group_anagrams(strs):
            &quot;&quot;&quot;
            Key insight: Anagrams have same character frequency
            Use sorted string or char count as key
            &quot;&quot;&quot;
            groups = defaultdict(list)

            for s in strs:
                # Method 1: Sorted string as key - O(k log k) per string
                key = ''.join(sorted(s))

                # Method 2: Character count - O(k) per string
                # key = tuple(sorted(Counter(s).items()))

                groups[key].append(s)

            return list(groups.values())
        </code></pre>
        <p><strong>Time:</strong> O(n * k log k) where k = avg string length | <strong>Space:</strong> O(nk)</p>
        <h4 id="14-running-computation-pattern">1.4 Running Computation Pattern</h4>
        <p><strong>Use Case:</strong> Prefix sums, cumulative products</p>
        <pre><code class="language-python">def product_except_self(nums):
            &quot;&quot;&quot;
            Key insight: result[i] = (product of all left) * (product of all right)
            Use two passes instead of division
            &quot;&quot;&quot;
            n = len(nums)
            result = [1] * n

            # Left pass: result[i] = product of all nums[0..i-1]
            left_product = 1
            for i in range(n):
                result[i] = left_product
                left_product *= nums[i]

            # Right pass: multiply by product of all nums[i+1..n-1]
            right_product = 1
            for i in range(n - 1, -1, -1):
                result[i] *= right_product
                right_product *= nums[i]

            return result
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1) excluding output</p>
        <h4 id="15-dutch-national-flag">1.5 Dutch National Flag (3-Way Partitioning)</h4>
        <p><strong>Use Case:</strong> Sort array with 3 distinct values in-place (FAANG FAVORITE)</p>
        <pre><code class="language-python">def sort_colors(nums):
    """
    DUTCH NATIONAL FLAG ALGORITHM
    Sort 0s, 1s, 2s in-place with ONE PASS

    Three pointers:
    - low: boundary for 0s (next position for 0)
    - mid: current element being examined
    - high: boundary for 2s (next position for 2)

    Key: Everything before low is 0, after high is 2
    """
    low, mid, high = 0, 0, len(nums) - 1

    while mid &lt;= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:  # nums[mid] == 2
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
            # Don't increment mid - need to check swapped element
</code></pre>
        <p><strong>Time:</strong> O(n) single pass | <strong>Space:</strong> O(1)</p>
        <h3 id="common-traps">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Hash Collisions</strong>: Rare in Python, but use tuple for composite keys</li>
            <li>âŒ <strong>Mutable Keys</strong>: Lists can't be dict keys - use tuples</li>
            <li>âŒ <strong>Space Explosion</strong>: O(n) space acceptable for n &lt; 10^6</li>
            <li>âŒ <strong>Empty Input</strong>: Always check <code>if not nums: return []</code></li>
            <li>âŒ <strong>Order Matters</strong>: Hash sets lose order - use dict if order matters (Python 3.7+)</li>
        </ul>
        <h3 id="complexity-analysis">Complexity Analysis</h3>
        <ul>
            <li><strong>Hash Insert/Lookup</strong>: O(1) average, O(n) worst case</li>
            <li><strong>Counter Creation</strong>: O(n)</li>
            <li><strong>Space</strong>: O(n) for hash table</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Frequency/Count? â†’ Hash Map/Set
        â”œâ”€ Duplicate check? â†’ Hash Set
        â”œâ”€ Pair/Sum finding? â†’ Hash Map (Two Sum)
        â”œâ”€ Anagrams? â†’ Sort or Hash Map (Count)
        â”œâ”€ Prefix Sum? â†’ Continuous sub-array sum
        â””â”€ Sliding Window? â†’ Contiguous subarray/substring
        </pre>
        <h3 id="must-know-problems">Must-Know Problems</h3>
        <h4 id="easy-master-these-first">Easy (Master These First)</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/contains-duplicate/">Contains Duplicate</a> (217)
                - Set basics
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-anagram/">Valid Anagram</a> (242) -
                Frequency count</li>
            <li><a target="_blank" href="https://leetcode.com/problems/two-sum/">Two Sum</a> (1) - Index mapping â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/majority-element/">Majority Element</a> (169) -
                Boyer-Moore or
                hash</li>
            <li><a target="_blank" href="https://leetcode.com/problems/roman-to-integer/">Roman to Integer</a> (13) -
                Mapping pattern
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-element/">Remove Element</a> (27)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-common-prefix/">Longest Common Prefix</a>
                (14)</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/">Find the
                    Index of the First Occurrence in a String</a> (28)</li>
        </ol>
        <h4 id="medium-core-pattern-practice">Medium (Core Pattern Practice)</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/group-anagrams/">Group Anagrams</a> (49) -
                Grouping pattern â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/top-k-frequent-elements/">Top K Frequent
                    Elements</a> (347) -
                Frequency + heap/bucket</li>
            <li><a target="_blank" href="https://leetcode.com/problems/product-of-array-except-self/">Product of Array
                    Except Self</a>
                (238) - Running computation â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a> (36) - Multiple
                hash sets</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-consecutive-sequence/">Longest
                    Consecutive Sequence</a>
                (128) - Set membership â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/encode-and-decode-strings/">Encode and Decode
                    Strings</a> (271) - String manipulation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/rotate-array/">Rotate Array</a> (189)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/subarray-sum-equals-k/">Subarray Sum Equals K</a>
                (560) - Prefix Sum â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/sort-colors/">Sort Colors</a> (75) - Dutch
                National Flag â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/4sum/">4Sum</a> (18) - Extension of 3Sum</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/">Longest
                    Substring with At Most K Distinct Characters</a> (340) â­</li>
        </ol>
        <h4 id="hard-arrays">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water</a>
                (42) - Two Pointer variant â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/first-missing-positive/">First Missing
                    Positive</a> (41) - Array manipulation</li>
        </ol>
        <hr />
        <h2 id="2-two-pointers">2. TWO POINTERS ğŸ‘‰ğŸ‘ˆ</h2>
        <p><strong>Difficulty:</strong> <span style="color: green">â˜…â˜†â˜†</span> | <strong>Builds on:</strong> Arrays</p>
        <h3 id="core-concept_1">Core Concept</h3>
        <p>Reduce O(nÂ²) nested loops to O(n) by using two pointers that move based on conditions. Think: "Can I
            eliminate one dimension by smart pointer movement?"</p>
        <h3 id="when-to-use_1">When to Use</h3>
        <ul>
            <li>âœ… <strong>Sorted arrays</strong> for pair/triplet finding</li>
            <li>âœ… In-place array modifications</li>
            <li>âœ… Palindrome validation</li>
            <li>âœ… Partitioning/segregating elements</li>
            <li>âœ… Finding cycles (fast-slow pointer)</li>
            <li><strong>Signal Words:</strong> "sorted", "pair", "palindrome", "in-place", "two ends"</li>
        </ul>
        <h3 id="sub-patterns_1">Sub-Patterns</h3>
        <h4 id="21-opposite-direction-collision">2.1 Opposite Direction (Collision)</h4>
        <p><strong>Use Case:</strong> Sorted array pair problems, palindromes</p>
        <pre><code class="language-python">def two_sum_sorted(nums, target):
            &quot;&quot;&quot;
            PREREQUISITE: Array must be sorted
            Pointers converge from ends based on sum comparison
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt; right:
                current_sum = nums[left] + nums[right]

                if current_sum == target:
                    return [left, right]
                elif current_sum &lt; target:
                    left += 1  # Need larger sum
                else:
                    right -= 1  # Need smaller sum

            return []

        def is_palindrome(s):
            &quot;&quot;&quot;
            Clean and check from both ends
            Key: Skip non-alphanumeric characters
            &quot;&quot;&quot;
            left, right = 0, len(s) - 1

            while left &lt; right:
                # Skip non-alphanumeric
                while left &lt; right and not s[left].isalnum():
                    left += 1
                while left &lt; right and not s[right].isalnum():
                    right -= 1

                if s[left].lower() != s[right].lower():
                    return False

                left += 1
                right -= 1

            return True
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="22-same-direction-fast-slow">2.2 Same Direction (Fast-Slow)</h4>
        <p><strong>Use Case:</strong> Remove duplicates, move zeros, cycle detection</p>
        <pre><code class="language-python">def remove_duplicates(nums):
            &quot;&quot;&quot;
            Slow pointer = position to place next unique
            Fast pointer = explorer finding next unique
            Works on SORTED array only
            &quot;&quot;&quot;
            if not nums:
                return 0

            slow = 1  # Position for next unique element

            for fast in range(1, len(nums)):
                if nums[fast] != nums[slow - 1]:
                    nums[slow] = nums[fast]
                    slow += 1

            return slow  # New length

        def move_zeros(nums):
            &quot;&quot;&quot;
            Slow = position for next non-zero
            Fast = explorer finding non-zeros
            &quot;&quot;&quot;
            slow = 0

            for fast in range(len(nums)):
                if nums[fast] != 0:
                    nums[slow], nums[fast] = nums[fast], nums[slow]
                    slow += 1
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="23-three-pointers-3sum-pattern">2.3 Three Pointers (3Sum Pattern)</h4>
        <p><strong>Use Case:</strong> Finding triplets in sorted array</p>
        <pre><code class="language-python">def three_sum(nums):
            &quot;&quot;&quot;
            Fix one number, use two pointers for remaining pair
            MUST sort first: O(n log n)
            Total: O(nÂ²) - acceptable for n &lt; 1000
            &quot;&quot;&quot;
            nums.sort()
            result = []

    for i in range(len(nums) - 2):
    # Skip duplicates for first number
    if i &gt; 0 and nums[i] == nums[i-1]:
    continue

    left, right = i + 1, len(nums) - 1
    target = -nums[i]

    while left &lt; right:
    current_sum = nums[left] + nums[right]

    if current_sum == target:
    result.append([nums[i], nums[left], nums[right]])

    # Skip duplicates for second number
    while left &lt; right and nums[left] == nums[left + 1]:
    left += 1
    # Skip duplicates for third number
    while left &lt; right and nums[right] == nums[right - 1]:
    right -= 1

    left += 1
    right -= 1
    elif current_sum &lt; target:
    left += 1
    else:
    right -= 1

    return result
    </code></pre>
        <p><strong>Time:</strong> O(nÂ²) | <strong>Space:</strong> O(1) excluding output</p>
        <h4 id="24-sliding-window-with-two-pointers">2.4 Sliding Window with Two Pointers</h4>
        <p><strong>Use Case:</strong> Variable-size windows (covered more in Pattern 3)</p>
        <pre><code class="language-python">def container_with_most_water(height):
        &quot;&quot;&quot;
        Key insight: Move pointer with smaller height
        Why? Larger height might form bigger area with other side
        &quot;&quot;&quot;
        left, right = 0, len(height) - 1
        max_area = 0

        while left &lt; right:
            # Area limited by shorter height
            width = right - left
            current_area = width * min(height[left], height[right])
            max_area = max(max_area, current_area)

            # Move the pointer with smaller height
            if height[left] &lt; height[right]:
                left += 1
            else:
                right -= 1

        return max_area
    </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h3 id="common-traps_1">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Unsorted Input</strong>: Two-pointer collision only works on sorted data</li>
            <li>âŒ <strong>Duplicate Handling</strong>: Must skip duplicates in 3Sum to avoid duplicate triplets</li>
            <li>âŒ <strong>Boundary Conditions</strong>: Use <code>left &lt; right</code> not
                <code>left &lt;= right</code> for
                collision
            </li>
            <li>âŒ <strong>Off-by-One</strong>: Initialize slow pointer correctly (often 0 or 1)</li>
            <li>âŒ <strong>Modifying While Iterating</strong>: Use slow pointer for in-place modifications</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre><code>Is array sorted?
    â”œâ”€ Yes â†’ Use collision (opposite direction)
    â”‚   â””â”€ Finding pair/sum? â†’ Start from ends, converge
    â””â”€ No â†’ Can you sort? (O(n log n) acceptable?)
        â”œâ”€ Yes â†’ Sort then use two pointers
        â””â”€ No â†’ Use hash table (Pattern 1) or sliding window (Pattern 3)
    </code></pre>

        <h3 id="must-know-problems_1">Must-Know Problems</h3>
        <h4 id="easy">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome</a> (125) -
                Collision pattern
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove
                    Duplicates from
                    Sorted Array</a> (26) - Fast-slow â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array</a> (88)
                - Reverse
                collision</li>
            <li><a target="_blank" href="https://leetcode.com/problems/is-subsequence/">Is Subsequence</a> (392) - Same
                direction</li>
        </ol>
        <h4 id="medium">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/3sum/">3Sum</a> (15) - Three pointers â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/container-with-most-water/">Container With Most
                    Water</a> (11) -
                Greedy collision â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">Remove
                    Duplicates from
                    Sorted Array II</a> (80) - Fast-slow variant</li>
            <li><a target="_blank" href="https://leetcode.com/problems/h-index/">H-Index</a> (274)</li>
        </ol>
        <h4 id="hard">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/candy/">Candy</a> (135)</li>
        </ol>
        <hr />
        <h2 id="3-sliding-window">3. SLIDING WINDOW ğŸªŸ</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Builds on:</strong> Two
            Pointers, Hashing</p>
        <h3 id="core-concept_2">Core Concept</h3>
        <p>Maintain a dynamic window that expands/contracts to satisfy conditions. Converts O(nÂ²) "check all subarrays"
            to O(n) by reusing computation.</p>
        <h3 id="when-to-use_2">When to Use</h3>
        <ul>
            <li>âœ… <strong>Contiguous</strong> subarray/substring problems</li>
            <li>âœ… "Longest/shortest/maximum in subarray"</li>
            <li>âœ… "At most K" or "exactly K" constraints</li>
            <li>âœ… String permutation/anagram problems</li>
            <li><strong>Signal Words:</strong> "subarray", "substring", "contiguous", "window", "at most K"</li>
        </ul>
        <h3 id="sub-patterns_2">Sub-Patterns</h3>
        <h4 id="31-fixed-window-size">3.1 Fixed Window Size</h4>
        <p><strong>Use Case:</strong> Max sum of K elements, sliding average</p>
        <pre><code class="language-python">def max_sum_subarray_k(nums, k):
            &quot;&quot;&quot;
            Window size is constant K
            Slide by: add right element, remove left element
            &quot;&quot;&quot;
            if len(nums) &lt; k:
                return 0

            # Initialize first window
            window_sum = sum(nums[:k])
            max_sum = window_sum

            # Slide window
            for i in range(k, len(nums)):
                window_sum += nums[i] - nums[i - k]  # Add right, remove left
                max_sum = max(max_sum, window_sum)

            return max_sum

        def find_anagrams(s, p):
            &quot;&quot;&quot;
            Fixed window = len(p)
            Check if window is permutation of p
            &quot;&quot;&quot;
            if len(p) &gt; len(s):
                return []

            from collections import Counter
            p_count = Counter(p)
            window_count = Counter(s[:len(p)])
            result = []

            if window_count == p_count:
                result.append(0)

            for i in range(len(p), len(s)):
                # Add new character
                window_count[s[i]] += 1

                # Remove old character
                left_char = s[i - len(p)]
                window_count[left_char] -= 1
                if window_count[left_char] == 0:
                    del window_count[left_char]

                if window_count == p_count:
                    result.append(i - len(p) + 1)

            return result
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1) or O(k) for frequency map</p>
        <h4 id="32-dynamic-window-shrinkable-most-common">3.2 Dynamic Window - Shrinkable (Most Common)</h4>
        <p><strong>Use Case:</strong> Longest substring with K distinct, minimum window substring</p>
        <pre><code class="language-python">def length_of_longest_substring_k_distinct(s, k):
            &quot;&quot;&quot;
            TEMPLATE FOR DYNAMIC WINDOW:
            1. Expand right until invalid
            2. Shrink left while invalid
            3. Update result when valid
            &quot;&quot;&quot;
            from collections import defaultdict

            char_count = defaultdict(int)
            left = 0
            max_length = 0

            for right in range(len(s)):
                # Expand: add right character
                char_count[s[right]] += 1

                # Shrink: while invalid (too many distinct)
                while len(char_count) &gt; k:
                    char_count[s[left]] -= 1
                    if char_count[s[left]] == 0:
                        del char_count[s[left]]
                    left += 1

                # Update result when valid
                max_length = max(max_length, right - left + 1)

            return max_length

        def longest_substring_without_repeating(s):
            &quot;&quot;&quot;
            Special case: K = 1 (each char appears at most once)
            Use set or dict to track last seen index
            &quot;&quot;&quot;
            char_index = {}
            left = 0
            max_length = 0

            for right in range(len(s)):
                # If seen and within window, shrink from left
                if s[right] in char_index and char_index[s[right]] &gt;= left:
                    left = char_index[s[right]] + 1

                char_index[s[right]] = right
                max_length = max(max_length, right - left + 1)

            return max_length
</code></pre>
        <p><strong>Time:</strong> O(n) - each element visited at most twice | <strong>Space:</strong> O(k)</p>
        <h4 id="33-dynamic-window-non-shrinkable-optimization">3.3 Dynamic Window - Non-Shrinkable (Optimization)</h4>
        <p><strong>Use Case:</strong> When you only care about maximum window size</p>
        <pre><code class="language-python">def length_longest_substring_k_distinct_optimized(s, k):
            &quot;&quot;&quot;
            OPTIMIZATION: Keep window at max size, only expand
            If invalid, move both pointers (maintain size)
            Only expand when valid
            &quot;&quot;&quot;
            from collections import defaultdict

            char_count = defaultdict(int)
            left = 0

            for right in range(len(s)):
                char_count[s[right]] += 1

                # If invalid, move both pointers (don't shrink window)
                if len(char_count) &gt; k:
                    char_count[s[left]] -= 1
                    if char_count[s[left]] == 0:
                        del char_count[s[left]]
                    left += 1

            return right - left + 1  # Final window size is the answer
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(k)</p>
        <h4 id="34-minimum-window-substring-hard-pattern">3.4 Minimum Window Substring (Hard Pattern)</h4>
        <p><strong>Use Case:</strong> Find smallest window containing all characters</p>
        <pre><code class="language-python">def min_window_substring(s, t):
            &quot;&quot;&quot;
            HARD TEMPLATE:
            1. Expand until valid (contains all t chars)
            2. Shrink while still valid (minimize)
            3. Track minimum
            &quot;&quot;&quot;
            from collections import Counter

            if not s or not t:
                return &quot;&quot;

            required = Counter(t)
            needed = len(required)  # Unique chars needed
            formed = 0  # Unique chars satisfied

            window_counts = {}
            left = 0
            min_len = float('inf')
            min_left = 0

            for right in range(len(s)):
                # Expand: add right character
                char = s[right]
                window_counts[char] = window_counts.get(char, 0) + 1

                # Check if this char satisfies requirement
                if char in required and window_counts[char] == required[char]:
                    formed += 1

                # Shrink: while valid (all chars present)
                while formed == needed and left &lt;= right:
                    # Update result
                    if right - left + 1 &lt; min_len:
                        min_len = right - left + 1
                        min_left = left

                    # Remove left character
                    char = s[left]
                    window_counts[char] -= 1
                    if char in required and window_counts[char] &lt; required[char]:
                        formed -= 1

                    left += 1

            return &quot;&quot; if min_len == float('inf') else s[min_left:min_left + min_len]
        </code></pre>
        <p><strong>Time:</strong> O(n + m) | <strong>Space:</strong> O(m) where m = len(t)</p>
        <h3 id="common-traps_2">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Nested Loops</strong>: Should NEVER have nested while loops iterating - only shrink loop
                inside expand
            </li>
            <li>âŒ <strong>When to Update Result</strong>:
                <ul>
                    <li>Maximum: Update when valid</li>
                    <li>Minimum: Update while valid (during shrink phase)</li>
                </ul>
            </li>
            <li>âŒ <strong>Counter Cleanup</strong>: Always <code>del dict[key]</code> when count reaches 0</li>
            <li>âŒ <strong>Empty Window</strong>: Check <code>if not s: return ""</code></li>
            <li>âŒ <strong>Fixed vs Dynamic</strong>: Fixed = add/remove one at a time, Dynamic = shrink in while loop
            </li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre><code>Subarray/substring problem?
        â”œâ”€ Fixed size K given?
        â”‚   â””â”€ Use Fixed Window (3.1)
        â””â”€ Variable size (find longest/shortest)?
            â”œâ”€ Find LONGEST with constraint?
            â”‚   â””â”€ Use Dynamic Shrinkable (3.2)
            â”‚       â””â”€ Only care about max size? Use Non-shrinkable (3.3)
            â””â”€ Find SHORTEST/MINIMUM?
                â””â”€ Use Minimum Window (3.4) - shrink while valid
        </code></pre>

        <h3 id="must-know-problems_2">Must-Know Problems</h3>
        <h4 id="easy_1">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to
                    Buy and Sell
                    Stock</a> (121) - Min tracking</li>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to
                    Buy and Sell
                    Stock II</a> (122)</li>
        </ol>
        <h4 id="medium_1">Medium</h4>
        <ol>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest
                    Substring Without Repeating Characters</a> (3) - Classic template â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-repeating-character-replacement/">Longest
                    Repeating
                    Character Replacement</a> (424) - With K changes</li>
            <li><a target="_blank" href="https://leetcode.com/problems/permutation-in-string/">Permutation in String</a>
                (567) - Fixed
                window variant</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-size-subarray-sum/">Minimum Size Subarray
                    Sum</a> (209) -
                Minimum window â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">Find All Anagrams
                    in a String</a> (438) - Optimization of generic template</li>
        </ol>
        <h4 id="hard">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-window-substring/">Minimum Window
                    Substring</a> (76) -
                Master template â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window
                    Maximum</a> (239) - With
                deque</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">Substring with
                    Concatenation of All Words</a> (30) - Complex fixed window</li>
        </ol>
        <hr />
        <h1 id="phase-2-searching-basic-data-structures">PHASE 2: POINTER TECHNIQUES ğŸ‘‰</h1>
        <h2 id="4-binary-search">4. BINARY SEARCH ğŸ¯</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Builds on:</strong> Arrays, Two
            Pointers</p>
        <h3 id="core-concept_3">Core Concept</h3>
        <p>Halve search space on monotonic functions by eliminating impossible halves. Reduces O(n) to O(log n).</p>
        <h3 id="when-to-use_3">When to Use</h3>
        <ul>
            <li>âœ… <strong>Sorted arrays</strong> (ascending/descending)</li>
            <li>âœ… Finding boundaries/first/last occurrence</li>
            <li>âœ… Search in rotated arrays</li>
            <li>âœ… Minimize/maximize answer (answer binary search)</li>
            <li>âœ… Implicit sorted search space</li>
            <li><strong>Signal Words:</strong> "sorted", "find position", "minimize maximum", "maximize minimum"</li>
        </ul>
        <h3 id="sub-patterns_3">Sub-Patterns</h3>
        <h4 id="41-standard-binary-search-exact-match">4.1 Standard Binary Search (Exact Match)</h4>
        <p><strong>Use Case:</strong> Find exact target in sorted array</p>
        <pre><code class="language-python">def binary_search(nums, target):
            &quot;&quot;&quot;
            TEMPLATE 1: Find exact value
            - Use when target MUST exist or return -1
            - Loop condition: left &lt;= right (can check single element)
            - Return: mid when found, -1 if not found
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt;= right:
                mid = left + (right - left) // 2  # Avoid overflow in other languages

                if nums[mid] == target:
                    return mid
                elif nums[mid] &lt; target:
                    left = mid + 1  # Search right half
                else:
                    right = mid - 1  # Search left half

            return -1  # Not found
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <p><strong>Key Points:</strong><br />
            - <code>left &lt;= right</code> allows checking single element<br />
            - Move left/right by <code>mid Â±1</code> to avoid infinite loop<br />
            - Result is at <code>mid</code> or not found</p>
        <h4 id="42-lower-bound-first-target">4.2 Lower Bound (First &gt;= Target)</h4>
        <p><strong>Use Case:</strong> Find first position where value &gt;= target, insertion point</p>
        <pre><code class="language-python">def lower_bound(nums, target):
            &quot;&quot;&quot;
            TEMPLATE 2: Find leftmost position &gt;= target
            - Use for: insertion index, first occurrence
            - Loop condition: left &lt; right (stops when left == right)
            - Return: left (insertion point, may be len(nums))
            &quot;&quot;&quot;
            left, right = 0, len(nums)  # Note: right = len(nums), not len(nums)-1

            while left &lt; right:
                mid = left + (right - left) // 2

                if nums[mid] &lt; target:
                    left = mid + 1  # Answer is to the right
                else:
                    right = mid  # nums[mid] &gt;= target, could be answer, keep it

            return left  # First position where nums[left] &gt;= target

        def search_insert_position(nums, target):
            &quot;&quot;&quot;
            LeetCode 35: Find index to insert target
            Same as lower_bound
            &quot;&quot;&quot;
            return lower_bound(nums, target)

        def first_occurrence(nums, target):
            &quot;&quot;&quot;
            Find first occurrence of target
            &quot;&quot;&quot;
            idx = lower_bound(nums, target)
            if idx &lt; len(nums) and nums[idx] == target:
                return idx
            return -1
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <h4 id="43-upper-bound-first-target">4.3 Upper Bound (First &gt; Target)</h4>
        <p><strong>Use Case:</strong> Find first position where value &gt; target</p>
        <pre><code class="language-python">def upper_bound(nums, target):
            &quot;&quot;&quot;
            TEMPLATE 3: Find leftmost position &gt; target
            - Use for: last occurrence, count of elements
            - Return: left (first position &gt; target)
            &quot;&quot;&quot;
            left, right = 0, len(nums)

    while left &lt; right:
    mid = left + (right - left) // 2

    if nums[mid] &lt;= target: # Note: &lt;= instead of
    left = mid + 1
    else:
    right = mid

    return left

    def last_occurrence(nums, target):
    &quot;&quot;&quot;
    Find last occurrence of target
    &quot;&quot;&quot;
    idx = upper_bound(nums, target) - 1
    if idx &gt;= 0 and nums[idx] == target:
    return idx
    return -1

    def count_occurrences(nums, target):
    &quot;&quot;&quot;
    Count how many times target appears
    &quot;&quot;&quot;
    first = lower_bound(nums, target)
    last = upper_bound(nums, target)
    return last - first # Will be 0 if target not present
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <h4 id="44-binary-search-on-answer">4.4 Binary Search on Answer</h4>
        <p><strong>Use Case:</strong> Minimize maximum, maximize minimum - search space is implicit</p>
        <pre><code class="language-python">def koko_eating_bananas(piles, h):
            &quot;&quot;&quot;
            Find minimum eating speed K such that:
            - Can finish all piles in H hours
            - Search space: [1, max(piles)]

            KEY INSIGHT: If speed K works, then K+1, K+2... also work
            This creates monotonicity for binary search
            &quot;&quot;&quot;
            def can_finish(speed):
                &quot;&quot;&quot;Helper: Can we finish with this speed?&quot;&quot;&quot;
                hours = 0
                for pile in piles:
                    hours += (pile + speed - 1) // speed  # Ceiling division
                return hours &lt;= h

            left, right = 1, max(piles)
            result = right

            while left &lt;= right:
                mid = left + (right - left) // 2

                if can_finish(mid):
                    result = mid  # Valid, try smaller
                    right = mid - 1
                else:
                    left = mid + 1  # Too slow, need faster

            return result

        def split_array_largest_sum(nums, m):
            &quot;&quot;&quot;
            Minimize the largest sum among m subarrays
            Search space: [max(nums), sum(nums)]
            &quot;&quot;&quot;
            def can_split(max_sum):
                &quot;&quot;&quot;Can we split into m subarrays with each sum &lt;= max_sum?&quot;&quot;&quot;
                subarrays = 1
                current_sum = 0
                for num in nums:
                    if current_sum + num &gt; max_sum:
                        subarrays += 1
                        current_sum = num
                        if subarrays &gt; m:
                            return False
                    else:
                        current_sum += num
                return True

            left, right = max(nums), sum(nums)

            while left &lt; right:
                mid = left + (right - left) // 2
                if can_split(mid):
                    right = mid  # Can do it, try smaller max_sum
                else:
                    left = mid + 1  # Can't do it, need larger max_sum

            return left
        </code></pre>
        <p><strong>Time:</strong> O(n log(max-min)) | <strong>Space:</strong> O(1)</p>
        <p><strong>Answer Binary Search Pattern:</strong><br />
            1. Identify search space [min, max]<br />
            2. Define check function: is value X feasible?<br />
            3. Determine monotonicity (if X works, does X+1/X-1 work?)<br />
            4. Apply binary search to find boundary</p>
        <h4 id="45-rotated-array-search">4.5 Rotated Array Search</h4>
        <p><strong>Use Case:</strong> Search in rotated sorted array</p>
        <pre><code class="language-python">def search_rotated(nums, target):
            &quot;&quot;&quot;
            Key insight: One half is always sorted
            - Determine which half is sorted- Check if target in sorted half
            - If yes, search sorted half; else search other half
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt;= right:
                mid = left + (right - left) // 2

                if nums[mid] == target:
                    return mid

                # Determine which half is sorted
                if nums[left] &lt;= nums[mid]:  # Left half is sorted
                    # Check if target in sorted left half
                    if nums[left] &lt;= target &lt; nums[mid]:
                        right = mid - 1
                    else:
                        left = mid + 1
                else:  # Right half is sorted
                    # Check if target in sorted right half
                    if nums[mid] &lt; target &lt;= nums[right]:
                        left = mid + 1
                    else:
                        right = mid - 1

            return -1

        def find_minimum_rotated(nums):
            &quot;&quot;&quot;
            Find minimum in rotated sorted array
            Key: minimum is in unsorted half
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt; right:
                mid = left + (right - left) // 2

                if nums[mid] &gt; nums[right]:
                    # Minimum is in right half
                    left = mid + 1
                else:
                    # Minimum is in left half (could be mid)
                    right = mid

            return nums[left]
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <h3 id="common-traps_3">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Loop Condition Confusion</strong>:
                <ul>
                    <li><code>left &lt;= right</code>: Use when returning mid or -1 (exact search)</li>
                    <li><code>left &lt; right</code>: Use when returning left/right (bound search)</li>
                </ul>
            </li>
            <li>âŒ <strong>Infinite Loop</strong>: Always use <code>mid + 1</code> or <code>mid - 1</code>, never just
                <code>mid</code>
            </li>
            <li>âŒ <strong>Overflow</strong>: Use <code>mid = left + (right - left) // 2</code> not
                <code>(left + right) // 2</code>
            </li>
            <li>âŒ <strong>Off-by-One</strong>:
                <ul>
                    <li>Exact search: <code>right = len(nums) - 1</code>, loop <code>left &lt;= right</code></li>
                    <li>Bound search: <code>right = len(nums)</code>, loop <code>left &lt; right</code></li>
                </ul>
            </li>
            <li>âŒ <strong>Duplicate Elements</strong>: Standard binary search may not work with duplicates</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre><code>What are you looking for?
        â”œâ”€ Exact value (exists or -1)
        â”‚   â””â”€ Template 1: left &lt;= right, return mid or -1
        â”œâ”€ First position &gt;= target (insertion point)
        â”‚   â””â”€ Template 2: left &lt; right, right = mid, return left
        â”œâ”€ First position &gt; target
        â”‚   â””â”€ Template 3: left &lt; right, nums[mid] &lt;= target, return left
        â”œâ”€ Minimize/maximize something
        â”‚   â””â”€ Template 4: Binary search on answer with feasibility function
        â””â”€ Rotated array
            â””â”€ Template 5: Identify sorted half, adjust search
</code></pre>
        <h3 id="must-know-problems_3">Must-Know Problems</h3>
        <h4 id="easy_2">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-search/">Binary Search</a> (704) -
                Template 1 â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/search-insert-position/">Search Insert
                    Position</a> (35) -
                Template 2 â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/sqrtx/">Sqrt(x)</a> (69) - Answer binary search
            </li>
        </ol>
        <h4 id="medium_2">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Search in
                    Rotated Sorted
                    Array</a> (33) - Template 5 â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find
                    Minimum in Rotated
                    Sorted Array</a> (153) - Rotated variant</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find
                    First and Last Position of Element</a> (34) - Lower/upper bound â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/koko-eating-bananas/">Koko Eating Bananas</a>
                (875) - Answer
                binary search â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-peak-element/">Find Peak Element</a> (162) -
                Mountain array
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/search-a-2d-matrix/">Search a 2D Matrix</a> (74)
                - 2D binary
                search</li>
            <li><a target="_blank" href="https://leetcode.com/problems/time-based-key-value-store/">Time Based Key-Value
                    Store</a> (981)
                - Lower bound application</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">Capacity To Ship
                    Packages Within D Days</a> (1011) - Answer Binary Search</li>
            <li><a target="_blank" href="https://leetcode.com/problems/snapshot-array/">Snapshot Array</a> (1146) -
                Design + Binary Search</li>
        </ol>
        <h4 id="hard_1">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/median-of-two-sorted-arrays/">Median of Two
                    Sorted Arrays</a> (4)
                - Advanced â­â­â­</li>
        </ol>
        <hr />
        <h2 id="5-stack">5. STACK ğŸ“š</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Foundation Pattern</strong></p>
        <h3 id="core-concept_4">Core Concept</h3>
        <p>LIFO (Last In First Out) structure that simulates recursion, tracks recent elements for
            matching/monotonicity. Think: "Do I need to remember recent items and process them in reverse?"</p>
        <h3 id="when-to-use_4">When to Use</h3>
        <ul>
            <li>âœ… Matching pairs (parentheses, brackets)</li>
            <li>âœ… Monotonic problems (next greater/smaller)</li>
            <li>âœ… Expression evaluation (postfix, infix)</li>
            <li>âœ… Undo operations, browser history</li>
            <li>âœ… Depth-first traversal simulation</li>
            <li><strong>Signal Words:</strong> "valid", "matching", "next greater", "nearest", "evaluate expression"
            </li>
        </ul>
        <h3 id="sub-patterns_4">Sub-Patterns</h3>
        <h4 id="51-matchingvalidation-pattern">5.1 Matching/Validation Pattern</h4>
        <p><strong>Use Case:</strong> Valid parentheses, balanced brackets</p>
        <pre><code class="language-python">def is_valid_parentheses(s):
            &quot;&quot;&quot;
            MATCHING TEMPLATE:
            1. Push opening brackets
            2. For closing bracket, check stack top matches
            3. Stack should be empty at end
            &quot;&quot;&quot;
            stack = []
            matching = {')': '(', '}': '{', ']': '['}

            for char in s:
                if char in matching:  # Closing bracket
                    if not stack or stack.pop() != matching[char]:
                        return False
                else:  # Opening bracket
                    stack.append(char)

            return not stack  # Valid if empty

        def remove_outer_parentheses(s):
            &quot;&quot;&quot;
            Remove outer parentheses from each primitive
            Track depth with counter (stack size simulation)
            &quot;&quot;&quot;
            result = []
            depth = 0

            for char in s:
                if char == '(':
                    if depth &gt; 0:  # Not outer
                        result.append(char)
                    depth += 1
                else:  # ')'
                    depth -= 1
                    if depth &gt; 0:  # Not outer
                        result.append(char)

            return ''.join(result)
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="52-monotonic-stack-next-greatersmaller">5.2 Monotonic Stack (Next Greater/Smaller)</h4>
        <p><strong>Use Case:</strong> Next greater element, next warmer temperature, stock span</p>
        <pre><code class="language-python">def next_greater_elements(nums):
            &quot;&quot;&quot;
            MONOTONIC DECREASING STACK TEMPLATE:
            - Maintains decreasing order
            - When encounter larger element, pop all smaller
            - Iterate right-to-left for &quot;next greater to right&quot;

            Key insight: If element A is greater than B,
            B can never be &quot;next greater&quot; for future elements
            &quot;&quot;&quot;
            n = len(nums)
            result = [-1] * n
            stack = []  # Stores indices

            # Iterate from right to left
            for i in range(n - 1, -1, -1):
                # Pop all elements smaller than current
                while stack and nums[stack[-1]] &lt;= nums[i]:
                    stack.pop()

                # Stack top is next greater (if exists)
                if stack:
                    result[i] = nums[stack[-1]]

                stack.append(i)

            return result

        def next_smaller_element(nums):
            &quot;&quot;&quot;
            MONOTONIC INCREASING STACK:
            - For next smaller, maintain increasing order
            - Pop elements &gt;= current
            &quot;&quot;&quot;
            n = len(nums)
            result = [-1] * n
            stack = []

            for i in range(n - 1, -1, -1):
                while stack and nums[stack[-1]] &gt;= nums[i]:
                    stack.pop()

                if stack:
                    result[i] = nums[stack[-1]]

                stack.append(i)

            return result

        def daily_temperatures(temperatures):
            &quot;&quot;&quot;
            How many days until warmer temperature?
            Same as next greater, but return index difference
            &quot;&quot;&quot;
            n = len(temperatures)
            result = [0] * n
            stack = []

            for i in range(n):
                # Pop all days with cooler temperature
                while stack and temperatures[stack[-1]] &lt; temperatures[i]:
                    prev_day = stack.pop()
                    result[prev_day] = i - prev_day

                stack.append(i)

            return result
        </code></pre>
        <p><strong>Time:</strong> O(n) - each element pushed/popped once | <strong>Space:</strong> O(n)</p>
        <p><strong>Monotonic Stack Rules:</strong><br />
            - <strong>Next Greater</strong>: Use decreasing stack, iterate right-to-left<br />
            - <strong>Next Smaller</strong>: Use increasing stack, iterate right-to-left<br />
            - <strong>Previous Greater</strong>: Use decreasing stack, iterate left-to-right<br />
            - <strong>Previous Smaller</strong>: Use increasing stack, iterate left-to-right</p>
        <h4 id="53-expression-evaluation">5.3 Expression Evaluation</h4>
        <p><strong>Use Case:</strong> Calculator, postfix notation, operator precedence</p>
        <pre><code class="language-python">def eval_reverse_polish(tokens):
            &quot;&quot;&quot;
            Postfix (RPN) evaluation
            Operands go on stack, operators pop and compute
            &quot;&quot;&quot;
            stack = []
            operators = {'+', '-', '*', '/'}

            for token in tokens:
                if token in operators:
                    b = stack.pop()
                    a = stack.pop()

                    if token == '+':
                        stack.append(a + b)
                    elif token == '-':
                        stack.append(a - b)
                    elif token == '*':
                        stack.append(a * b)
                    else:  # '/'
                        stack.append(int(a / b))  # Truncate toward zero
                else:
                    stack.append(int(token))

            return stack[0]

        def basic_calculator(s):
            &quot;&quot;&quot;
            Infix with +, -, parentheses
            Use stack for parentheses, track sign
            &quot;&quot;&quot;
            stack = []
            result = 0
            sign = 1
            num = 0

            for char in s:
                if char.isdigit():
                    num = num * 10 + int(char)
                elif char in '+-':
                    result += sign * num
                    num = 0
                    sign = 1 if char == '+' else -1
                elif char == '(':
                    # Push current result and sign onto stack
                    stack.append(result)
                    stack.append(sign)
                    result = 0
                    sign = 1
                elif char == ')':
                    result += sign * num
                    num = 0
                    result *= stack.pop()  # Pop sign
                    result += stack.pop()  # Pop result before '('

            return result + sign * num
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="54-histogramrectangle-pattern">5.4 Histogram/Rectangle Pattern</h4>
        <p><strong>Use Case:</strong> Largest rectangle in histogram, maximal rectangle</p>
        <pre><code class="language-python">def largest_rectangle_histogram(heights):
            &quot;&quot;&quot;
            KEY INSIGHT: For each bar, find left and right boundaries
            where heights are &gt;= current bar's height
            Area = height[i] * (right - left - 1)

            Use monotonic increasing stack
            &quot;&quot;&quot;
            stack = []  # Stores indices
            max_area = 0
            heights.append(0)  # Sentinel to flush stack

            for i in range(len(heights)):
                # While current bar is shorter, calculate area for stack top
                while stack and heights[stack[-1]] &gt; heights[i]:
                    h_idx = stack.pop()
                    height = heights[h_idx]
                    # Width = current index - left boundary - 1
                    width = i if not stack else i - stack[-1] - 1
                    max_area = max(max_area, height * width)

                stack.append(i)

            return max_area

        def trap_rain_water(height):
            &quot;&quot;&quot;
            Can also use stack approach (besides two-pointer)
            Store indices of bars in decreasing order
            &quot;&quot;&quot;
            stack = []
            water = 0

            for i in range(len(height)):
                while stack and height[i] &gt; height[stack[-1]]:
                    bottom = stack.pop()

                    if not stack:
                        break

                    # Water trapped between stack[-1] and i
                    width = i - stack[-1] - 1
                    bounded_height = min(height[i], height[stack[-1]]) - height[bottom]
                    water += width * bounded_height

                stack.append(i)

            return water
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="55-min-stack-max-stack">5.5 Min Stack / Max Stack</h4>
        <p><strong>Use Case:</strong> Stack with O(1) min/max retrieval</p>
        <pre><code class="language-python">class MinStack:
            &quot;&quot;&quot;
            APPROACH 1: Two stacks
            - Main stack stores all values
            - Min stack stores minimums at each level
            &quot;&quot;&quot;
            def __init__(self):
                self.stack = []
                self.min_stack = []

            def push(self, val):
                self.stack.append(val)
                # Push current minimum
                min_val = min(val, self.min_stack[-1] if self.min_stack else val)
                self.min_stack.append(min_val)

            def pop(self):
                self.stack.pop()
                self.min_stack.pop()

            def top(self):
                return self.stack[-1]

            def get_min(self):
                return self.min_stack[-1]

        class MinStackOptimized:
            &quot;&quot;&quot;
            APPROACH 2: Single stack with tuples
            Store (value, current_min) pairs
            &quot;&quot;&quot;
            def __init__(self):
                self.stack = []

            def push(self, val):
                if not self.stack:
                    self.stack.append((val, val))
                else:
                    current_min = min(val, self.stack[-1][1])
                    self.stack.append((val, current_min))

            def pop(self):
                self.stack.pop()

            def top(self):
                return self.stack[-1][0]

            def get_min(self):
                return self.stack[-1][1]
</code></pre>
        <p><strong>Time:</strong> O(1) all operations | <strong>Space:</strong> O(n)</p>
        <h3 id="common-traps_4">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Empty Stack Pop</strong>: Always check <code>if stack:</code> before <code>stack.pop()</code>
            </li>
            <li>âŒ <strong>LIFO Confusion</strong>: Remember it's Last In First Out, not FIFO (queue)</li>
            <li>âŒ <strong>Monotonic Direction</strong>:
                <ul>
                    <li>Decreasing stack for "next greater"</li>
                    <li>Increasing stack for "next smaller"</li>
                </ul>
            </li>
            <li>âŒ <strong>Index vs Value</strong>: For monotonic stack, often better to store indices</li>
            <li>âŒ <strong>Sentinel Values</strong>: Add sentinel (0 for histogram) to flush remaining elements</li>
            <li>âŒ <strong>Iterator Direction</strong>: Right-to-left for "next", left-to-right for "previous"</li>
        </ul>
        <h3 id="decision-tree_1">Decision Tree</h3>
        <pre><code>Need to track recent elements?
        â”œâ”€ Matching brackets/tags?
        â”‚   â””â”€ Use validation pattern (5.1)
        â”œâ”€ Find next/previous greater/smaller?
        â”‚   â””â”€ Use monotonic stack (5.2)
        â”œâ”€ Evaluate expression?
        â”‚   â””â”€ Use evaluation pattern (5.3)
        â”œâ”€ Rectangle/histogram problem?
        â”‚   â””â”€ Use histogram pattern (5.4)
        â””â”€ Need O(1) min/max access?
            â””â”€ Use specialized stack (5.5)
</code></pre>
        <h3 id="must-know-problems_4">Must-Know Problems</h3>
        <h4 id="easy_3">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-parentheses/">Valid Parentheses</a> (20) -
                Matching
                template â­â­</li>
        </ol>
        <h4 id="medium_3">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/min-stack/">Min Stack</a> (155) - Specialized
                stack â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/daily-temperatures/">Daily Temperatures</a> (739)
                - Monotonic
                stack â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">Evaluate
                    Reverse Polish
                    Notation</a> (150) - Expression eval</li>
            <li><a target="_blank" href="https://leetcode.com/problems/generate-parentheses/">Generate Parentheses</a>
                (22) - Backtrack
                + validation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/car-fleet/">Car Fleet</a> (853) - Monotonic stack
                application
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/simplify-path/">Simplify Path</a> (71) - Stack
                for path
                processing</li>
            <li><a target="_blank" href="https://leetcode.com/problems/decode-string/">Decode String</a> (394) - Nested
                structures</li>
            <li><a target="_blank" href="https://leetcode.com/problems/basic-calculator-ii/">Basic Calculator II</a>
                (227) - String Parsing</li>
            <li><a target="_blank" href="https://leetcode.com/problems/asteroid-collision/">Asteroid Collision</a> (735)
                - Collision State</li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-k-digits/">Remove K Digits</a> (402) -
                Monotonic Greedy</li>
        </ol>
        <h4 id="hard_2">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/largest-rectangle-in-histogram/">Largest
                    Rectangle in
                    Histogram</a> (84) - Histogram pattern â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water</a>
                (42) - Advanced
                monotonic</li>
            <li><a target="_blank" href="https://leetcode.com/problems/basic-calculator/">Basic Calculator</a> (224) -
                Expression with
                parentheses â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/text-justification/">Text Justification</a> (68)
                - Greedy String Handling</li>
        </ol>
        <hr />
        <h2 id="6-linked-list">6. LINKED LIST ğŸ”—</h2>
        <p><span style="background: #059669; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em;">ğŸ“Œ
                WEEK 2-3 (with Two Pointers)</span> <strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span>
            | <strong>Builds on:</strong> Two Pointers</p>
        <h3 id="core-concept_5">Core Concept</h3>
        <p>Sequential data structure where each node points to next (and optionally previous). Use pointers for O(1)
            insertions/deletions, but O(n) access. Think: "Can I do this in-place without extra space?"</p>
        <h3 id="when-to-use_5">When to Use</h3>
        <ul>
            <li>âœ… In-place reversals/reordering</li>
            <li>âœ… Cycle detection</li>
            <li>âœ… Merge sorted lists</li>
            <li>âœ… Remove/modify nodes without extra space</li>
            <li>âœ… LRU cache (doubly linked list + hash)</li>
            <li><strong>Signal Words:</strong> "linked list", "in-place", "cycle", "reverse", "merge"</li>
        </ul>
        <h3 id="sub-patterns_5">Sub-Patterns</h3>
        <h4 id="61-two-pointer-techniques">6.1 Two Pointer Techniques</h4>
        <h5 id="fast-slow-floyds-cycle-detection">Fast-Slow (Floyd's Cycle Detection)</h5>
        <p><strong>Use Case:</strong> Find middle, detect cycles, find cycle start</p>
        <pre><code class="language-python">class ListNode:
            def __init__(self, val=0, next=None):
                self.val = val
                self.next = next

        def has_cycle(head):
            &quot;&quot;&quot;
            FLOYD'S ALGORITHM:
            - Slow moves 1 step, fast moves 2 steps
            - If cycle exists, they'll meet
            - If no cycle, fast reaches None
            &quot;&quot;&quot;
            if not head:
                return False

            slow = fast = head

            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next

                if slow == fast:
                    return True

            return False

        def detect_cycle_start(head):
            &quot;&quot;&quot;
            Find where cycle starts:
            1. Detect cycle with fast-slow
            2. Reset slow to head
            3. Move both at same speed until they meet
            &quot;&quot;&quot;
            if not head:
                return None

            slow = fast = head

            # Phase 1: Detect cycle
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow == fast:
                    break
            else:
                return None  # No cycle

            # Phase 2: Find start
            slow = head
            while slow != fast:
                slow = slow.next
                fast = fast.next

            return slow

        def find_middle(head):
            &quot;&quot;&quot;
            Find middle node (for palindrome check, merge sort)
            When fast reaches end, slow is at middle
            &quot;&quot;&quot;
            slow = fast = head

            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next

            return slow
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h5 id="remove-nth-from-end">Remove Nth from End</h5>
        <p><strong>Use Case:</strong> Two-pass becomes one-pass with gap technique</p>
        <pre><code class="language-python">def remove_nth_from_end(head, n):
            &quot;&quot;&quot;
            TECHNIQUE: Maintain n-node gap between fast and slow
            When fast reaches end, slow is at (n+1)th from end

            Use dummy node to handle edge cases (removing head)
            &quot;&quot;&quot;
            dummy = ListNode(0, head)
            slow = fast = dummy

            # Move fast n+1 steps ahead
            for _ in range(n + 1):
                fast = fast.next

            # Move both until fast reaches end
            while fast:
                slow = slow.next
                fast = fast.next

            # Remove nth node
            slow.next = slow.next.next

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="62-reversal-patterns">6.2 Reversal Patterns</h4>
        <h5 id="basic-reversal">Basic Reversal</h5>
        <p><strong>Use Case:</strong> Reverse entire list or sublist</p>
        <pre><code class="language-python">def reverse_list(head):
            &quot;&quot;&quot;
            ITERATIVE REVERSAL:
            - Track prev, curr, next
            - Reverse links one by one
            - Return prev (new head)
            &quot;&quot;&quot;
            prev = None
            curr = head

            while curr:
                next_temp = curr.next  # Save next BEFORE reversing
                curr.next = prev       # Reverse the link
                prev = curr            # Move prev forward
                curr = next_temp       # Move curr forward

            return prev  # New head

        def reverse_between(head, left, right):
            &quot;&quot;&quot;
            Reverse nodes from position left to right
            KEY: Need to track connection points
            &quot;&quot;&quot;
            if not head or left == right:
                return head

            dummy = ListNode(0, head)
            prev_left = dummy

            # Move to node before left
            for _ in range(left - 1):
                prev_left = prev_left.next

            # Reverse from left to right
            prev = None
            curr = prev_left.next
            for _ in range(right - left + 1):
                next_temp = curr.next
                curr.next = prev
                prev = curr
                curr = next_temp

            # Reconnect
            prev_left.next.next = curr  # Connect end of reversed to rest
            prev_left.next = prev       # Connect start to reversed part

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h5 id="reversal-in-k-groups">Reversal in K-Groups</h5>
        <p><strong>Use Case:</strong> Reverse every K nodes</p>
        <pre><code class="language-python">def reverse_k_group(head, k):
            &quot;&quot;&quot;
            HARD PATTERN:
            1. Check if k nodes remaining
            2. Reverse k nodes
            3. Recursively handle rest
            4. Connect parts
            &quot;&quot;&quot;
            # Check if k nodes exist
            curr = head
            for _ in range(k):
                if not curr:
                    return head  # Less than k nodes, return as is
                curr = curr.next

            # Reverse first k nodes
            prev = None
            curr = head
            for _ in range(k):
                next_temp = curr.next
                curr.next = prev
                prev = curr
                curr = next_temp

            # Recursively reverse rest and connect
            head.next = reverse_k_group(curr, k)

            return prev  # New head of this group
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n/k) for recursion</p>
        <h4 id="63-merge-pattern">6.3 Merge Pattern</h4>
        <p><strong>Use Case:</strong> Merge sorted lists, merge k lists</p>
        <pre><code class="language-python">def merge_two_lists(l1, l2):
            &quot;&quot;&quot;
            MERGE TEMPLATE:
            - Use dummy node to simplify edge cases
            - Compare and append smaller
            - Attach remaining
            &quot;&quot;&quot;
            dummy = ListNode(0)
            curr = dummy

            while l1 and l2:
                if l1.val &lt;= l2.val:
                    curr.next = l1
                    l1 = l1.next
                else:
                    curr.next = l2
                    l2 = l2.next
                curr = curr.next

            # Attach remaining
            curr.next = l1 if l1 else l2

            return dummy.next

        def merge_k_lists(lists):
            &quot;&quot;&quot;
            DIVIDE &amp; CONQUER:
            - Merge pairs of lists
            - Repeat until one list remains
            Time: O(N log k) where N = total nodes, k = number of lists
            &quot;&quot;&quot;
            if not lists:
                return None

            while len(lists) &gt; 1:
                merged = []
                for i in range(0, len(lists), 2):
                    l1 = lists[i]
                    l2 = lists[i + 1] if i + 1 &lt; len(lists) else None
                    merged.append(merge_two_lists(l1, l2))
                lists = merged

            return lists[0]

        # Alternative: Heap-based O(N log k)
        import heapq

        def merge_k_lists_heap(lists):
            &quot;&quot;&quot;Use min-heap to always merge smallest&quot;&quot;&quot;
            heap = []

            # Initialize heap with first node of each list
            for i, node in enumerate(lists):
                if node:
                    heapq.heappush(heap, (node.val, i, node))

            dummy = ListNode(0)
            curr = dummy

            while heap:
                val, i, node = heapq.heappop(heap)
                curr.next = node
                curr = curr.next

                if node.next:
                    heapq.heappush(heap, (node.next.val, i, node.next))

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(N log k) | <strong>Space:</strong> O(k) for heap</p>
        <h4 id="64-reorder-pattern">6.4 Reorder Pattern</h4>
        <p><strong>Use Case:</strong> Rearrange nodes in specific patterns</p>
        <pre><code class="language-python">def reorder_list(head):
            &quot;&quot;&quot;
            Reorder L0â†’L1â†’...â†’Ln-1â†’Ln to L0â†’Lnâ†’L1â†’Ln-1â†’...

            STEPS:
            1. Find middle (fast-slow)
            2. Reverse second half
            3. Merge two halves alternately
            &quot;&quot;&quot;
            if not head or not head.next:
                return

            # Step 1: Find middle
            slow = fast = head
            while fast.next and fast.next.next:
                slow = slow.next
                fast = fast.next.next

            # Step 2: Reverse second half
            second = slow.next
            slow.next = None  # Split into two lists

            prev = None
            while second:
                next_temp = second.next
                second.next = prev
                prev = second
                second = next_temp
            second = prev  # Head of reversed second half

            # Step 3: Merge alternately
            first = head
            while second:
                temp1, temp2 = first.next, second.next
                first.next = second
                second.next = temp1
                first, second = temp1, temp2

        def rotate_right(head, k):
            &quot;&quot;&quot;
            Rotate list to right by k places
            Example: 1â†’2â†’3â†’4â†’5, k=2  â†’  4â†’5â†’1â†’2â†’3

            TECHNIQUE:
            1. Make it circular
            2. Find new tail (length - k % length - 1)
            3. Break circle
            &quot;&quot;&quot;
            if not head or not head.next or k == 0:
                return head

            # Find length and connect tail to head
            length = 1
            curr = head
            while curr.next:
                curr = curr.next
                length += 1
            curr.next = head  # Make circular

            # Find new tail position
            k = k % length
            steps_to_new_tail = length - k - 1

            new_tail = head
            for _ in range(steps_to_new_tail):
                new_tail = new_tail.next

            new_head = new_tail.next
            new_tail.next = None

            return new_head
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="65-deep-copy-pattern">6.5 Deep Copy Pattern</h4>
        <p><strong>Use Case:</strong> Clone list with random pointers</p>
        <pre><code class="language-python">def copy_random_list(head):
            &quot;&quot;&quot;
            Clone list where each node has next and random pointer

            APPROACH 1: Hash map
            Pass 1: Create all nodes and store in map
            Pass 2: Set next and random pointers
            &quot;&quot;&quot;
            if not head:
                return None

            # Map old nodes to new nodes
            old_to_new = {}

            # First pass: Create all nodes
            curr = head
            while curr:
                old_to_new[curr] = ListNode(curr.val)
                curr = curr.next

            # Second pass: Set pointers
            curr = head
            while curr:
                if curr.next:
                    old_to_new[curr].next = old_to_new[curr.next]
                if curr.random:
                    old_to_new[curr].random = old_to_new[curr.random]
                curr = curr.next

            return old_to_new[head]

        def copy_random_list_optimal(head):
            &quot;&quot;&quot;
            APPROACH 2: Interweave nodes (no extra space)

            Step 1: Create copy nodes interweaved
            Aâ†’Bâ†’C  becomes  Aâ†’A'â†’Bâ†’B'â†’Câ†’C'

            Step 2: Set random pointers
            A'.random = A.random.next

            Step 3: Separate lists
            &quot;&quot;&quot;
            if not head:
                return None

            # Step 1: Interweave
            curr = head
            while curr:
                copy = ListNode(curr.val)
                copy.next = curr.next
                curr.next = copy
                curr = copy.next

            # Step 2: Set random pointers
            curr = head
            while curr:
                if curr.random:
                    curr.next.random = curr.random.next
                curr = curr.next.next

            # Step 3: Separate
            dummy = ListNode(0)
            copy_curr = dummy
            curr = head
            while curr:
                copy_curr.next = curr.next
                copy_curr = copy_curr.next
                curr.next = curr.next.next
                curr = curr.next

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n) for map, O(1) for optimal</p>
        <h3 id="common-traps_5">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Losing References</strong>: Always save <code>next</code> before modifying pointers
                <pre><code class="language-python"># WRONG
                                                        curr.next = prev
                                                        curr = curr.next # Lost reference!

                                                        # RIGHT
                                                        next_temp = curr.next
                                                        curr.next = prev
                                                        curr = next_temp</code></pre>
            </li>
            <li>âŒ <strong>Dummy Node</strong>: Use for edge cases (empty list, removing head)
                <pre><code class="language-python">dummy = ListNode(0, head)
                # Work with dummy.next
return dummy.next</code></pre>
            </li>
            <li>âŒ <strong>Null Checks</strong>: Always check <code>if node:</code> and <code>if node.next:</code></li>
            <li>âŒ <strong>Cycle Bugs</strong>: In cycle detection, check <code>fast and fast.next</code> before
                accessing
                <code>fast.next.next</code>
            </li>
            <li>âŒ <strong>Off-by-One</strong>: For "remove nth from end", move fast <code>n+1</code> steps</li>
        </ul>
        <h3 id="pattern-recognition-guide">Pattern Recognition Guide</h3>
        <pre><code>Linked list problem?
        â”œâ”€ Need middle/detect cycle?
        â”‚   â””â”€ Fast-slow pointers (6.1)
        â”œâ”€ Reverse list/sublist?
        â”‚   â””â”€ Reversal pattern (6.2)
        â”œâ”€ Merge lists?
        â”‚   â””â”€ Merge pattern (6.3)
        â”œâ”€ Rearrange/reorder?
        â”‚   â””â”€ Reorder pattern (6.4)
        â””â”€ Clone with complex pointers?
            â””â”€ Deep copy pattern (6.5)
        </code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Traversal?
        â”‚ â”œâ”€ Cycle/Middle? â†’ Fast/Slow Pointers
        â”‚ â””â”€ Intersection? â†’ Difference in length
        â”œâ”€ Reversal?
        â”‚ â”œâ”€ Full? â†’ Iterative (3 pointers)
        â”‚ â””â”€ Partial (k-groups)? â†’ Stack or Recursive
        â”œâ”€ Merging?
        â”‚ â””â”€ Sorted? â†’ Merge patterns (Dummy node)
        â””â”€ Deep Copy? â†’ Hash Map (Old -> New)
        </pre>
        <h3 id="must-know-problems_5">Must-Know Problems</h3>
        <h4 id="easy_4">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List</a>
                (206) - Basic
                reversal â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle</a> (141) -
                Floyd's
                algorithm â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-
                two-sorted-lists/">Merge Two Sorted Lists</a> (21) - Merge pattern â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List
                    Elements</a>
                (203) - Deletion</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindrome-linked-list/">Palindrome Linked
                    List</a> (234) -
                Reverse + compare</li>
        </ol>
        <h4 id="medium_4">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/reorder-list/">Reorder List</a> (143) -
                Multi-step pattern â­â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth
                    Node From End</a>
                (19) - Gap technique â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/copy-list-with-random-pointer/">Copy List with
                    Random Pointer</a>
                (138) - Deep copy â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/add-two-numbers/">Add Two Numbers</a> (2) - Carry
                simulation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/linked-list-cycle-ii/">Linked List Cycle II</a>
                (142) - Find
                cycle start</li>
            <li><a target="_blank" href="https://leetcode.com/problems/rotate-list/">Rotate List</a> (61) - Circular
                technique</li>
            <li><a target="_blank" href="https://leetcode.com/problems/lru-cache/">LRU Cache</a> (146) - Doubly linked +
                hash â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-the-duplicate-number/">Find the Duplicate
            <li><a target="_blank" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove
            <li><a target="_blank" href="https://leetcode.com/problems/partition-list/">Partition List</a> (86)</li>
        </ol>
        <h4 id="hard_3">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Reverse Nodes in
                    k-Group</a> (25) -
                Advanced reversal â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-k-sorted-lists/">Merge k Sorted Lists</a>
                (23) - Divide
                &amp; conquer â­â­</li>
        </ol>
        <hr />
        <h1 id="phase-3-optimization-math">PHASE 3: SEARCHING & STACK ğŸ”</h1>
        <h2 id="7-greedy">7. GREEDY âš¡</h2>
        <p><strong>Difficulty:</strong> <span style="color: green">â˜…â˜†â˜†</span> | <strong>Optimization Pattern</strong>
        </p>
        <h3 id="core-concept_6">Core Concept</h3>
        <p>Make the locally optimal choice at each step with the hope of finding the global optimum. Unlike DP, you
            never look back or reconsider choices.</p>
        <h3 id="when-to-use_6">When to Use</h3>
        <ul>
            <li>âœ… <strong>Optimization problems</strong> (min/max)</li>
            <li>âœ… <strong>Activity selection/Interval scheduling</strong> (max events)</li>
            <li>âœ… <strong>Partitioning</strong> (labels, merge triplets)</li>
            <li>âœ… <strong>Huffman Coding</strong> or similar compression</li>
            <li><strong>Signal Words:</strong> "maximum number", "minimum cost", "best fit", "earliest ending"</li>
        </ul>
        <h3 id="sub-patterns_6">Sub-Patterns</h3>
        <h4 id="71-interval-scheduling-earliest-finish-time">7.1 Interval Scheduling (Earliest Finish Time)</h4>
        <p><strong>Use Case:</strong> Maximize number of non-overlapping intervals</p>
        <pre><code class="language-python">def max_non_overlapping(intervals):
            &quot;&quot;&quot;
            GREEDY STRATEGY:
            1. Sort by END time (finish earliest = leave room for more)
            2. Iterate and pick if start &gt;= last_end
            &quot;&quot;&quot;
            # Sort by end time
            intervals.sort(key=lambda x: x[1])

            count = 0
            last_end = float('-inf')

            for start, end in intervals:
                if start &gt;= last_end:
                    count += 1
                    last_end = end

            return count
        </code></pre>
        <p><strong>Time:</strong> O(N log N) for sort | <strong>Space:</strong> O(1)</p>
        <h4 id="72-jump-game-furthest-reach">7.2 Jump Game (Furthest Reach)</h4>
        <p><strong>Use Case:</strong> Can you reach the end? Minimum jumps?</p>
        <pre><code class="language-python">def can_jump(nums):
            &quot;&quot;&quot;
            Track the furthest index reachable from current position.
            If current index &gt; furthest reachable, we're stuck.
            &quot;&quot;&quot;
            furthest = 0
            for i, jump_len in enumerate(nums):
                if i &gt; furthest:
                    return False
                furthest = max(furthest, i + jump_len)

                if furthest &gt;= len(nums) - 1:
                    return True

            return True
</code></pre>
        <p><strong>Time:</strong> O(N) | <strong>Space:</strong> O(1)</p>
        <h4 id="73-kadanes-algorithm-max-subarray">7.3 Kadane's Algorithm (Max Subarray)</h4>
        <p><strong>Use Case:</strong> Maximum sum contiguous subarray</p>
        <pre><code class="language-python">def max_sub_array(nums):
            &quot;&quot;&quot;
            Key insight: If current subarray sum is negative,
            better to reset and start fresh from current element.
            &quot;&quot;&quot;
            current_sum = nums[0]
            max_sum = nums[0]

            for num in nums[1:]:
                # Choice: Continue current subarray OR start new
                current_sum = max(num, current_sum + num)
                max_sum = max(max_sum, current_sum)

            return max_sum
</code></pre>
        <h3 id="common-traps_6">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>False Greedy</strong>: Always prove greedy works (usually by induction). If picking 'largest
                now'
                limits future options in a bad way, use DP.</li>
            <li>âŒ <strong>Sorting Key</strong>: Sorting by start vs. end time changes everything.</li>
            <li>âŒ <strong>Local vs Global</strong>: Greedy fails for "Coin Change" with general coins (requires DP), but
                works
                for US coins.</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Optimization problem?
        â”œâ”€ Current choice affects future? â†’ No (Greedy Property)
        â”œâ”€ Intervals? â†’ Sort by end/start time
        â”‚ â”œâ”€ Overlap? â†’ Merge/Erase
        â”‚ â””â”€ Meeting Rooms? â†’ Min-Heap (end times)
        â”œâ”€ Partitioning labels? â†’ Last index map
        â””â”€ Huffman/Coding? â†’ Min-Heap
        </pre>
        <h3 id="must-know-problems_6">Must-Know Problems</h3>
        <h4 id="medium_5">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a> (53) -
                Kadane's â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/jump-game/">Jump Game</a> (55) - Reachability â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/jump-game-ii/">Jump Game II</a> (45) - Min jumps
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/gas-station/">Gas Station</a> (134) - Circular
                greedy</li>
            <li><a target="_blank" href="https://leetcode.com/problems/hand-of-straights/">Hand of Straights</a> (846) -
                Ordered map +
                greedy</li>
            <li><a target="_blank" href="https://leetcode.com/problems/partition-labels/">Partition Labels</a> (763) -
                Furthest reach
                variant â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-parenthesis-string/">Valid Parenthesis
                    String</a> (678) -
                Min/Max open tracking</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-triplets-to-target/">Merge Triplets to
                    Target</a>
                (1899)</li>
        </ol>
        <hr />
        <h2 id="8-intervals">8. INTERVALS ğŸ“Š</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Sorting &amp; Geometry</strong>
        </p>
        <h3 id="core-concept_7">Core Concept</h3>
        <p>Handling overlapping or merging time ranges. Almost always requires sorting by start time first to linearize
            the problem.</p>
        <h3 id="when-to-use_7">When to Use</h3>
        <ul>
            <li>âœ… <strong>Merging ranges</strong></li>
            <li>âœ… <strong>Inserting into sorted intervals</strong></li>
            <li>âœ… <strong>Meeting rooms / Resource allocation</strong></li>
            <li><strong>Signal Words:</strong> "start and end times", "overlapping", "merge", "schedule"</li>
        </ul>
        <h3 id="sub-patterns_7">Sub-Patterns</h3>
        <h4 id="81-merge-intervals-pattern">8.1 Merge Intervals Pattern</h4>
        <p><strong>Use Case:</strong> Combine overlapping ranges</p>
        <pre><code class="language-python">def merge_intervals(intervals):
            &quot;&quot;&quot;
            1. Sort by start time.
            2. Iterate: if overlap (current.start &lt;= last.end), merge.
               Else, append new interval.
            &quot;&quot;&quot;
            if not intervals: return []

            intervals.sort(key=lambda x: x[0])
            merged = [intervals[0]]

            for current in intervals[1:]:
                last = merged[-1]

                # Overlap case
                if current[0] &lt;= last[1]:
                    # Merge: extend last end to max of both
                    last[1] = max(last[1], current[1])
                else:
                    # No overlap
                    merged.append(current)

            return merged
</code></pre>
        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
        <h4 id="82-sweep-line-meeting-rooms-ii">8.2 Sweep Line (Meeting Rooms II)</h4>
        <p><strong>Use Case:</strong> Maximum concurrent intervals (Min rooms needed)</p>
        <pre><code class="language-python">def min_meeting_rooms(intervals):
            &quot;&quot;&quot;
            Separate starts and ends, sort both.
            Two pointer sweep.
            &quot;&quot;&quot;
            starts = sorted([i[0] for i in intervals])
            ends = sorted([i[1] for i in intervals])

            count = 0
            max_count = 0
            s, e = 0, 0

            while s &lt; len(intervals):
                if starts[s] &lt; ends[e]:
                    count += 1  # Meeting started
                    s += 1
                else:
                    count -= 1  # Meeting ended
                    e += 1
                max_count = max(max_count, count)

            return max_count
</code></pre>
        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
        <h3 id="common-traps_7">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Edge Cases</strong>: <code>[1,2]</code> and <code>[2,3]</code> - do they touch or overlap?
                (Usually
                touch = merge).</li>
            <li>âŒ <strong>Unsorted Input</strong>: Always sort first unless specified.</li>
            <li>âŒ <strong>Modifying list while iterating</strong>: Create a new <code>merged</code> list result.</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Input text...
        â”œâ”€ Intervals [start, end]? â†’ Sort first!
        â”œâ”€ Overlapping?
        â”‚ â”œâ”€ Merge? â†’ Sort by start, check end
        â”‚ â””â”€ Insert? â†’ Search position, merge
        â”œâ”€ Non-overlapping? â†’ Erase Interval (Greedy)
        â””â”€ Meeting Rooms? â†’ Chronological ordering (Two Arrays/Heap)
        </pre>
        <h3 id="must-know-problems_7">Must-Know Problems</h3>
        <h4 id="easy_intervals">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/meeting-rooms/">Meeting Rooms</a> (252)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/summary-ranges/">Summary Ranges</a> (228)</li>
        </ol>
        <h4 id="medium_6">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/insert-interval/">Insert Interval</a> (57) -
                Linear scan â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a> (56) -
                Sorting â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/non-overlapping-intervals/">Non-overlapping
                    Intervals</a> (435) -
                Greedy removal</li>
            <li><a target="_blank" href="https://leetcode.com/problems/meeting-rooms-ii/">Meeting Rooms II</a> (253) -
                Sweep line â­â­
            </li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">Minimum Number of
                    Arrows to Burst Balloons</a> (452) - Intersection</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-interval-to-include-each-query/">Minimum
                    Interval to Include Each Query</a> (1851)</li>
        </ol>
        <hr />
        <h2 id="9-bit-manipulation">9. BIT MANIPULATION ğŸ”¢</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Arithmetic Hacks</strong></p>
        <h3 id="core-concept_8">Core Concept</h3>
        <p>Manipulate integers at the binary level. XOR is the king of bit manipulation problems.</p>
        <h3 id="key-operators">Key Operators</h3>
        <ul>
            <li><code>&amp;</code> (AND): Both 1</li>
            <li><code>|</code> (OR): Either 1</li>
            <li><code>^</code> (XOR): Different bits (1 if different, 0 if same)</li>
            <li><code>~</code> (NOT): Invert</li>
            <li><code>&lt;&lt;</code>, <code>&gt;&gt;</code>: Shift</li>
        </ul>
        <h3 id="when-to-use_bits">When to Use</h3>
        <ul>
            <li>âœ… <strong>Find unique/missing element</strong> (XOR cancels duplicates)</li>
            <li>âœ… <strong>Count set bits</strong> (Brian Kernighan's algorithm)</li>
            <li>âœ… <strong>Power of 2 checks</strong> (n & (n-1) == 0)</li>
            <li>âœ… <strong>Subset representation</strong> (bitmask DP)</li>
            <li><strong>Signal Words:</strong> "single number", "power of two", "bit", "XOR"</li>
        </ul>
        <h3 id="sub-patterns_8">Sub-Patterns</h3>
        <h4 id="91-xor-property-a-a-0">9.1 XOR Property (a ^ a = 0)</h4>
        <p><strong>Use Case:</strong> Find unique number, missing number</p>
        <pre><code class="language-python">def single_number(nums):
            &quot;&quot;&quot;
            XOR all numbers. Duplicates cancel out (a ^ a = 0).
            Only the unique number remains.
            &quot;&quot;&quot;
            res = 0
            for n in nums:
                res ^= n
            return res
</code></pre>
        <h4 id="92-brian-kernighans-algorithm-count-set-bits">9.2 Brian Kernighan's Algorithm (Count Set Bits)</h4>
        <p><strong>Use Case:</strong> Count 1s (Hamming Weight)</p>
        <pre><code class="language-python">def count_set_bits(n):
            count = 0
            while n:
                n = n &amp; (n - 1)  # Clear the least significant bit set
                count += 1
            return count
</code></pre>
        <h4 id="93-bit-masking">9.3 Bit Masking</h4>
        <p><strong>Use Case:</strong> Track state using bits (e.g., subsets)</p>
        <pre><code class="language-python"># Check if ith bit is set
        is_set = (n &amp; (1 &lt;&lt; i)) != 0

        # Set ith bit
        n = n | (1 &lt;&lt; i)

        # Clear ith bit
        n = n &amp; ~(1 &lt;&lt; i)
        </code></pre>
        <h3 id="common-traps_8">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Operator Precedence</strong>: <code>a &amp; b == 0</code> evaluates as
                <code>a &amp; (b == 0)</code>.
                <strong>ALWAYS use parentheses</strong>: <code>(a &amp; b) == 0</code>.
            </li>
            <li>âŒ <strong>Negative Numbers</strong>: Python handles large integers and infinite leading 1s for
                negatives. Be
                careful using <code>~</code> or checks.</li>
            <li>âŒ <strong>Overflow</strong>: Python auto-promotes to long, but in Java/C++ checked for MAX_INT.</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Counting 1s? â†’ n & (n-1) (Brian Kernighan)
        â”œâ”€ XOR properties?
        â”‚ â”œâ”€ Single Number? â†’ x ^ x = 0
        â”‚ â””â”€ Missing Number? â†’ XOR all 1..n
        â”œâ”€ Power of 2? â†’ n & (n-1) == 0
        â””â”€ Reverse Bits? â†’ Mask and Shift
        </pre>
        <h3 id="must-know-problems_8">Must-Know Problems</h3>
        <h4 id="easy_5">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/single-number/">Single Number</a> (136) - XOR
                trick â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/number-of-1-bits/">Number of 1 Bits</a> (191) -
                Hamming weight
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/counting-bits/">Counting Bits</a> (338) - DP +
                Bits</li>
            <li><a target="_blank" href="https://leetcode.com/problems/missing-number/">Missing Number</a> (268) - Math
                or XOR</li>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-bits/">Reverse Bits</a> (190)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/add-binary/">Add Binary</a> (67)</li>
        </ol>
        <h4 id="medium_7">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/sum-of-two-integers/">Sum of Two Integers</a>
                (371) - Adder
                simulation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-integer/">Reverse Integer</a> (7) -
                Overflow check</li>
            <li><a target="_blank" href="https://leetcode.com/problems/single-number-ii/">Single Number II</a> (137)
            <li><a target="_blank" href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">Bitwise AND of
                    Numbers
                    Range</a> (201)</li>
        </ol>
        <hr />
        <h2 id="10-math-geometry">10. MATH &amp; GEOMETRY â—</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Logic &amp; Rules</strong></p>
        <h3 id="core-concept_9">Core Concept</h3>
        <p>Using mathematical properties (modulo, powers, GCD) or matrix coordinates to solve problems efficiently.</p>
        <h3 id="when-to-use_9">When to Use</h3>
        <ul>
            <li>âœ… <strong>Matrix manipulation</strong> (rotate, spiral traversal)</li>
            <li>âœ… <strong>Number theory</strong> (primes, GCD, modular arithmetic)</li>
            <li>âœ… <strong>Geometry</strong> (distance, area, line intersections)</li>
            <li>âœ… <strong>Probability/Random</strong> (weighted selection, reservoir sampling)</li>
            <li><strong>Signal Words:</strong> "matrix", "rotate", "power", "prime", "random"</li>
        </ul>
        <h3 id="sub-patterns_9">Sub-Patterns</h3>
        <h4 id="101-matrix-traversal">10.1 Matrix Traversal</h4>
        <p><strong>Use Case:</strong> Spiral matrix, Rotate image</p>
        <pre><code class="language-python">def rotate_image(matrix):
            &quot;&quot;&quot;
            Rotate 90 deg clockwise in-place.
            Strategy: Transpose (swap i,j) then Reverse rows.
            &quot;&quot;&quot;
            n = len(matrix)

            # 1. Transpose
            for i in range(n):
                for j in range(i, n):
                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

            # 2. Reverse rows
            for i in range(n):
                matrix[i].reverse()
</code></pre>
        <h4 id="102-fast-power-exponentiation">10.2 Fast Power (Exponentiation)</h4>
        <p><strong>Use Case:</strong> Calculate x^n in O(log n)</p>
        <pre><code class="language-python">def my_pow(x, n):
            def helper(x, n):
                if x == 0: return 0
                if n == 0: return 1

                res = helper(x, n // 2)
                res = res * res

                return x * res if n % 2 else res

            res = helper(x, abs(n))
            return res if n &gt;= 0 else 1 / res
</code></pre>
        <h3 id="common-traps-math">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Integer overflow</strong>: Use modulo for large results (10^9+7)</li>
            <li>âŒ <strong>Floating point precision</strong>: Use epsilon for comparisons</li>
            <li>âŒ <strong>Negative modulo</strong>: Python handles it, but (a % m + m) % m is safer</li>
            <li>âŒ <strong>Edge cases</strong>: n=0 for power, empty matrix, division by zero</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Geometric?
        â”‚ â”œâ”€ Rotation? â†’ Matrix Transpose + Reverse
        â”‚ â””â”€ Distance? â†’ Euclidean/Manhattan
        â”œâ”€ Number Theory?
        â”‚ â”œâ”€ Primes? â†’ Sieve of Eratosthenes
        â”‚ â””â”€ GCD/LCM? â†’ Euclidean Algorithm
        â””â”€ Pow(x, n)? â†’ Binary Exponentiation
        </pre>
        <h3 id="must-know-problems_9">Must-Know Problems</h3>
        <h4 id="easy_6">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/happy-number/">Happy Number</a> (202) - Cycle
                detection (Set/F-S)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/plus-one/">Plus One</a> (66)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindrome-number/">Palindrome Number</a> (9)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/factorial-trailing-zeroes/">Factorial Trailing
                    Zeroes</a>
                (172)</li>
        </ol>
        <h4 id="medium_8">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/rotate-image/">Rotate Image</a> (48) - Matrix
                manipulation â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/spiral-matrix/">Spiral Matrix</a> (54) -
                Simulation â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/set-matrix-zeroes/">Set Matrix Zeroes</a> (73) -
                Space
                optimization</li>
            <li><a target="_blank" href="https://leetcode.com/problems/powx-n/">Pow(x, n)</a> (50) - Recursive log n
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/multiply-strings/">Multiply Strings</a> (43)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/detect-squares/">Detect Squares</a> (2017)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/max-points-on-a-line/">Max Points on a Line</a>
                (149)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/game-of-life/">Game of Life</a> (289)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/random-pick-with-weight/">Random Pick with
                    Weight</a> (528) - Probability/Prefix Sum</li>
        </ol>
        <hr />
        <h2 id="11-heap-priority-queue">11. HEAP / PRIORITY QUEUE ğŸ†</h2>
        <p><span style="background: #7c3aed; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em;">ğŸ“Œ
                WEEK 4-6 (with Trees)</span> <strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> |
            <strong>Tree-Based Structure</strong>
        </p>
        <h3 id="core-concept_10">Core Concept</h3>
        <p>A tree-based structure that maintains the min (or max) element at the root. Insert/Delete in O(log N), Peek
            in O(1). Python's <code>heapq</code> is a Min-Heap by default.</p>
        <h3 id="when-to-use_8">When to Use</h3>
        <ul>
            <li>âœ… <strong>Find top K elements</strong> (largest/smallest/frequent)</li>
            <li>âœ… <strong>Merge K sorted structures</strong></li>
            <li>âœ… <strong>Median in data stream</strong></li>
            <li><strong>Signal Words:</strong> "kth largest", "top k", "median", "schedule tasks"</li>
        </ul>
        <h3 id="sub-patterns">Sub-Patterns</h3>
        <h4 id="11.1-top-k-elements">11.1 Top K Elements Pattern</h4>
        <pre><code class="language-python">import heapq

        def find_kth_largest(nums, k):
            &quot;&quot;&quot;
            Maintain a Min-Heap of size K.
            The root will be the Kth largest element seen so far.
            &quot;&quot;&quot;
            heap = []
            for num in nums:
                heapq.heappush(heap, num)
                if len(heap) &gt; k:
                    heapq.heappop(heap)

            return heap[0] # Kth largest
</code></pre>
        <h4 id="11.2-two-heaps">11.2 Two Heaps Pattern</h4>
        <p>Maintain two heaps:<br />
            1. <code>small</code>: Max-Heap (stores smaller half of numbers)<br />
            2. <code>large</code>: Min-Heap (stores larger half)</p>
        <p>Balance them so <code>len(small) == len(large)</code> or <code>len(small) == len(large) + 1</code>. Median is
            top of <code>small</code> (or avg of tops).</p>
        <h3 id="common-traps_9">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Max Heap in Python</strong>: Python only has Min Heap. For Max Heap, <strong>negate</strong>
                numbers
                when pushing, negate back when popping.</li>
            <li>âŒ <strong>Time Complexity</strong>: Heapify is O(N). Pushing N items is O(N log N).</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Top K elements?
        â”‚ â”œâ”€ Largest? â†’ Min-Heap (size k)
        â”‚ â””â”€ Smallest? â†’ Max-Heap (size k)
        â”œâ”€ Streaming data?
        â”‚ â””â”€ Median? â†’ Two Heaps (Min + Max)
        â”œâ”€ K-way merge? â†’ Min-Heap
        â””â”€ Task Scheduling? â†’ Max-Heap
        </pre>
        <h3 id="must-know-problems_10">Must-Know Problems</h3>
        <h4 id="easy_7">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/last-stone-weight/">Last Stone Weight</a> (1046)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">Kth Largest
                    Element in a Stream</a> (703)</li>
        </ol>
        <h4 id="medium_9">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Kth Largest
                    Element in an
                    Array</a> (215) - Selection/Heap â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/task-scheduler/">Task Scheduler</a> (621) -
                Greedy + Heap</li>
            <li><a target="_blank" href="https://leetcode.com/problems/design-twitter/">Design Twitter</a> (355) - Merge
                K sorted</li>
            <li><a target="_blank" href="https://leetcode.com/problems/k-closest-points-to-origin/">K Closest Points to
                    Origin</a> (973)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/">Find K Pairs
                    with Smallest Sums</a> (373)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/reorganize-string/">Reorganize String</a> (767) -
                Greedy Heap</li>
            <li><a target="_blank" href="https://leetcode.com/problems/top-k-frequent-words/">Top K Frequent Words</a>
                (692) - Trie + Heap</li>
            <li><a target="_blank" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">Kth
                    Smallest Element in a Sorted Matrix</a> (378) - Binary Search on Answer / Heap</li>
        </ol>
        <h4 id="hard_4">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/find-median-from-data-stream/">Find Median from
                    Data Stream</a>
                (295) - Two heaps â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/ipo/">IPO</a> (502)</li>
        </ol>
        <hr />
        <h1 id="phase-4-trees-recursion">PHASE 4: TREES &amp; RECURSION ğŸŒ³</h1>
        <h2 id="12-binary-trees">12. BINARY TREES ğŸŒ²</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">â˜…â˜…â˜†</span> | <strong>Foundation for Advanced
                Patterns</strong></p>
        <h3 id="core-concept_11">Core Concept</h3>
        <p>Hierarchical structure where each node has at most two children. Master DFS (pre/in/post order) and BFS
            (level order) traversals. Think recursively: "solve for children, combine for parent."</p>
        <h3 id="when-to-use_9">When to Use</h3>
        <ul>
            <li>âœ… Hierarchical data traversal</li>
            <li>âœ… Path problems (root to leaf)</li>
            <li>âœ… Level-based operations</li>
            <li>âœ… Tree validation/construction</li>
            <li>âœ… Subtree problems</li>
            <li><strong>Signal Words:</strong> "tree", "root", "ancestor", "depth", "level", "path"</li>
        </ul>
        <h3 id="sub-patterns_10">Sub-Patterns</h3>
        <h4 id="12.1-dfs-traversals">12.1 DFS Traversals (Recursive)</h4>
        <p><strong>Core Templates:</strong></p>
        <pre><code class="language-python">class TreeNode:
            def __init__(self, val=0, left=None, right=None):
                self.val = val
                self.left = left
                self.right = right

        # Preorder: Root â†’ Left â†’ Right (Top-down)
        def preorder(root):
            if not root:
                return []
            return [root.val] + preorder(root.left) + preorder(root.right)

        # Inorder: Left â†’ Root â†’ Right (BST gives sorted)
        def inorder(root):
            if not root:
                return []
            return inorder(root.left) + [root.val] + inorder(root.right)

        # Postorder: Left â†’ Right â†’ Root (Bottom-up)
        def postorder(root):
            if not root:
                return []
            return postorder(root.left) + postorder(root.right) + [root.val]
</code></pre>
        <p><strong>When to use each:</strong><br />
            - <strong>Preorder</strong>: Copy tree, serialize, prefix expression<br />
            - <strong>Inorder</strong>: BST operations (get sorted order)<br />
            - <strong>Postorder</strong>: Delete tree, calculate subtree properties, postfix expression</p>
        <h5 id="depthheight-calculations">Depth/Height Calculations</h5>
        <pre><code class="language-python">def max_depth(root):
            &quot;&quot;&quot;
            BOTTOM-UP (Postorder):
            - Get depth of children
            - Return 1 + max(left, right)
            &quot;&quot;&quot;
            if not root:
                return 0

            left_depth = max_depth(root.left)
            right_depth = max_depth(root.right)

            return 1 + max(left_depth, right_depth)

        def min_depth(root):
            &quot;&quot;&quot;
            Minimum depth to leaf (node with no children)
            CAREFUL: Don't count path to None child!
            &quot;&quot;&quot;
            if not root:
                return 0

            # If one child is None, ignore it
            if not root.left:
                return 1 + min_depth(root.right)
            if not root.right:
                return 1 + min_depth(root.left)

            # Both children exist
            return 1 + min(min_depth(root.left), min_depth(root.right))

        def is_balanced(root):
            &quot;&quot;&quot;
            Check if height-balanced (left and right depth differ by â‰¤ 1)
            &quot;&quot;&quot;
            def check(node):
                if not node:
                    return 0, True  # (height, is_balanced)

                left_h, left_bal = check(node.left)
                if not left_bal:
                    return 0, False

                right_h, right_bal = check(node.right)
                if not right_bal:
                    return 0, False

                balanced = abs(left_h - right_h) &lt;= 1
                height = 1 + max(left_h, right_h)

                return height, balanced

            return check(root)[1]
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h) for recursion stack, h = height</p>
        <h5 id="path-sum-problems">Path Sum Problems</h5>
        <pre><code class="language-python">def has_path_sum(root, target_sum):
            &quot;&quot;&quot;
            Check if root-to-leaf path sums to target
            TOP-DOWN: Pass remaining sum down
            &quot;&quot;&quot;
            if not root:
                return False

            # Leaf node
            if not root.left and not root.right:
                return root.val == target_sum

            remaining = target_sum - root.val
            return (has_path_sum(root.left, remaining) or
                    has_path_sum(root.right, remaining))

        def path_sum_all(root, target_sum):
            &quot;&quot;&quot;
            Find ALL root-to-leaf paths that sum to target
            &quot;&quot;&quot;
            def dfs(node, remaining, path, result):
                if not node:
                    return

                path.append(node.val)

                # Check if leaf and sum matches
                if not node.left and not node.right and remaining == node.val:
                    result.append(path[:])  # Copy path!

                # Recurse
                dfs(node.left, remaining - node.val, path, result)
                dfs(node.right, remaining - node.val, path, result)

                path.pop()  # Backtrack

            result = []
            dfs(root, target_sum, [], result)
            return result

        def max_path_sum(root):
            &quot;&quot;&quot;
            HARD: Maximum path sum (any node to any node)
            Can go through root or entirely in one subtree

            TECHNIQUE:
            - Each node decides: include me or not?
            - Track global maximum
            - Return: max single-path sum through this node
            &quot;&quot;&quot;
            max_sum = float('-inf')

            def max_gain(node):
                nonlocal max_sum

                if not node:
                    return 0

                # Max sum from left/right (ignore if negative)
                left_gain = max(max_gain(node.left), 0)
                right_gain = max(max_gain(node.right), 0)

                # Path through this node
                path_sum = node.val + left_gain + right_gain
                max_sum = max(max_sum, path_sum)

                # Return max single branch sum (for parent)
                return node.val + max(left_gain, right_gain)

            max_gain(root)
            return max_sum
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h)</p>
        <h4 id="12.2-bfs-level-order">12.2 BFS (Level Order Traversal)</h4>
        <pre><code class="language-python">from collections import deque

        def level_order(root):
            &quot;&quot;&quot;
            BFS TEMPLATE:
            1. Use queue (deque)
            2. Process level by level
            3. Add children of current level to queue
            &quot;&quot;&quot;
            if not root:
                return []

            result = []
            queue = deque([root])

            while queue:
                level = []
                level_size = len(queue)  # IMPORTANT: Fix size for this level

                for _ in range(level_size):
                    node = queue.popleft()
                    level.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)

                result.append(level)

            return result

        def zigzag_level_order(root):
            &quot;&quot;&quot;
            Alternate left-to-right and right-to-left
            &quot;&quot;&quot;
            if not root:
                return []

            result = []
            queue = deque([root])
            left_to_right = True

            while queue:
                level = []
                level_size = len(queue)

                for _ in range(level_size):
                    node = queue.popleft()
                    level.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)

                # Reverse if right-to-left
                if not left_to_right:
                    level.reverse()

                result.append(level)
                left_to_right = not left_to_right

            return result

        def right_side_view(root):
            &quot;&quot;&quot;
            View from right side = rightmost node at each level
            &quot;&quot;&quot;
            if not root:
                return []

            result = []
            queue = deque([root])

            while queue:
                level_size = len(queue)

                for i in range(level_size):
                    node = queue.popleft()

                    # Rightmost node of this level
                    if i == level_size - 1:
                        result.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)

            return result
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(w) where w = max width of tree</p>
        <h4 id="12.3-tree-construction">12.3 Tree Construction</h4>
        <pre><code class="language-python">def build_tree_pre_in(preorder, inorder):
            &quot;&quot;&quot;
            Construct tree from preorder and inorder

            KEY INSIGHTS:
            - Preorder[0] is root
            - Find root in inorder â†’ splits left/right subtrees
            - Recursively build left and right
            &quot;&quot;&quot;
            if not preorder or not inorder:
                return None

            root_val = preorder[0]
            root = TreeNode(root_val)

            # Find root position in inorder
            mid = inorder.index(root_val)

            # Build left and right subtrees
            root.left = build_tree_pre_in(
                preorder[1:mid+1],
                inorder[:mid]
            )
            root.right = build_tree_pre_in(
                preorder[mid+1:],
                inorder[mid+1:]
            )

            return root

        def build_tree_in_post(inorder, postorder):
            &quot;&quot;&quot;
            Construct from inorder and postorder
            Postorder: last element is root
            &quot;&quot;&quot;
            if not inorder or not postorder:
                return None

            root_val = postorder[-1]
            root = TreeNode(root_val)

            mid = inorder.index(root_val)

            root.left = build_tree_in_post(
                inorder[:mid],
                postorder[:mid]
            )
            root.right = build_tree_in_post(
                inorder[mid+1:],
                postorder[mid:-1]
            )

            return root
        </code></pre>
        <p><strong>Time:</strong> O(nÂ²) due to index search, O(n) with hash map | <strong>Space:</strong> O(n)</p>
        <p><strong>Optimization with Hash Map:</strong></p>
        <pre><code class="language-python">def build_tree_optimized(preorder, inorder):
            inorder_map = {val: i for i, val in enumerate(inorder)}

            def helper(pre_left, pre_right, in_left, in_right):
                if pre_left &gt; pre_right:
                    return None

                root_val = preorder[pre_left]
                root = TreeNode(root_val)

                in_root = inorder_map[root_val]
                left_size = in_root - in_left

                root.left = helper(
                    pre_left + 1,
                    pre_left + left_size,
                    in_left,
                    in_root - 1
                )
                root.right = helper(
                    pre_left + left_size + 1,
                    pre_right,
                    in_root + 1,
                    in_right
                )

                return root

            return helper(0, len(preorder) - 1, 0, len(inorder) - 1)
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="74-tree-comparison-validation">7.4 Tree Comparison &amp; Validation</h4>
        <pre><code class="language-python">def is_same_tree(p, q):
            &quot;&quot;&quot;
            Check if two trees are identical
            &quot;&quot;&quot;
            if not p and not q:
                return True
            if not p or not q:
                return False

            return (p.val == q.val and
                    is_same_tree(p.left, q.left) and
                    is_same_tree(p.right, q.right))

        def is_subtree(root, sub_root):
            &quot;&quot;&quot;
            Check if sub_root is subtree of root
            &quot;&quot;&quot;
            if not root:
                return False

            if is_same_tree(root, sub_root):
                return True

            return (is_subtree(root.left, sub_root) or
                    is_subtree(root.right, sub_root))

        def is_symmetric(root):
            &quot;&quot;&quot;
            Check if tree is mirror of itself
            &quot;&quot;&quot;
            def is_mirror(left, right):
                if not left and not right:
                    return True
                if not left or not right:
                    return False

                return (left.val == right.val and
                        is_mirror(left.left, right.right) and
                        is_mirror(left.right, right.left))

            return is_mirror(root, root)
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h)</p>
        <h4 id="75-lowest-common-ancestor-lca">7.5 Lowest Common Ancestor (LCA)</h4>
        <pre><code class="language-python">def lowest_common_ancestor(root, p, q):
            &quot;&quot;&quot;
            TECHNIQUE:
            - If root is p or q, return root
            - Check left and right subtrees
            - If both return non-null, root is LCA
            - Otherwise, return non-null side
            &quot;&quot;&quot;
            if not root or root == p or root == q:
                return root

            left = lowest_common_ancestor(root.left, p, q)
            right = lowest_common_ancestor(root.right, p, q)

            if left and right:
                return root  # Both sides found, root is LCA

            return left if left else right
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h)</p>
        <h3 id="common-traps_10">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Null Checks</strong>: Always check <code>if not root</code> first</li>
            <li>âŒ <strong>Leaf vs None</strong>: Leaf has no children, not root.val == None
                <pre><code class="language-python"># Leaf check
                                                if not node.left and not node.right:
                                                    # do something</code></pre>
            </li>
            <li>âŒ <strong>Recursion Stack</strong>: Deep trees (h &gt; 1000) may cause stack overflow</li>
            <li>âŒ <strong>Path Copy</strong>: When storing paths, always copy list
                <pre><code class="language-python">result.append(path[:])  # Not path!</code></pre>
            </li>
            <li>âŒ <strong>Level Order Size</strong>: Fix <code>level_size = len(queue)</code> before loop</li>
            <li>âŒ <strong>Min Depth</strong>: Don't count path to None child</li>
        </ul>
        <h3 id="traversal-selection-guide">Traversal Selection Guide</h3>
        <pre><code>What do you need?
        â”œâ”€ Process node before children?
        â”‚   â””â”€ Preorder (top-down)
        â”œâ”€ Process node between children? (BST sorted order?)
        â”‚   â””â”€ Inorder
        â”œâ”€ Process node after children? (bottom-up calculation?)
        â”‚   â””â”€ Postorder
        â””â”€ Process level by level?
            â””â”€ BFS (level order)
        </code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Structure?
        â”œâ”€ Traversals?
        â”‚ â”œâ”€ Level Order? â†’ BFS (Queue)
        â”‚ â””â”€ Depth First? â†’ DFS (Recursion/Stack)
        â”œâ”€ BST Properties?
        â”‚ â”œâ”€ In-order is sorted
        â”‚ â””â”€ Validate? â†’ Range (min, max)
        â”œâ”€ Construction?
        â”‚ â””â”€ From Pre/In-order? â†’ Root is first in Pre
        â””â”€ Serialization? â†’ Encode structure
        </pre>
        <h4 id="126-serialization-deserialization">12.6 Serialization/Deserialization</h4>
        <p><strong>Use Case:</strong> Convert tree to string and back (CRITICAL for Meta/Amazon)</p>
        <pre><code class="language-python">def serialize(root):
    """
    PREORDER with None markers
    Serialize: root -> left -> right with 'null' for None
    """
    if not root:
        return "null,"

    return str(root.val) + "," + serialize(root.left) + serialize(root.right)

def deserialize(data):
    """
    Rebuild tree from serialized string
    Use iterator to process values in order
    """
    def helper():
        val = next(vals)
        if val == "null":
            return None

        node = TreeNode(int(val))
        node.left = helper()
        node.right = helper()
        return node

    vals = iter(data.split(','))
    return helper()

# Level-order alternative (BFS approach)
from collections import deque

def serialize_bfs(root):
    if not root:
        return ""

    result = []
    queue = deque([root])

    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")

    return ",".join(result)
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="127-morris-traversal">12.7 Morris Traversal (O(1) Space)</h4>
        <p><strong>Use Case:</strong> Traverse without recursion or stack (ADVANCED - Google L5+)</p>
        <pre><code class="language-python">def morris_inorder(root):
    """
    MORRIS TRAVERSAL - O(1) space using threading

    KEY INSIGHT: Use right pointers of leaves to thread back
    1. If no left child, visit and go right
    2. If left child exists:
       - Find inorder predecessor
       - If predecessor's right is None, create thread
       - If predecessor's right points back, remove thread and visit
    """
    curr = root
    result = []

    while curr:
        if not curr.left:
            # No left subtree - visit and go right
            result.append(curr.val)
            curr = curr.right
        else:
            # Find inorder predecessor (rightmost in left subtree)
            pred = curr.left
            while pred.right and pred.right != curr:
                pred = pred.right

            if not pred.right:
                # Create thread: predecessor points to current
                pred.right = curr
                curr = curr.left
            else:
                # Thread exists: remove it, visit current, go right
                pred.right = None
                result.append(curr.val)
                curr = curr.right

    return result

def recover_bst(root):
    """
    RECOVER BST - Two nodes swapped, use Morris to find them
    Uses O(1) space with Morris traversal
    """
    first = second = prev = None
    curr = root

    while curr:
        if not curr.left:
            # Visit
            if prev and prev.val &gt; curr.val:
                if not first:
                    first = prev
                second = curr
            prev = curr
            curr = curr.right
        else:
            pred = curr.left
            while pred.right and pred.right != curr:
                pred = pred.right

            if not pred.right:
                pred.right = curr
                curr = curr.left
            else:
                pred.right = None
                if prev and prev.val &gt; curr.val:
                    if not first:
                        first = prev
                    second = curr
                prev = curr
                curr = curr.right

    # Swap values to fix BST
    first.val, second.val = second.val, first.val
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1) - no recursion stack!</p>
        <h3 id="must-know-problems_11">Must-Know Problems</h3>
        <h4 id="easy_8">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree</a> (226)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/same-tree/">Same Tree</a> (100) - Comparison</li>
            <li><a target="_blank" href="https://leetcode.com/problems/symmetric-tree/">Symmetric Tree</a> (101) -
                Mirror check</li>
            <li><a target="_blank" href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree</a>
                (110) - Height
                check</li>
            <li><a target="_blank" href="https://leetcode.com/problems/path-sum/">Path Sum</a> (112) - DFS path</li>
            <li><a target="_blank" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">Average of
                    Levels in Binary Tree</a> (637)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">Minimum
                    Absolute Difference in BST</a> (530)</li>
        </ol>
        <h4 id="medium_10">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/diameter-of-binary-tree/">Diameter of Binary
                    Tree</a> (543) -
                Bottom-up â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">Lowest
                    Common
                    Ancestor</a> (236) - LCA template â­â­</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Lowest Common
                    Ancestor of a Binary Search Tree</a> (235)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree
                    Level Order
                    Traversal</a> (102) - BFS template â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-right-side-view/">Binary Tree Right
                    Side View</a>
                (199) - BFS variant</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct
                    Binary Tree from Preorder and Inorder</a> (105) - Construction â­â­</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">Construct
                    Binary Tree from Inorder and Postorder Traversal</a> (106)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary
                    Search Tree</a>
                (98) - Range validation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Kth Smallest in
                    BST</a> (230) -
                Inorder</li>
            <li><a target="_blank" href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/">Count Good
                    Nodes</a> (1448) -
                Path max</li>
            <li><a target="_blank" href="https://leetcode.com/problems/subtree-of-another-tree/">Subtree of Another
                    Tree</a> (572)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">Sum Root to Leaf
                    Numbers</a> (129)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/count-complete-tree-nodes/">Count Complete Tree
                    Nodes</a> (222)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">Binary
                    Tree Zigzag Level Order Traversal</a> (103)</li>
        </ol>
        <h4 id="hard_5">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">Binary Tree
                    Maximum Path Sum</a>
                (124) - Global max â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">Serialize
                    and Deserialize
                    Binary Tree</a> (297) - Encoding â­â­</li>
        </ol>
        <hr />

        <hr />
        <h2 id="13-tries-">13. TRIES ğŸ“ </h2>
        <h3 id="when-to-use-12">When to Use </h3>
        <ul>
            <li>Prefix-based searches/inserts</li>
            <li>Word suggestions/autocomplete</li>
            <li>Validate words in dict</li>
            <li>Longest prefix</li>
            <li>Signal: "prefix" or "trie/dictionary"</li>
        </ul>
        <h3 id="core-concept-12">Core Concept </h3>
        <p>Tree of characters for shared prefixes, enabling O(L) inserts/searches where L is word length, vs O(nL) for
            sets.</p>
        <h3 id="sub-patterns-6">Sub-Patterns </h3>
        <h4 id="13.1-trie-implementation">13.1 Trie Implementation</h4>
        <pre><code class="language-python"><span class="token keyword keyword-class">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>is_end <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>root <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword keyword-for">for</span> char <span class="token keyword keyword-in">in</span> word<span class="token punctuation">:</span>
            <span class="token keyword keyword-if">if</span> char <span class="token keyword keyword-not">not</span> <span class="token keyword keyword-in">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span> <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
        node<span class="token punctuation">.</span>is_end <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword keyword-for">for</span> char <span class="token keyword keyword-in">in</span> word<span class="token punctuation">:</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">.</span>get<span class="token punctuation">(</span>char<span class="token punctuation">)</span>
            <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-not">not</span> node<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">False</span>
        <span class="token keyword keyword-return">return</span> node<span class="token punctuation">.</span>is_end
</code></pre>
        <p><strong>Prefix Search</strong></p>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">starts_with</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
    node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
    <span class="token keyword keyword-for">for</span> char <span class="token keyword keyword-in">in</span> prefix<span class="token punctuation">:</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">.</span>get<span class="token punctuation">(</span>char<span class="token punctuation">)</span>
        <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-not">not</span> node<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">False</span>
    <span class="token keyword keyword-return">return</span> <span class="token boolean">True</span>
</code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Input...
        â”œâ”€ String prefix queries? â†’ Trie
        â”œâ”€ Autocomplete? â†’ Trie with frequency/end marks
        â”œâ”€ Word Search II (Grid)? â†’ Trie + DFS
        â””â”€ Max XOR pair? â†’ Bitwise Trie
        </pre>
        <h3 id="common-traps-tries">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Case sensitivity</strong>: Decide lowercase vs mixed case upfront</li>
            <li>âŒ <strong>Empty string</strong>: Handle empty word insertion/search separately</li>
            <li>âŒ <strong>Memory usage</strong>: Each node has 26+ children pointers (use HashMap for sparse)</li>
            <li>âŒ <strong>Deletion complexity</strong>: Need to clean up empty branches after delete</li>
        </ul>
        <h3 id="must-know-problems_13">Must-Know Problems</h3>
        <h4 id="medium_13">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie
                    (Prefix Tree)</a>
                (208)</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">Design Add and
                    Search Words Data Structure</a> (211)</li>
        </ol>
        <h4 id="hard_11">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/word-search-ii/">Word Search II</a> (212)</li>
        </ol>

        <hr />
        <h2 id="14-backtracking-">14. BACKTRACKING ğŸ”„ </h2>
        <p><span style="background: #dc2626; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em;">ğŸ“Œ
                WEEK 6-8 (after Graphs - uses DFS)</span> <strong>Difficulty:</strong> <span
                style="color: red">â˜…â˜…â˜…</span></p>
        <h3 id="when-to-use-13">When to Use </h3>
        <ul>
            <li>Generate combinations/permutations</li>
            <li>Subsets/solutions with choices</li>
            <li>Puzzles (N-Queens, Sudoku)</li>
            <li>Path finding with branches</li>
            <li>Signal: "all possible" or "combinations"</li>
        </ul>
        <h3 id="core-concept-13">Core Concept </h3>
        <p>Systematically explore branches with pruning/undoing choices, bounding exponential space by early
            termination.</p>
        <h3 id="sub-patterns-7">Sub-Patterns </h3>
        <h4 id="14.1-subsets-pattern">14.1 Subsets Pattern</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">subsets</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># Copy!</span>
        <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            backtrack<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span> <span class="token comment"># No reuse</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># Backtrack</span>
    backtrack<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> res
</code></pre>
        <h4 id="14.2-permutations-pattern">14.2 Permutations Pattern</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    used <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-if">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-return">return</span>
        <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword keyword-if">if</span> used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword keyword-continue">continue</span>
            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            backtrack<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>
    backtrack<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> res
</code></pre>
        <h3 id="traps-12">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ Reference copy: <code>path[:]</code> not <code>path</code></li>
            <li>âŒ Duplicates: Sort + <code>if i &gt; start and nums[i] == nums[i-1]: continue</code></li>
            <li>âŒ Undo state: Always pop/False after recurse</li>
            <li>âŒ Prune early: If partial invalid, return</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Combinatorial Search?
        â”‚ â”œâ”€ Permutations? â†’ Order matters
        â”‚ â”œâ”€ Combinations? â†’ Order doesn't matter
        â”‚ â””â”€ Subsets? â†’ Include/Exclude
        â”œâ”€ Constraints/Games?
        â”‚ â”œâ”€ N-Queens? â†’ Row/Col/Diag checks
        â”‚ â””â”€ Sudoku? â†’ Grid/Row/Col checks
        â””â”€ String Partition? â†’ Palindrome Partitioning
        </pre>
        <h3 id="must-know-problems_12">Must-Know Problems</h3>
        <h4 id="medium_12">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/subsets/">Subsets</a> (78)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/combination-sum/">Combination Sum</a> (39)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/permutations/">Permutations</a> (46)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/subsets-ii/">Subsets II</a> (90)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/combination-sum-ii/">Combination Sum II</a> (40)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/word-search/">Word Search</a> (79)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindrome-partitioning/">Palindrome
                    Partitioning</a> (131)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">Letter
                    Combinations of a
                    Phone Number</a> (17)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/combinations/">Combinations</a> (77)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/restore-ip-addresses/">Restore IP Addresses</a>
                (93) - Partitioning String</li>
        </ol>
        <h4 id="hard_10">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/n-queens/">N-Queens</a> (51)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/n-queens-ii/">N-Queens II</a> (52)</li>
        </ol>

        <hr />
        <h1 id="phase-5-graph-mastery">PHASE 5: GRAPH MASTERY ğŸŒ</h1>
        <h2 id="15-graphs-ğŸŒ">15. GRAPHS ğŸŒ</h2>
        <p>**Difficulty:** <span style="color: red">â˜…â˜…â˜…</span> | **Builds on:** Trees, BFS, DFS, Backtracking</p>
        <h3 id="core-concept">Core Concept</h3>
        <p>Model relationships as nodes (vertices) and edges. Use BFS for shortest paths in unweighted graphs, DFS for
            connectivity/cycles. Master both adjacency list representation and traversal patterns.</p>
        <h3 id="when-to-use">When to Use</h3>
        <ul>
            <li>âœ… Connectivity problems (islands, components)</li>
        </ul>
        <ul>
            <li>âœ… Shortest path (unweighted: BFS, weighted: Dijkstra)</li>
        </ul>
        <ul>
            <li>âœ… Cycle detection, topological sort</li>
        </ul>
        <ul>
            <li>âœ… Network flow, dependency resolution</li>
        </ul>
        <ul>
            <li>âœ… Matrix traversal (grid graphs)</li>
        </ul>
        <p>- **Signal Words:** "connected", "path", "network", "dependencies", "prerequisites", "islands"</p>
        <h3 id="graph-representations">Graph Representations</h3>
        <pre><code class="language-python">
        # Adjacency List (Most Common)
        graph = {
            'A': ['B', 'C'],
            'B': ['A', 'D'],
            'C': ['A', 'D'],
            'D': ['B', 'C']
        }

        # Or using defaultdict
        from collections import defaultdict
        graph = defaultdict(list)
        graph['A'].append('B')

        # Edge List (for algorithms like Union-Find)
        edges = [('A', 'B'), ('B', 'C'), ('C', 'D')]

        # Adjacency Matrix (for dense graphs)
        matrix = [
            [0, 1, 1, 0],
            [1, 0, 0, 1],
            [1, 0, 0, 1],
            [0, 1, 1, 0]
        ]
        </code></pre>
        <h3 id="sub-patterns">Sub-Patterns</h3>
        <h4 id="151-bfs---shortest-path-&-level-traversal">15.1 BFS - Shortest Path & Level Traversal</h4>
        <pre><code class="language-python">
        from collections import deque

        def bfs_shortest_path(graph, start, end):
            """
            BFS TEMPLATE for shortest path in unweighted graph

            KEY POINTS:
            - Queue for FIFO processing
            - Visited set to avoid cycles
            - Track parent/distance for path reconstruction
            """
            if start == end:
                return 0

            queue = deque([(start, 0)])  # (node, distance)
            visited = {start}

            while queue:
                node, dist = queue.popleft()

                for neighbor in graph[node]:
                    if neighbor in visited:
                        continue

                    if neighbor == end:
                        return dist + 1

                    visited.add(neighbor)
                    queue.append((neighbor, dist + 1))

            return -1  # No path

        def bfs_with_path(graph, start, end):
            """
            Return actual path, not just distance
            Track parent pointers
            """
            if start == end:
                return [start]

            queue = deque([start])
            visited = {start}
            parent = {start: None}

            while queue:
                node = queue.popleft()

                for neighbor in graph[node]:
                    if neighbor in visited:
                        continue

                    visited.add(neighbor)
                    parent[neighbor] = node
                    queue.append(neighbor)

                    if neighbor == end:
                        # Reconstruct path
                        path = []
                        current = end
                        while current is not None:
                            path.append(current)
                            current = parent[current]
                        return path[::-1]

            return []

        def bfs_multi_source(grid):
            """
            Multi-source BFS: Start from multiple sources simultaneously
            Example: Rotting oranges, walls and gates

            TECHNIQUE: Add all sources to queue initially
            """
            rows, cols = len(grid), len(grid[0])
            queue = deque()

            # Add all sources
            for r in range(rows):
                for c in range(cols):
                    if grid[r][c] == 2:  # Source (e.g., rotten orange)
                        queue.append((r, c, 0))  # (row, col, time)

            max_time = 0

            while queue:
                r, c, time = queue.popleft()
                max_time = max(max_time, time)

                for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                    nr, nc = r + dr, c + dc

                    if (0 <= nr < rows and 0 <= nc < cols and
                        grid[nr][nc] == 1):  # Fresh orange
                        grid[nr][nc] = 2  # Make rotten
                        queue.append((nr, nc, time + 1))

            return max_time
        </code></pre>
        <p>**Time:** O(V + E) | **Space:** O(V)</p>
        <h4 id="152-dfs---connectivity-&-cycles">15.2 DFS - Connectivity & Cycles</h4>
        <pre><code class="language-python">
        def dfs_recursive(graph, node, visited):
            """
            BASIC DFS TEMPLATE (Recursive)

            Use for:
            - Finding connected components
            - Detecting cycles
            - Topological sort (with modifications)
            """
            visited.add(node)

            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs_recursive(graph, neighbor, visited)

        def dfs_iterative(graph, start):
            """
            DFS with explicit stack (iterative)
            Useful when recursion depth is concern
            """
            visited = set()
            stack = [start]

            while stack:
                node = stack.pop()

                if node in visited:
                    continue

                visited.add(node)

                # Process node
                print(node)

                # Add neighbors (reverse for same order as recursive)
                for neighbor in reversed(graph[node]):
                    if neighbor not in visited:
                        stack.append(neighbor)

            return visited

        def count_connected_components(n, edges):
            """
            Count number of connected components

            TECHNIQUE: DFS from each unvisited node
            """
            graph = defaultdict(list)
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)

            visited = set()
            count = 0

            def dfs(node):
                visited.add(node)
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        dfs(neighbor)

            for node in range(n):
                if node not in visited:
                    dfs(node)
                    count += 1

            return count

        def has_cycle_undirected(graph, n):
            """
            Detect cycle in undirected graph

            KEY: Track parent to avoid false positive
            Edge back to parent is not a cycle
            """
            visited = set()

            def dfs(node, parent):
                visited.add(node)

                for neighbor in graph[node]:
                    if neighbor not in visited:
                        if dfs(neighbor, node):
                            return True
                    elif neighbor != parent:
                        return True  # Back edge (not to parent) = cycle

                return False

            for node in range(n):
                if node not in visited:
                    if dfs(node, -1):
                        return True

            return False

        def has_cycle_directed(graph, n):
            """
            Detect cycle in directed graph

            KEY: Track recursion stack, not just visited
            Three states: unvisited (0), visiting (1), visited (2)
            """
            state = [0] * n  # 0: unvisited, 1: visiting, 2: visited

            def dfs(node):
                if state[node] == 1:  # In recursion stack
                    return True
                if state[node] == 2:  # Already processed
                    return False

                state[node] = 1  # Mark as visiting

                for neighbor in graph[node]:
                    if dfs(neighbor):
                        return True

                state[node] = 2  # Mark as visited
                return False

            for node in range(n):
                if state[node] == 0:
                    if dfs(node):
                        return True

            return False
        </code></pre>
        <p>**Time:** O(V + E) | **Space:** O(V)</p>
        <h4 id="153-topological-sort">15.3 Topological Sort</h4>
        <pre><code class="language-python">
        def topological_sort_dfs(graph, n):
            """
            APPROACH 1: DFS with postorder

            TECHNIQUE:
            - DFS from each node
            - Add to result AFTER processing all neighbors
            - Reverse result for topological order

            Used for: Course schedule, build order
            """
            visited = set()
            result = []

            def dfs(node):
                visited.add(node)

                for neighbor in graph.get(node, []):
                    if neighbor not in visited:
                        dfs(neighbor)

                result.append(node)  # Add after all descendants

            for node in range(n):
                if node not in visited:
                    dfs(node)

            return result[::-1]  # Reverse for topological order

        def topological_sort_kahn(graph, n):
            """
            APPROACH 2: Kahn's Algorithm (BFS)

            TECHNIQUE:
            - Calculate in-degrees
            - Start with nodes having in-degree 0
            - Remove edges, add new 0-degree nodes

            ADVANTAGE: Detects cycles (if not all nodes processed)
            """
            in_degree = [0] * n

            # Calculate in-degrees
            for node in graph:
                for neighbor in graph[node]:
                    in_degree[neighbor] += 1

            # Queue with 0 in-degree nodes
            queue = deque([i for i in range(n) if in_degree[i] == 0])
            result = []

            while queue:
                node = queue.popleft()
                result.append(node)

                # Remove edges
                for neighbor in graph.get(node, []):
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)

            # Cycle detection
            if len(result) != n:
                return []  # Has cycle

            return result

        def course_schedule(num_courses, prerequisites):
            """
            Can finish all courses given prerequisites?

            This is cycle detection in directed graph
            """
            graph = defaultdict(list)
            for course, prereq in prerequisites:
                graph[prereq].append(course)

            topo_order = topological_sort_kahn(graph, num_courses)
            return len(topo_order) == num_courses

        def course_schedule_ii(num_courses, prerequisites):
            """
            Return order to take all courses

            This is topological sort
            """
            graph = defaultdict(list)
            for course, prereq in prerequisites:
                graph[prereq].append(course)

            return topological_sort_kahn(graph, num_courses)
        </code></pre>
        <p>**Time:** O(V + E) | **Space:** O(V)</p>
        <h4 id="154-union-find-(disjoint-set)">15.4 Union-Find (Disjoint Set)</h4>
        <pre><code class="language-python">
        class UnionFind:
            """
            UNION-FIND / DISJOINT SET

            Operations:
            - Find: O(Î±(n)) â‰ˆ O(1) with path compression
            - Union: O(Î±(n)) â‰ˆ O(1) with union by rank

            Use for:
            - Dynamic connectivity
            - Cycle detection in undirected graphs
            - Kruskal's MST
            - Number of islands II (dynamic)
            """

            def __init__(self, n):
                self.parent = list(range(n))
                self.rank = [0] * n
                self.components = n

            def find(self, x):
                """
                Find root with PATH COMPRESSION
                Makes tree flatter for faster future operations
                """
                if self.parent[x] != x:
                    self.parent[x] = self.find(self.parent[x])  # Compression
                return self.parent[x]

            def union(self, x, y):
                """
                Union by RANK
                Attach smaller tree under larger tree
                """
                root_x = self.find(x)
                root_y = self.find(y)

                if root_x == root_y:
                    return False  # Already connected

                # Union by rank
                if self.rank[root_x] < self.rank[root_y]:
                    self.parent[root_x] = root_y
                elif self.rank[root_x] > self.rank[root_y]:
                    self.parent[root_y] = root_x
                else:
                    self.parent[root_y] = root_x
                    self.rank[root_x] += 1

                self.components -= 1
                return True

            def connected(self, x, y):
                """Check if x and y are in same component"""
                return self.find(x) == self.find(y)

            def get_components(self):
                """Get number of connected components"""
                return self.components

        def redundant_connection(edges):
            """
            Find edge that creates cycle

            TECHNIQUE: Add edges one by one
            If connecting already-connected nodes, that's the cycle edge
            """
            n = len(edges)
            uf = UnionFind(n + 1)

            for u, v in edges:
                if not uf.union(u, v):
                    return [u, v]  # Creates cycle

            return []

        def number_of_provinces(is_connected):
            """
            Count number of connected components
            Using Union-Find
            """
            n = len(is_connected)
            uf = UnionFind(n)

            for i in range(n):
                for j in range(i + 1, n):
                    if is_connected[i][j]:
                        uf.union(i, j)

            return uf.get_components()
</code></pre>
        <p>**Time:** O(Î±(n)) per operation | **Space:** O(n)</p>
        <h4 id="155-dijkstra's-algorithm-(weighted-shortest-path)">15.5 Dijkstra's Algorithm (Weighted Shortest Path)
        </h4>
        <pre><code class="language-python">
        import heapq

        def dijkstra(graph, start, n):
            """
            DIJKSTRA'S ALGORITHM
            Shortest path in weighted graph with NON-NEGATIVE weights

            TECHNIQUE:
            - Min-heap with (distance, node)
            - Always process closest unvisited node
            - Relax edges (update distances)

            Time: O((V + E) log V) with heap
            """
            dist = [float('inf')] * n
            dist[start] = 0

            heap = [(0, start)]  # (distance, node)
            visited = set()

            while heap:
                d, node = heapq.heappop(heap)

                if node in visited:
                    continue

                visited.add(node)

                # Relax edges
                for neighbor, weight in graph[node]:
                    new_dist = d + weight

                    if new_dist < dist[neighbor]:
                        dist[neighbor] = new_dist
                        heapq.heappush(heap, (new_dist, neighbor))

            return dist

        def network_delay_time(times, n, k):
            """
            Minimum time for signal to reach all nodes

            This is Dijkstra from source k
            Answer = max distance (or -1 if unreachable)
            """
            graph = defaultdict(list)
            for u, v, w in times:
                graph[u].append((v, w))

            dist = dijkstra(graph, k, n + 1)

            max_dist = max(dist[1:])  # Skip index 0
            return max_dist if max_dist != float('inf') else -1

        def cheapest_flights_k_stops(n, flights, src, dst, k):
            """
            Shortest path with at most k stops

            MODIFIED DIJKSTRA:
            - Track (cost, node, stops)
            - Stop if stops > k
            """
            graph = defaultdict(list)
            for u, v, price in flights:
                graph[u].append((v, price))

            heap = [(0, src, 0)]  # (cost, node, stops)
            visited = {}  # (node, stops) -> min_cost

            while heap:
                cost, node, stops = heapq.heappop(heap)

                if node == dst:
                    return cost

                if stops > k:
                    continue

                # Avoid revisiting with more stops and higher cost
                if (node, stops) in visited and visited[(node, stops)] <= cost:
                    continue
                visited[(node, stops)] = cost

                for neighbor, price in graph[node]:
                    heapq.heappush(heap, (cost + price, neighbor, stops + 1))

            return -1
</code></pre>
        <p>**Time:** O((V + E) log V) | **Space:** O(V)</p>
        <h4 id="156-bellman-ford">15.6 Bellman-Ford Algorithm (Negative Weights)</h4>
        <p><strong>Use Case:</strong> Shortest path with negative weights, detect negative cycles</p>
        <pre><code class="language-python">def bellman_ford(graph, n, src):
    """
    BELLMAN-FORD ALGORITHM
    When Dijkstra fails: handles NEGATIVE edge weights

    KEY INSIGHT:
    - Relax all edges n-1 times
    - If any edge can still be relaxed, negative cycle exists

    Time: O(V * E) - slower than Dijkstra but handles negatives
    """
    dist = [float('inf')] * n
    dist[src] = 0

    # Relax all edges n-1 times
    for _ in range(n - 1):
        for u in range(n):
            for v, weight in graph[u]:
                if dist[u] != float('inf') and dist[u] + weight &lt; dist[v]:
                    dist[v] = dist[u] + weight

    # Check for negative cycle
    for u in range(n):
        for v, weight in graph[u]:
            if dist[u] != float('inf') and dist[u] + weight &lt; dist[v]:
                return None  # Negative cycle detected!

    return dist

def cheapest_flights_bellman(n, flights, src, dst, k):
    """
    Cheapest Flights Within K Stops (787)
    Modified Bellman-Ford: limit iterations to k+1
    """
    dist = [float('inf')] * n
    dist[src] = 0

    # Only k+1 relaxations (k stops = k+1 edges)
    for _ in range(k + 1):
        temp = dist[:]  # Use previous iteration's values
        for u, v, price in flights:
            if dist[u] != float('inf'):
                temp[v] = min(temp[v], dist[u] + price)
        dist = temp

    return dist[dst] if dist[dst] != float('inf') else -1
</code></pre>
        <p><strong>Time:</strong> O(V Ã— E) | <strong>Space:</strong> O(V)</p>
        <h4 id="157-tarjans-algorithm">15.7 Tarjan's Algorithm (Strongly Connected Components)</h4>
        <p><strong>Use Case:</strong> Find SCCs, articulation points, bridges (ADVANCED - Google L5+)</p>
        <pre><code class="language-python">def critical_connections(n, connections):
    """
    Critical Connections in a Network (1192) - BRIDGES
    Find all edges whose removal disconnects the graph

    TARJAN'S KEY CONCEPTS:
    - disc[]: Discovery time of each node
    - low[]: Lowest discovery time reachable
    - Bridge condition: low[v] &gt; disc[u] (can't reach back)
    """
    graph = defaultdict(list)
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)

    disc = [-1] * n
    low = [0] * n
    bridges = []
    time = [0]  # Mutable for nested function

    def dfs(u, parent):
        disc[u] = low[u] = time[0]
        time[0] += 1

        for v in graph[u]:
            if v == parent:
                continue

            if disc[v] == -1:  # Not visited
                dfs(v, u)
                low[u] = min(low[u], low[v])

                # Bridge condition: v can't reach back to u or earlier
                if low[v] &gt; disc[u]:
                    bridges.append([u, v])
            else:
                # Back edge: update low-link
                low[u] = min(low[u], disc[v])

    for i in range(n):
        if disc[i] == -1:
            dfs(i, -1)

    return bridges

def find_articulation_points(n, edges):
    """
    Find vertices whose removal disconnects graph
    Similar to bridges but check: low[v] &gt;= disc[u]
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    disc = [-1] * n
    low = [0] * n
    parent = [-1] * n
    ap = set()
    time = [0]

    def dfs(u):
        children = 0
        disc[u] = low[u] = time[0]
        time[0] += 1

        for v in graph[u]:
            if disc[v] == -1:
                children += 1
                parent[v] = u
                dfs(v)
                low[u] = min(low[u], low[v])

                # Articulation point conditions
                if parent[u] == -1 and children &gt; 1:
                    ap.add(u)  # Root with 2+ children
                if parent[u] != -1 and low[v] &gt;= disc[u]:
                    ap.add(u)  # Non-root: child can't reach up
            elif v != parent[u]:
                low[u] = min(low[u], disc[v])

    for i in range(n):
        if disc[i] == -1:
            dfs(i)

    return list(ap)
</code></pre>
        <p><strong>Time:</strong> O(V + E) | <strong>Space:</strong> O(V)</p>
        <h4 id="158-matrix/grid-as-graph">15.8 Matrix/Grid as Graph</h4>
        <pre><code class="language-python">
        def num_islands(grid):
            """
            COUNT ISLANDS (DFS approach)

            TECHNIQUE:
            - DFS from each unvisited land cell
            - Mark visited cells
            - Each DFS call is one island
            """
            if not grid:
                return 0

            rows, cols = len(grid), len(grid[0])
            count = 0

            def dfs(r, c):
                # Bounds check
                if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':
                    return

                grid[r][c] = '0'  # Mark visited

                # Explore 4 directions
                dfs(r + 1, c)
                dfs(r - 1, c)
                dfs(r, c + 1)
                dfs(r, c - 1)

            for r in range(rows):
                for c in range(cols):
                    if grid[r][c] == '1':
                        dfs(r, c)
                        count += 1

            return count

        def max_area_island(grid):
            """
            Find largest island area
            Track size during DFS
            """
            if not grid:
                return 0

            rows, cols = len(grid), len(grid[0])
            max_area = 0

            def dfs(r, c):
                if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != 1:
                    return 0

                grid[r][c] = 0  # Mark visited

                area = 1
                area += dfs(r + 1, c)
                area += dfs(r - 1, c)
                area += dfs(r, c + 1)
                area += dfs(r, c - 1)

                return area

            for r in range(rows):
                for c in range(cols):
                    if grid[r][c] == 1:
                        max_area = max(max_area, dfs(r, c))

            return max_area

        def surrounded_regions(board):
            """
            Capture surrounded regions

            KEY INSIGHT: Regions connected to border can't be captured

            TECHNIQUE:
            1. DFS from border 'O's, mark as safe
            2. Flip remaining 'O's to 'X' (captured)
            3. Restore safe 'O's
            """
            if not board:
                return

            rows, cols = len(board), len(board[0])

            def dfs(r, c):
                if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'O':
                    return

                board[r][c] = 'S'  # Mark as safe

                dfs(r + 1, c)
                dfs(r - 1, c)
                dfs(r, c + 1)
                dfs(r, c - 1)

            # Mark border-connected 'O's as safe
            for r in range(rows):
                dfs(r, 0)
                dfs(r, cols - 1)

            for c in range(cols):
                dfs(0, c)
                dfs(rows - 1, c)

            # Capture surrounded regions
            for r in range(rows):
                for c in range(cols):
                    if board[r][c] == 'O':
                        board[r][c] = 'X'  # Captured
                    elif board[r][c] == 'S':
                        board[r][c] = 'O'  # Restore safe

        def pacific_atlantic_water_flow(heights):
            """
            Find cells where water can flow to both oceans

            REVERSE THINKING:
            - Start from ocean, flow uphill (reverse direction)
            - Find cells reachable from both oceans
            """
            if not heights:
                return []

            rows, cols = len(heights), len(heights[0])
            pacific = set()
            atlantic = set()

            def dfs(r, c, visited):
                visited.add((r, c))

                for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                    nr, nc = r + dr, c + dc

                    if (0 <= nr < rows and 0 <= nc < cols and
                        (nr, nc) not in visited and
                        heights[nr][nc] >= heights[r][c]):  # Can flow uphill
                        dfs(nr, nc, visited)

            # DFS from Pacific (top and left borders)
            for r in range(rows):
                dfs(r, 0, pacific)
            for c in range(cols):
                dfs(0, c, pacific)

            # DFS from Atlantic (bottom and right borders)
            for r in range(rows):
                dfs(r, cols - 1, atlantic)
            for c in range(cols):
                dfs(rows - 1, c, atlantic)

            # Intersection
            return list(pacific & atlantic)
</code></pre>
        <p>**Time:** O(rows * cols) | **Space:** O(rows * cols)</p>
        <h3 id="common-traps-ğŸš¨">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>Graph Representation</strong>: Choose right structure
                <ul>
                    <li>Adjacency list for sparse graphs</li>
                    <li>Matrix for dense graphs or grid problems</li>
                </ul>
            </li>
            <li>âŒ <strong>Visited Tracking</strong>: Mark visited when adding to queue (BFS), not when processing</li>
            <li>âŒ <strong>Cycle Detection</strong>:
                <ul>
                    <li>Undirected: Track parent</li>
                    <li>Directed: Track recursion stack (visiting state)</li>
                </ul>
            </li>
            <li>âŒ <strong>Bidirectional Edges</strong>: For undirected graphs, add edge in both directions</li>
            <li>âŒ <strong>Topological Sort</strong>: Only works on DAGs (Directed Acyclic Graphs)</li>
            <li>âŒ <strong>Dijkstra Limitations</strong>: Doesn't work with negative weights (use Bellman-Ford)</li>
            <li>âŒ <strong>Union-Find</strong>: Remember path compression and union by rank for efficiency</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Graph problem type?
        â”œâ”€ Shortest path?
        â”‚ â”œâ”€ Unweighted â†’ BFS (15.1)
        â”‚ â”œâ”€ Weighted (non-negative) â†’ Dijkstra (15.5)
        â”‚ â””â”€ With constraints (k stops) â†’ Modified Dijkstra
        â”œâ”€ Connected components / Connectivity?
        â”‚ â”œâ”€ Static â†’ DFS (15.2)
        â”‚ â””â”€ Dynamic (adding edges) â†’ Union-Find (15.4)
        â”œâ”€ Cycle detection?
        â”‚ â”œâ”€ Undirected â†’ DFS with parent or Union-Find
        â”‚ â””â”€ Directed â†’ DFS with recursion stack (15.2)
        â”œâ”€ Dependencies / Ordering?
        â”‚ â””â”€ Topological Sort (11.3)
        â””â”€ Grid/Matrix problem?
          â””â”€ Treat as graph, use DFS/BFS (11.6)
        </pre>
        <h3 id="must-know-problems">Must-Know Problems</h3>
        <h4 id="medium">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a> (200) -
                DFS/BFS
                foundation â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/clone-graph/">Clone Graph</a> (133) - Graph
                traversal + copy</li>
            <li><a target="_blank" href="https://leetcode.com/problems/max-area-of-island/">Max Area of Island</a> (695)
                - DFS with
                count</li>
            <li><a target="_blank" href="https://leetcode.com/problems/surrounded-regions/">Surrounded Regions</a> (130)
                - Border DFS â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">Pacific Atlantic
                    Water Flow</a>
                (417) - Reverse thinking â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/course-schedule/">Course Schedule</a> (207) -
                Cycle detection â­â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a> (210)
                - Topological
                sort â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/rotting-oranges/">Rotting Oranges</a> (994) -
                Multi-source BFS â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/redundant-connection/">Redundant Connection</a>
                (684) -
                Union-Find â­</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">Number
                    of
                    Connected Components</a> (323) - Components</li>
            <li><a target="_blank" href="https://leetcode.com/problems/graph-valid-tree/">Graph Valid Tree</a> (261) -
                Cycle +
                connectivity</li>
            <li><a target="_blank" href="https://leetcode.com/problems/network-delay-time/">Network Delay Time</a> (743)
                - Dijkstra â­â­
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">Cheapest
                    Flights Within K
                    Stops</a> (787) - Modified Dijkstra â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/min-cost-to-connect-all-points/">Min Cost to
                    Connect All
                    Points</a> (1584)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/walls-and-gates/">Walls and Gates</a> (286)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/snakes-and-ladders/">Snakes and Ladders</a> (909)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/evaluate-division/">Evaluate Division</a> (399)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-genetic-mutation/">Minimum Genetic
                    Mutation</a> (433)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/accounts-merge/">Accounts Merge</a> (721) - Union
                Find / DFS</li>
            <li><a target="_blank" href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">Shortest Path in
                    Binary Matrix</a> (1091) - BFS Level Order</li>
            <li><a target="_blank" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">All Nodes
                    Distance K in Binary Tree</a> (863) - Graph BFS conversion</li>
        </ol>

        <h4 id="hard">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/word-ladder/">Word Ladder</a> (127) - BFS on word
                graph â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/alien-dictionary/">Alien Dictionary</a> (269) -
                Topological Sort â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/swim-in-rising-water/">Swim in Rising Water</a>
                (778) - Binary
                search + BFS</li>
            <li><a target="_blank" href="https://leetcode.com/problems/reconstruct-itinerary/">Reconstruct Itinerary</a>
                (332)</li>
        </ol>
        <hr />
        <h1 id="phase-6-advanced-algorithms">PHASE 6: ADVANCED ALGORITHMS ğŸ’</h1>
        <h2 id="16-dynamic-programming-">16. DYNAMIC PROGRAMMING ğŸ’ </h2>
        <p><span style="background: #f59e0b; color: black; padding: 2px 8px; border-radius: 4px; font-size: 0.8em;">âš ï¸
                WEEK 9-11 (Requires recursion mastery from Trees!)</span> <strong>Difficulty:</strong> <span
                style="color: red">â˜…â˜…â˜…</span></p>
        <h3 id="when-to-use-15">When to Use </h3>
        <ul>
            <li>Overlapping subproblems + optimal structure</li>
            <li>Counts/paths/min-max costs</li>
            <li>Subsequences/strings</li>
            <li>Knapsack decisions</li>
            <li>Signal: "ways/max" + recursion hints</li>
        </ul>
        <h3 id="recognition">Recognition </h3>
        <ul>
            <li>Max/min/ways with choices</li>
            <li>Subproblems repeat (memoize)</li>
            <li>Bottom-up fill table</li>
        </ul>
        <h3 id="core-concept-15">Core Concept </h3>
        <p>Break into subproblems, store solutions to avoid recompute, building bottom-up from bases to optimize
            recursive exponential calls.</p>
        <h3 id="sub-patternss-7">Sub-Patternss </h3>
        <h4 id="16.1-1d-dp">16.1 1D Dynamic Programming</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-not">not</span> nums<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token number">0</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># Skip or take</span>
    <span class="token keyword keyword-return">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token comment"># Space opt: prev2, prev1 vars</span>
</code></pre>
        <h4 id="16.2-2d-dp">16.2 2D Dynamic Programming</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">longest_common_subsequence</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    m<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>text1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>text2<span class="token punctuation">)</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> _ <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-for">for</span> j <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword keyword-if">if</span> text1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword keyword-else">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
</code></pre>
        <h4 id="163-dp-on-trees">16.3 DP on Trees</h4>
        <p><strong>Use Case:</strong> Optimize decisions on tree structures (House Robber III pattern)</p>
        <pre><code class="language-python">def rob_tree(root):
    """
    HOUSE ROBBER III - DP ON TREES
    Can't rob two adjacent nodes (parent-child)

    KEY INSIGHT: Each node returns tuple (rob_this, skip_this)
    - rob_this: max money if we rob this node
    - skip_this: max money if we skip this node
    """
    def dfs(node):
        if not node:
            return (0, 0)  # (rob, skip)

        left = dfs(node.left)
        right = dfs(node.right)

        # If we rob this node, we can't rob children
        rob = node.val + left[1] + right[1]

        # If we skip this node, take max of each child
        skip = max(left) + max(right)

        return (rob, skip)

    return max(dfs(root))

def binary_tree_cameras(root):
    """
    BINARY TREE CAMERAS (968) - Greedy on Trees
    Minimum cameras to monitor all nodes

    State: 0 = needs camera, 1 = has camera, 2 = covered
    """
    cameras = [0]

    def dfs(node):
        if not node:
            return 2  # Null nodes are covered

        left = dfs(node.left)
        right = dfs(node.right)

        # If any child needs camera, install here
        if left == 0 or right == 0:
            cameras[0] += 1
            return 1  # This node has camera

        # If any child has camera, this is covered
        if left == 1 or right == 1:
            return 2  # Covered by child

        # Both children covered, this needs camera from parent
        return 0

    # Root might need camera if returned 0
    if dfs(root) == 0:
        cameras[0] += 1

    return cameras[0]
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h) for recursion</p>
        <h4 id="164-bitmask-dp">16.4 Bitmask DP</h4>
        <p><strong>Use Case:</strong> Track subset states efficiently (TSP, subset problems)</p>
        <pre><code class="language-python">def traveling_salesman(dist, n):
    """
    TRAVELING SALESMAN with Bitmask DP
    Visit all cities exactly once, return to start with minimum cost

    KEY INSIGHT: Use bitmask to represent visited cities
    - mask = 0b1010 means cities 1 and 3 are visited
    - O(nÂ² Ã— 2^n) time - exponential but better than O(n!)
    """
    memo = {}

    def dp(mask, pos):
        # All cities visited
        if mask == (1 &lt;&lt; n) - 1:
            return dist[pos][0]  # Return to start

        if (mask, pos) in memo:
            return memo[(mask, pos)]

        ans = float('inf')
        for city in range(n):
            # If city not visited
            if not (mask &amp; (1 &lt;&lt; city)):
                new_mask = mask | (1 &lt;&lt; city)
                ans = min(ans, dist[pos][city] + dp(new_mask, city))

        memo[(mask, pos)] = ans
        return ans

    return dp(1, 0)  # Start at city 0, mask = 1 (city 0 visited)

def shortest_path_all_nodes(graph):
    """
    Shortest Path Visiting All Nodes (847)
    BFS with bitmask state
    """
    from collections import deque
    n = len(graph)
    target = (1 &lt;&lt; n) - 1  # All nodes visited

    # Start from every node
    queue = deque()
    visited = set()

    for i in range(n):
        mask = 1 &lt;&lt; i
        queue.append((i, mask, 0))  # (node, visited_mask, distance)
        visited.add((i, mask))

    while queue:
        node, mask, dist = queue.popleft()

        if mask == target:
            return dist

        for neighbor in graph[node]:
            new_mask = mask | (1 &lt;&lt; neighbor)
            if (neighbor, new_mask) not in visited:
                visited.add((neighbor, new_mask))
                queue.append((neighbor, new_mask, dist + 1))

    return -1
</code></pre>
        <p><strong>Time:</strong> O(nÂ² Ã— 2^n) | <strong>Space:</strong> O(n Ã— 2^n)</p>
        <h3 id="5-steps">5 Steps </h3>
        <ol>
            <li>State: dp[i][j] = max profit up to i</li>
            <li>Recur: dp[i] = max(dp[i-1], dp[i-2] + val)</li>
            <li>Base: dp[0]=0, dp[1]=val[0]</li>
            <li>Order: For i in 1 to n (dependencies first)</li>
            <li>Space: 2Dâ†’1D if row-only deps</li>
        </ol>
        <h3 id="traps-14">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ Base cases wrong (off-by-one in init)</li>
            <li>âŒ Iteration order: Compute small to large</li>
            <li>âŒ Bounds: Use n+1 sizing</li>
            <li>âŒ Space: Optimize to O(min(m,n)) when possible</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Optimization (Min/Max)?
        â”œâ”€ Counting ways?
        â””â”€ Decision making with state?
           â”œâ”€ 1D Array? â†’ Linear DP (House Robber)
           â”œâ”€ 2D Grid/Strings? â†’ LCS / Unique Paths
           â”œâ”€ Decisions (Unbounded)? â†’ Knapsack (Coin Change)
           â””â”€ Intervals? â†’ MCM / Burst Balloons
        </pre>
        <h3 id="must-know-problems-dp">Must-Know Problems</h3>
        <h4 id="1d-dp">1D DP</h4>
        <h5 id="easy-11">Easy</h5>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a> (70)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/min-cost-climbing-stairs/">Min Cost Climbing
                    Stairs</a> (746)
            </li>
        </ol>
        <h4 id="medium-14">Medium </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/house-robber/">House Robber</a> (198)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/house-robber-ii/">House Robber II</a> (213)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-palindromic-substring/">Longest
                    Palindromic Substring</a>
                (5)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindromic-substrings/">Palindromic
                    Substrings</a> (647)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/decode-ways/">Decode Ways</a> (91)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/coin-change/">Coin Change</a> (322)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/maximum-product-subarray/">Maximum Product
                    Subarray</a> (152)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/word-break/">Word Break</a> (139)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest
                    Increasing
                    Subsequence</a> (300)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/partition-equal-subset-sum/">Partition Equal
                    Subset Sum</a> (416)
            </li>
        </ol>
        <h3 id="2d">2D </h3>
        <h4 id="medium-15">Medium </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/unique-paths/">Unique Paths</a> (62)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-common-subsequence/">Longest Common
                    Subsequence</a>
                (1143)</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Best Time
                    Buy/Sell with Cooldown</a> (309)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/coin-change-ii/">Coin Change II</a> (518)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/target-sum/">Target Sum</a> (494)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/interleaving-string/">Interleaving String</a>
                (97)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/triangle/">Triangle</a> (120)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a> (64)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a> (63)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/edit-distance/">Edit Distance</a> (72)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/maximal-square/">Maximal Square</a> (221)</li>
        </ol>
        <h4 id="hard-12">Hard </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">Longest
                    Increasing Path in
                    Matrix</a> (329)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/distinct-subsequences/">Distinct Subsequences</a>
                (115)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/burst-balloons/">Burst Balloons</a> (312)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/regular-expression-matching/">Regular Expression
                    Matching</a>
                (10)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/wildcard-matching/">Wildcard Matching</a> (44) -
                DP Pattern â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">Best Time
                    to Buy and Sell
                    Stock III</a> (123)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to
                    Buy and Sell
                    Stock IV</a> (188)</li>
        </ol>

        <hr />
        <h2 id="17-divide--conquer-">17. DIVIDE &amp; CONQUER ğŸ”ª </h2>
        <h3 id="when-to-use-16">When to Use </h3>
        <ul>
            <li>Merge sorted data</li>
            <li>Tree building from arrays</li>
            <li>Large sort/inversions</li>
            <li>Matrix multiply</li>
            <li>Signal: "sorted input" + "merge halves"</li>
        </ul>
        <h3 id="core-concept-16">Core Concept </h3>
        <p>Recur on halves, conquer by merging solutions, achieving log factors for balanced divides like sorting or
            tree construction.</p>
        <h3 id="sub-patterns-8">Sub-Patterns </h3>
        <h4 id="17.1-merge-sort-pattern">17.1 Merge Sort Pattern</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-if">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> arr<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment"># Inversions</span>
    mid <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    left<span class="token punctuation">,</span> inv_l <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
    right<span class="token punctuation">,</span> inv_r <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    merged<span class="token punctuation">,</span> inv_m <span class="token operator">=</span> merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> merged<span class="token punctuation">,</span> inv_l <span class="token operator">+</span> inv_r <span class="token operator">+</span> inv_m
<span class="token keyword keyword-def">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
    merged <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    inv <span class="token operator">=</span> i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword keyword-while">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token keyword keyword-and">and</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-if">if</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            merged<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword keyword-else">else</span><span class="token punctuation">:</span>
            merged<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            inv <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token comment"># All remaining left &gt; right[j]</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword keyword-return">return</span> merged <span class="token operator">+</span> left<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inv
</code></pre>
        <p><strong>Sorted Array to BST</strong></p>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">sorted_array_to_bst</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-if">if</span> left <span class="token operator">&gt;</span> right<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">None</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> helper<span class="token punctuation">(</span>left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> helper<span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> root
    <span class="token keyword keyword-return">return</span> helper<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
        <h3 id="traps-15">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ Recursion depth: O(log n) ok, but stack overflow on n=10^5</li>
            <li>âŒ Merge efficiency: O(n) per level, total O(n log n)</li>
            <li>âŒ Off-mid: Balance tree with mid choice</li>
            <li>âŒ Base: <code>left &gt; right</code> not <code>==</code></li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        â”œâ”€ Splitting input?
        â”‚ â”œâ”€ Merge Sort? â†’ Split, Sort, Merge
        â”‚ â””â”€ Quick Sort? â†’ Partition around pivot
        â””â”€ Multiplication?
           â””â”€ Karatsuba / Strassen
        </pre>
        <h3 id="must-know-problems_17">Must-Know Problems</h3>
        <h4 id="easy_12">Easy</h4>
        <ol>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted
                    Array
                    to Binary Search Tree</a> (108)</li>
        </ol>
        <h4 id="medium_16">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/sort-list/">Sort List</a> (148)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/construct-quad-tree/">Construct Quad Tree</a>
                (427)</li>
        </ol>
        <h4 id="hard_13">Hard</h4>
        <ol>
        </ol>

        <hr />

        <h1 id="phase-7-interview-essentials">PHASE 7: INTERVIEW ESSENTIALS ğŸ¯</h1>
        <h2 id="18-design-questions">18. DESIGN QUESTIONS ğŸ—ï¸</h2>
        <p><strong>Difficulty:</strong> <span style="color: red">â˜…â˜…â˜…</span> | <strong>FAANG Staple - Asked in 70%+ of
                interviews</strong></p>
        <h3 id="core-concept-design">Core Concept</h3>
        <p>Implement data structures with specific requirements (O(1) operations, capacity limits). Often combines
            HashMap with Linked List or Heap.</p>
        <h3 id="when-to-use-design">When to Use</h3>
        <ul>
            <li>âœ… Cache implementations (LRU, LFU)</li>
            <li>âœ… Stack/Queue with O(1) special operations</li>
            <li>âœ… Data stream processing</li>
            <li>âœ… Real-time leaderboards</li>
            <li><strong>Signal Words:</strong> "design", "implement", "O(1)", "recently used"</li>
        </ul>
        <h3 id="sub-patterns-design">Sub-Patterns</h3>
        <h4 id="181-lru-cache">18.1 LRU Cache</h4>
        <p><strong>Use Case:</strong> O(1) get/put with capacity limit, evict least recently used</p>
        <pre><code class="language-python">class LRUCache:
    """
    LRU CACHE - FAANG STAPLE
    O(1) get, O(1) put

    TECHNIQUE: Doubly Linked List + HashMap
    - HashMap: key -> Node (O(1) access)
    - DLL: Maintain recency order (O(1) move to front)
    - Tail is least recently used
    """
    class Node:
        def __init__(self, key=0, val=0):
            self.key = key
            self.val = val
            self.prev = None
            self.next = None

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node

        # Dummy head and tail for easy operations
        self.head = self.Node()
        self.tail = self.Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node):
        """Remove node from DLL"""
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add_to_front(self, node):
        """Add node right after head (most recent)"""
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key: int) -&gt; int:
        if key not in self.cache:
            return -1

        node = self.cache[key]
        # Move to front (most recently used)
        self._remove(node)
        self._add_to_front(node)
        return node.val

    def put(self, key: int, value: int) -&gt; None:
        if key in self.cache:
            # Update existing
            self._remove(self.cache[key])

        node = self.Node(key, value)
        self._add_to_front(node)
        self.cache[key] = node

        if len(self.cache) &gt; self.capacity:
            # Evict LRU (node before tail)
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
</code></pre>
        <p><strong>Time:</strong> O(1) for all operations | <strong>Space:</strong> O(capacity)</p>
        <h4 id="182-min-stack">18.2 Min Stack</h4>
        <p><strong>Use Case:</strong> Stack with O(1) getMin</p>
        <pre><code class="language-python">class MinStack:
    """
    TECHNIQUE: Store (value, current_min) pairs
    Or use two stacks: one for values, one for mins
    """
    def __init__(self):
        self.stack = []  # (value, min_at_this_point)

    def push(self, val: int) -&gt; None:
        current_min = val if not self.stack else min(val, self.stack[-1][1])
        self.stack.append((val, current_min))

    def pop(self) -&gt; None:
        self.stack.pop()

    def top(self) -&gt; int:
        return self.stack[-1][0]

    def getMin(self) -&gt; int:
        return self.stack[-1][1]
</code></pre>
        <p><strong>Time:</strong> O(1) all operations | <strong>Space:</strong> O(n)</p>
        <h3 id="common-traps-design">Common Traps ğŸš¨</h3>
        <ul>
            <li>âŒ <strong>HashMap key deletion</strong>: When evicting from cache, remember to delete from HashMap too
            </li>
            <li>âŒ <strong>Dummy nodes</strong>: For DLL, use dummy head/tail to avoid null checks</li>
            <li>âŒ <strong>Update order</strong>: For LRU, update cache AFTER adding to DLL to avoid partial state</li>
            <li>âŒ <strong>Capacity check timing</strong>: Check capacity AFTER insert, not before</li>
            <li>âŒ <strong>Thread safety</strong>: In interviews, mention mutex/locks for concurrent access</li>
        </ul>
        <h3 id="decision-tree-design">Decision Tree</h3>
        <pre>
Design Problem Type...
â”œâ”€ Cache with eviction?
â”‚   â”œâ”€ Evict least recent â†’ LRU (DLL + HashMap)
â”‚   â””â”€ Evict least frequent â†’ LFU (HashMap + Freq Lists)
â”œâ”€ Get O(1) min/max?
â”‚   â”œâ”€ Stack â†’ Store (val, min) pairs
â”‚   â””â”€ Queue â†’ Two stacks or deque with monotonic
â”œâ”€ Stream processing?
â”‚   â”œâ”€ Moving average â†’ Sliding window queue
â”‚   â””â”€ Find median â†’ Two heaps
â””â”€ Social network?
    â””â”€ Twitter â†’ HashMap + Heap for merge
        </pre>
        <h3 id="must-know-problems-design">Must-Know Problems</h3>
        <h4 id="medium-design">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/lru-cache/">LRU Cache</a> (146) - Classic design
                â­â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/min-stack/">Min Stack</a> (155) â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie</a>
                (208) â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/design-twitter/">Design Twitter</a> (355)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/time-based-key-value-store/">Time Based Key-Value
                    Store</a> (981)</li>
        </ol>
        <h4 id="hard-design">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/lfu-cache/">LFU Cache</a> (460) â­â­</li>
            <li><a target="_blank" href="https://leetcode.com/problems/all-oone-data-structure/">All O'one Data
                    Structure</a> (432)</li>
        </ol>
        <hr />
        <h2 id="interview-frequency-table">ğŸ“Š Interview Frequency by Company</h2>
        <table style="width:100%; border-collapse: collapse; margin: 20px 0;">
            <thead>
                <tr style="background-color: #333; color: white;">
                    <th style="padding: 12px; border: 1px solid #555;">Pattern</th>
                    <th style="padding: 12px; border: 1px solid #555;">Google</th>
                    <th style="padding: 12px; border: 1px solid #555;">Meta</th>
                    <th style="padding: 12px; border: 1px solid #555;">Amazon</th>
                    <th style="padding: 12px; border: 1px solid #555;">Apple</th>
                    <th style="padding: 12px; border: 1px solid #555;">Microsoft</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Arrays & Hashing</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">95%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">90%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">85%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">85%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Binary Search</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">65%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">75%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Sliding Window</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">75%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">85%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">65%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Trees (BFS/DFS)</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">90%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">95%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">85%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Graphs</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">85%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">75%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">75%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Dynamic Programming</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">75%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">65%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Backtracking</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">60%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">55%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">50%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">55%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">60%</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #444;">Design</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">70%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">85%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">90%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">75%</td>
                    <td style="padding: 10px; border: 1px solid #444; text-align: center;">80%</td>
                </tr>
            </tbody>
        </table>
        <hr />
        <h2 id="interview-survival-guide">ğŸ¯ INTERVIEW SURVIVAL GUIDE</h2>
        <h3 id="red-flags">Red Flags Interviewers Watch For</h3>
        <ul>
            <li>âŒ <strong>Jumping to code</strong> without clarifying constraints</li>
            <li>âŒ <strong>Not discussing</strong> time/space complexity</li>
            <li>âŒ <strong>Not testing</strong> with edge cases</li>
            <li>âŒ <strong>Overcomplicating</strong> simple solutions</li>
            <li>âŒ <strong>Silent coding</strong> - not communicating thought process</li>
            <li>âŒ <strong>Getting stuck</strong> without asking for hints</li>
        </ul>
        <h3 id="perfect-interview-flow">The Perfect Interview Flow</h3>
        <pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. CLARIFY (2 min)                                      â”‚
â”‚    â€¢ Ask about input size and constraints               â”‚
â”‚    â€¢ Clarify edge cases (empty, single element, etc.)   â”‚
â”‚    â€¢ Confirm input/output format                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. APPROACH (5 min)                                     â”‚
â”‚    â€¢ Start with brute force approach                    â”‚
â”‚    â€¢ Identify optimization opportunities                â”‚
â”‚    â€¢ Explain your optimal approach clearly              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. COMPLEXITY (1 min)                                   â”‚
â”‚    â€¢ State time complexity BEFORE coding               â”‚
â”‚    â€¢ State space complexity                             â”‚
â”‚    â€¢ Justify why this is acceptable                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. CODE (15-20 min)                                     â”‚
â”‚    â€¢ Write clean, modular code                          â”‚
â”‚    â€¢ Use meaningful variable names                      â”‚
â”‚    â€¢ Explain as you code                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5. TEST (5 min)                                         â”‚
â”‚    â€¢ Walk through with a simple example                 â”‚
â”‚    â€¢ Test edge cases explicitly                         â”‚
â”‚    â€¢ Fix bugs calmly if found                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6. OPTIMIZE (2 min)                                     â”‚
â”‚    â€¢ Discuss further optimizations if any               â”‚
â”‚    â€¢ Mention trade-offs                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        </pre>
        <h3 id="must-ask-questions">Must-Ask Questions Before Coding</h3>
        <ul>
            <li>ğŸ“ <strong>"What's the size of the input?"</strong> - Determines acceptable complexity</li>
            <li>âš¡ <strong>"Are there any time/space constraints?"</strong> - May rule out some approaches</li>
            <li>ğŸ”§ <strong>"Can I modify the input array?"</strong> - Important for in-place algorithms</li>
            <li>âš ï¸ <strong>"Should I handle invalid inputs?"</strong> - Shows defensive thinking</li>
            <li>ğŸ”„ <strong>"Is the input sorted or can I sort it?"</strong> - Opens two-pointer/binary search</li>
            <li>ğŸ“Š <strong>"Can there be duplicates?"</strong> - Affects edge case handling</li>
        </ul>

    </div>
</body>

</html>
