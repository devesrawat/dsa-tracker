<!DOCTYPE html>
<html>

<head>
    <title>DSA Patterns</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Devesh Rawat <devsrawt@gmail.com>">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <link rel="stylesheet" href="style.css?v=dracula2">
    <script src="script.js?v=dracula2"></script>
    <!-- PrismJS for Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</head>

<body for="html-export">
    <div class="crossnote markdown-preview  ">
        <h1 id="dsa-mastery-progressive-pattern-guide">üéØ DSA MASTERY: PROGRESSIVE PATTERN GUIDE</h1>
        <p><strong>A weapon to conquer Data Structures &amp; Algorithms through pattern recognition and progressive
                learning</strong></p>
        <hr />
        <h2 id="learning-progression-philosophy">üìö Learning Progression Philosophy</h2>
        <p>This guide is organized so each pattern builds upon previous knowledge:</p>
        <ol>
            <li><strong>Phase 1: Foundation (Patterns 1-3)</strong> - Arrays, Two Pointers, Sliding Window</li>
            <li><strong>Phase 2: Searching & Basic Structures (Patterns 4-6)</strong> - Binary Search, Stack, Linked
                List</li>
            <li><strong>Phase 3: Optimization & Math (Patterns 7-11)</strong> - Greedy, Intervals, Bit Manipulation,
                Math, Heap</li>
            <li><strong>Phase 4: Trees & Recursion (Patterns 12-14)</strong> - Binary Trees, Tries, Backtracking</li>
            <li><strong>Phase 5: Graph Mastery (Pattern 15)</strong> - BFS, DFS, Union-Find, Shortest Path</li>
            <li><strong>Phase 6: Advanced Algorithms (Patterns 16-17)</strong> - Dynamic Programming, Divide & Conquer
            </li>
        </ol>
        <hr />
        <h2 id="how-to-use-this-guide">How to Use This Guide</h2>
        <ol>
            <li><strong>Master Prerequisites</strong>: Don't skip phases - each builds on the last</li>
            <li><strong>Learn the WHY</strong>: Understand when and why to use each pattern</li>
            <li><strong>Memorize Templates</strong>: Each pattern has 2-3 core templates</li>
            <li><strong>Practice Deliberately</strong>: Start with Easy, identify the pattern before coding</li>
            <li><strong>Review Traps</strong>: Learn from common mistakes</li>
            <li><strong>Space/Time Analysis</strong>: Always analyze complexity</li>
            <li><strong>Revisit</strong>: Come back after 48 hours, 1 week, 1 month</li>
        </ol>
        <hr />
        <h1 id="phase-1-foundation">PHASE 1: FOUNDATION üèóÔ∏è</h1>
        <h2 id="1-arrays-hashing">1. ARRAYS &amp; HASHING üîë</h2>
        <p><strong>Difficulty:</strong> <span style="color: green">‚òÖ‚òÜ‚òÜ</span> | <strong>Foundation Level</strong></p>
        <h3 id="core-concept">Core Concept</h3>
        <p>Transform O(n¬≤) brute force into O(n) using hash tables for instant lookups. Think: "Do I need to remember
            what I've seen?"</p>
        <h3 id="when-to-use">When to Use</h3>
        <ul>
            <li>‚úÖ Counting frequencies/occurrences</li>
            <li>‚úÖ Detecting duplicates/anagrams</li>
            <li>‚úÖ Finding complements (two sum pattern)</li>
            <li>‚úÖ Grouping related items</li>
            <li>‚úÖ Mapping indices to values</li>
            <li><strong>Signal Words:</strong> "unique", "frequency", "group by", "find pair that sums to"</li>
        </ul>
        <h3 id="sub-patterns">Sub-Patterns</h3>
        <h4 id="11-frequency-counter-pattern">1.1 Frequency Counter Pattern</h4>
        <p><strong>Use Case:</strong> Count occurrences, find majority elements, top K frequent</p>
        <pre><code class="language-python">from collections import Counter

        def top_k_frequent(nums, k):
            # O(n) time, O(n) space
            count = Counter(nums)
            # Counter returns most common in O(n log k) for heap
            return [num for num, freq in count.most_common(k)]

        # Alternative: Bucket sort for O(n)
        def top_k_bucket(nums, k):
            count = Counter(nums)
            buckets = [[] for _ in range(len(nums) + 1)]
            for num, freq in count.items():
                buckets[freq].append(num)

            result = []
            for i in range(len(buckets) - 1, 0, -1):
                result.extend(buckets[i])
                if len(result) &gt;= k:
                    return result[:k]
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="12-index-mapping-pattern-two-sum-family">1.2 Index Mapping Pattern (Two Sum Family)</h4>
        <p><strong>Use Case:</strong> Find pairs, triplets that meet conditions</p>
        <pre><code class="language-python">def two_sum(nums, target):
            &quot;&quot;&quot;
            Store what we've seen with indices
            Key insight: target - current = complement we need
            &quot;&quot;&quot;
            seen = {}  # value: index
            for i, num in enumerate(nums):
                complement = target - num
                if complement in seen:
                    return [seen[complement], i]
                seen[num] = i
            return []

        def two_sum_all_pairs(nums, target):
            &quot;&quot;&quot;Find ALL pairs (not indices)&quot;&quot;&quot;
            seen = set()
            pairs = set()
            for num in nums:
                complement = target - num
                if complement in seen:
                    pairs.add((min(num, complement), max(num, complement)))
                seen.add(num)
            return list(pairs)
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="13-grouping-pattern-anagrams-etc">1.3 Grouping Pattern (Anagrams, etc.)</h4>
        <p><strong>Use Case:</strong> Group items by some computed key</p>
        <pre><code class="language-python">from collections import defaultdict

        def group_anagrams(strs):
            &quot;&quot;&quot;
            Key insight: Anagrams have same character frequency
            Use sorted string or char count as key
            &quot;&quot;&quot;
            groups = defaultdict(list)

            for s in strs:
                # Method 1: Sorted string as key - O(k log k) per string
                key = ''.join(sorted(s))

                # Method 2: Character count - O(k) per string
                # key = tuple(sorted(Counter(s).items()))

                groups[key].append(s)

            return list(groups.values())
        </code></pre>
        <p><strong>Time:</strong> O(n * k log k) where k = avg string length | <strong>Space:</strong> O(nk)</p>
        <h4 id="14-running-computation-pattern">1.4 Running Computation Pattern</h4>
        <p><strong>Use Case:</strong> Prefix sums, cumulative products</p>
        <pre><code class="language-python">def product_except_self(nums):
            &quot;&quot;&quot;
            Key insight: result[i] = (product of all left) * (product of all right)
            Use two passes instead of division
            &quot;&quot;&quot;
            n = len(nums)
            result = [1] * n

            # Left pass: result[i] = product of all nums[0..i-1]
            left_product = 1
            for i in range(n):
                result[i] = left_product
                left_product *= nums[i]

            # Right pass: multiply by product of all nums[i+1..n-1]
            right_product = 1
            for i in range(n - 1, -1, -1):
                result[i] *= right_product
                right_product *= nums[i]

            return result
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1) excluding output</p>
        <h3 id="common-traps">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Hash Collisions</strong>: Rare in Python, but use tuple for composite keys</li>
            <li>‚ùå <strong>Mutable Keys</strong>: Lists can't be dict keys - use tuples</li>
            <li>‚ùå <strong>Space Explosion</strong>: O(n) space acceptable for n &lt; 10^6</li>
            <li>‚ùå <strong>Empty Input</strong>: Always check <code>if not nums: return []</code></li>
            <li>‚ùå <strong>Order Matters</strong>: Hash sets lose order - use dict if order matters (Python 3.7+)</li>
        </ul>
        <h3 id="complexity-analysis">Complexity Analysis</h3>
        <ul>
            <li><strong>Hash Insert/Lookup</strong>: O(1) average, O(n) worst case</li>
            <li><strong>Counter Creation</strong>: O(n)</li>
            <li><strong>Space</strong>: O(n) for hash table</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Frequency/Count? ‚Üí Hash Map/Set
        ‚îú‚îÄ Duplicate check? ‚Üí Hash Set
        ‚îú‚îÄ Pair/Sum finding? ‚Üí Hash Map (Two Sum)
        ‚îú‚îÄ Anagrams? ‚Üí Sort or Hash Map (Count)
        ‚îú‚îÄ Prefix Sum? ‚Üí Continuous sub-array sum
        ‚îî‚îÄ Sliding Window? ‚Üí Contiguous subarray/substring
        </pre>
        <h3 id="must-know-problems">Must-Know Problems</h3>
        <h4 id="easy-master-these-first">Easy (Master These First)</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/contains-duplicate/">Contains Duplicate</a> (217)
                - Set basics
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-anagram/">Valid Anagram</a> (242) -
                Frequency count</li>
            <li><a target="_blank" href="https://leetcode.com/problems/two-sum/">Two Sum</a> (1) - Index mapping ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/majority-element/">Majority Element</a> (169) -
                Boyer-Moore or
                hash</li>
            <li><a target="_blank" href="https://leetcode.com/problems/roman-to-integer/">Roman to Integer</a> (13) -
                Mapping pattern
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-element/">Remove Element</a> (27)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-common-prefix/">Longest Common Prefix</a>
                (14)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/">Find the
                    Index of the First Occurrence in a String</a> (28)</li>
        </ol>
        <h4 id="medium-core-pattern-practice">Medium (Core Pattern Practice)</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/group-anagrams/">Group Anagrams</a> (49) -
                Grouping pattern ‚≠ê
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/top-k-frequent-elements/">Top K Frequent
                    Elements</a> (347) -
                    Frequency + heap/bucket</li>
            <li><a target="_blank" href="https://leetcode.com/problems/product-of-array-except-self/">Product of Array
                    Except Self</a>
                    (238) - Running computation ‚≠ê</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a> (36) - Multiple
                        hash sets</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/longest-consecutive-sequence/">Longest
                            Consecutive Sequence</a>
                        (128) - Set membership ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/encode-and-decode-strings/">Encode and Decode
                    Strings</a> (271) - String manipulation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/rotate-array/">Rotate Array</a> (189)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/subarray-sum-equals-k/">Subarray Sum Equals K</a>
                (560) - Prefix Sum ‚≠ê</li>
            </ol>
            <hr />
            <h2 id="2-two-pointers">2. TWO POINTERS üëâüëà</h2>
            <p><strong>Difficulty:</strong> <span style="color: green">‚òÖ‚òÜ‚òÜ</span> | <strong>Builds on:</strong> Arrays</p>
            <h3 id="core-concept_1">Core Concept</h3>
            <p>Reduce O(n¬≤) nested loops to O(n) by using two pointers that move based on conditions. Think: "Can I
                eliminate one dimension by smart pointer movement?"</p>
            <h3 id="when-to-use_1">When to Use</h3>
        <ul>
            <li>‚úÖ <strong>Sorted arrays</strong> for pair/triplet finding</li>
            <li>‚úÖ In-place array modifications</li>
            <li>‚úÖ Palindrome validation</li>
            <li>‚úÖ Partitioning/segregating elements</li>
            <li>‚úÖ Finding cycles (fast-slow pointer)</li>
            <li><strong>Signal Words:</strong> "sorted", "pair", "palindrome", "in-place", "two ends"</li>
        </ul>
        <h3 id="sub-patterns_1">Sub-Patterns</h3>
        <h4 id="21-opposite-direction-collision">2.1 Opposite Direction (Collision)</h4>
        <p><strong>Use Case:</strong> Sorted array pair problems, palindromes</p>
        <pre><code class="language-python">def two_sum_sorted(nums, target):
            &quot;&quot;&quot;
            PREREQUISITE: Array must be sorted
            Pointers converge from ends based on sum comparison
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt; right:
                current_sum = nums[left] + nums[right]

                if current_sum == target:
                    return [left, right]
                elif current_sum &lt; target:
                    left += 1  # Need larger sum
                else:
                    right -= 1  # Need smaller sum

            return []

        def is_palindrome(s):
            &quot;&quot;&quot;
            Clean and check from both ends
            Key: Skip non-alphanumeric characters
            &quot;&quot;&quot;
            left, right = 0, len(s) - 1

            while left &lt; right:
                # Skip non-alphanumeric
                while left &lt; right and not s[left].isalnum():
                    left += 1
                while left &lt; right and not s[right].isalnum():
                    right -= 1

                if s[left].lower() != s[right].lower():
                    return False

                left += 1
                right -= 1

            return True
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="22-same-direction-fast-slow">2.2 Same Direction (Fast-Slow)</h4>
        <p><strong>Use Case:</strong> Remove duplicates, move zeros, cycle detection</p>
        <pre><code class="language-python">def remove_duplicates(nums):
            &quot;&quot;&quot;
            Slow pointer = position to place next unique
            Fast pointer = explorer finding next unique
            Works on SORTED array only
            &quot;&quot;&quot;
            if not nums:
                return 0

            slow = 1  # Position for next unique element

            for fast in range(1, len(nums)):
                if nums[fast] != nums[slow - 1]:
                    nums[slow] = nums[fast]
                    slow += 1

            return slow  # New length

        def move_zeros(nums):
            &quot;&quot;&quot;
            Slow = position for next non-zero
            Fast = explorer finding non-zeros
            &quot;&quot;&quot;
            slow = 0

            for fast in range(len(nums)):
                if nums[fast] != 0:
                    nums[slow], nums[fast] = nums[fast], nums[slow]
                    slow += 1
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="23-three-pointers-3sum-pattern">2.3 Three Pointers (3Sum Pattern)</h4>
        <p><strong>Use Case:</strong> Finding triplets in sorted array</p>
        <pre><code class="language-python">def three_sum(nums):
            &quot;&quot;&quot;
            Fix one number, use two pointers for remaining pair
            MUST sort first: O(n log n)
            Total: O(n¬≤) - acceptable for n &lt; 1000
            &quot;&quot;&quot;
            nums.sort()
            result = []

    for i in range(len(nums) - 2):
    # Skip duplicates for first number
    if i &gt; 0 and nums[i] == nums[i-1]:
    continue

    left, right = i + 1, len(nums) - 1
    target = -nums[i]

    while left &lt; right:
    current_sum = nums[left] + nums[right]

    if current_sum == target:
    result.append([nums[i], nums[left], nums[right]])

    # Skip duplicates for second number
    while left &lt; right and nums[left] == nums[left + 1]:
    left += 1
    # Skip duplicates for third number
    while left &lt; right and nums[right] == nums[right - 1]:
    right -= 1

    left += 1
    right -= 1
    elif current_sum &lt; target:
    left += 1
    else:
    right -= 1

    return result
    </code></pre>
    <p><strong>Time:</strong> O(n¬≤) | <strong>Space:</strong> O(1) excluding output</p>
    <h4 id="24-sliding-window-with-two-pointers">2.4 Sliding Window with Two Pointers</h4>
    <p><strong>Use Case:</strong> Variable-size windows (covered more in Pattern 3)</p>
    <pre><code class="language-python">def container_with_most_water(height):
        &quot;&quot;&quot;
        Key insight: Move pointer with smaller height
        Why? Larger height might form bigger area with other side
        &quot;&quot;&quot;
        left, right = 0, len(height) - 1
        max_area = 0

        while left &lt; right:
            # Area limited by shorter height
            width = right - left
            current_area = width * min(height[left], height[right])
            max_area = max(max_area, current_area)

            # Move the pointer with smaller height
            if height[left] &lt; height[right]:
                left += 1
            else:
                right -= 1

        return max_area
    </code></pre>
    <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
    <h3 id="common-traps_1">Common Traps üö®</h3>
    <ul>
        <li>‚ùå <strong>Unsorted Input</strong>: Two-pointer collision only works on sorted data</li>
        <li>‚ùå <strong>Duplicate Handling</strong>: Must skip duplicates in 3Sum to avoid duplicate triplets</li>
        <li>‚ùå <strong>Boundary Conditions</strong>: Use <code>left &lt; right</code> not <code>left &lt;= right</code> for
            collision</li>
        <li>‚ùå <strong>Off-by-One</strong>: Initialize slow pointer correctly (often 0 or 1)</li>
        <li>‚ùå <strong>Modifying While Iterating</strong>: Use slow pointer for in-place modifications</li>
    </ul>
    <h3 id="decision-tree">Decision Tree</h3>
    <pre><code>Is array sorted?
    ‚îú‚îÄ Yes ‚Üí Use collision (opposite direction)
    ‚îÇ   ‚îî‚îÄ Finding pair/sum? ‚Üí Start from ends, converge
    ‚îî‚îÄ No ‚Üí Can you sort? (O(n log n) acceptable?)
        ‚îú‚îÄ Yes ‚Üí Sort then use two pointers
        ‚îî‚îÄ No ‚Üí Use hash table (Pattern 1) or sliding window (Pattern 3)
    </code></pre>

    <h3 id="must-know-problems_1">Must-Know Problems</h3>
    <h4 id="easy">Easy</h4>
    <ol>
        <li><a target="_blank" href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome</a> (125) -
            Collision pattern
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove
                    Duplicates from
                    Sorted Array</a> (26) - Fast-slow ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array</a> (88)
                - Reverse
                collision</li>
            <li><a target="_blank" href="https://leetcode.com/problems/is-subsequence/">Is Subsequence</a> (392) - Same
                direction</li>
            </ol>
            <h4 id="medium">Medium</h4>
            <ol>
                <li><a target="_blank" href="https://leetcode.com/problems/3sum/">3Sum</a> (15) - Three pointers ‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/container-with-most-water/">Container With Most
                        Water</a> (11) -
                    Greedy collision ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">Remove
                    Duplicates from
                    Sorted Array II</a> (80) - Fast-slow variant</li>
            <li><a target="_blank" href="https://leetcode.com/problems/h-index/">H-Index</a> (274)</li>
        </ol>
        <h4 id="hard">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/candy/">Candy</a> (135)</li>
        </ol>
        <hr />
        <h2 id="3-sliding-window">3. SLIDING WINDOW ü™ü</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Builds on:</strong> Two
            Pointers, Hashing</p>
        <h3 id="core-concept_2">Core Concept</h3>
        <p>Maintain a dynamic window that expands/contracts to satisfy conditions. Converts O(n¬≤) "check all subarrays"
            to O(n) by reusing computation.</p>
        <h3 id="when-to-use_2">When to Use</h3>
        <ul>
            <li>‚úÖ <strong>Contiguous</strong> subarray/substring problems</li>
            <li>‚úÖ "Longest/shortest/maximum in subarray"</li>
            <li>‚úÖ "At most K" or "exactly K" constraints</li>
            <li>‚úÖ String permutation/anagram problems</li>
            <li><strong>Signal Words:</strong> "subarray", "substring", "contiguous", "window", "at most K"</li>
        </ul>
        <h3 id="sub-patterns_2">Sub-Patterns</h3>
        <h4 id="31-fixed-window-size">3.1 Fixed Window Size</h4>
        <p><strong>Use Case:</strong> Max sum of K elements, sliding average</p>
        <pre><code class="language-python">def max_sum_subarray_k(nums, k):
            &quot;&quot;&quot;
            Window size is constant K
            Slide by: add right element, remove left element
            &quot;&quot;&quot;
            if len(nums) &lt; k:
                return 0

            # Initialize first window
            window_sum = sum(nums[:k])
            max_sum = window_sum

            # Slide window
            for i in range(k, len(nums)):
                window_sum += nums[i] - nums[i - k]  # Add right, remove left
                max_sum = max(max_sum, window_sum)

            return max_sum

        def find_anagrams(s, p):
            &quot;&quot;&quot;
            Fixed window = len(p)
            Check if window is permutation of p
            &quot;&quot;&quot;
            if len(p) &gt; len(s):
                return []

            from collections import Counter
            p_count = Counter(p)
            window_count = Counter(s[:len(p)])
            result = []

            if window_count == p_count:
                result.append(0)

            for i in range(len(p), len(s)):
                # Add new character
                window_count[s[i]] += 1

                # Remove old character
                left_char = s[i - len(p)]
                window_count[left_char] -= 1
                if window_count[left_char] == 0:
                    del window_count[left_char]

                if window_count == p_count:
                    result.append(i - len(p) + 1)

            return result
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1) or O(k) for frequency map</p>
        <h4 id="32-dynamic-window-shrinkable-most-common">3.2 Dynamic Window - Shrinkable (Most Common)</h4>
        <p><strong>Use Case:</strong> Longest substring with K distinct, minimum window substring</p>
        <pre><code class="language-python">def length_of_longest_substring_k_distinct(s, k):
            &quot;&quot;&quot;
            TEMPLATE FOR DYNAMIC WINDOW:
            1. Expand right until invalid
            2. Shrink left while invalid
            3. Update result when valid
            &quot;&quot;&quot;
            from collections import defaultdict

            char_count = defaultdict(int)
            left = 0
            max_length = 0

            for right in range(len(s)):
                # Expand: add right character
                char_count[s[right]] += 1

                # Shrink: while invalid (too many distinct)
                while len(char_count) &gt; k:
                    char_count[s[left]] -= 1
                    if char_count[s[left]] == 0:
                        del char_count[s[left]]
                    left += 1

                # Update result when valid
                max_length = max(max_length, right - left + 1)

            return max_length

        def longest_substring_without_repeating(s):
            &quot;&quot;&quot;
            Special case: K = 1 (each char appears at most once)
            Use set or dict to track last seen index
            &quot;&quot;&quot;
            char_index = {}
            left = 0
            max_length = 0

            for right in range(len(s)):
                # If seen and within window, shrink from left
                if s[right] in char_index and char_index[s[right]] &gt;= left:
                    left = char_index[s[right]] + 1

                char_index[s[right]] = right
                max_length = max(max_length, right - left + 1)

            return max_length
</code></pre>
        <p><strong>Time:</strong> O(n) - each element visited at most twice | <strong>Space:</strong> O(k)</p>
        <h4 id="33-dynamic-window-non-shrinkable-optimization">3.3 Dynamic Window - Non-Shrinkable (Optimization)</h4>
        <p><strong>Use Case:</strong> When you only care about maximum window size</p>
        <pre><code class="language-python">def length_longest_substring_k_distinct_optimized(s, k):
            &quot;&quot;&quot;
            OPTIMIZATION: Keep window at max size, only expand
            If invalid, move both pointers (maintain size)
            Only expand when valid
            &quot;&quot;&quot;
            from collections import defaultdict

            char_count = defaultdict(int)
            left = 0

            for right in range(len(s)):
                char_count[s[right]] += 1

                # If invalid, move both pointers (don't shrink window)
                if len(char_count) &gt; k:
                    char_count[s[left]] -= 1
                    if char_count[s[left]] == 0:
                        del char_count[s[left]]
                    left += 1

            return right - left + 1  # Final window size is the answer
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(k)</p>
        <h4 id="34-minimum-window-substring-hard-pattern">3.4 Minimum Window Substring (Hard Pattern)</h4>
        <p><strong>Use Case:</strong> Find smallest window containing all characters</p>
        <pre><code class="language-python">def min_window_substring(s, t):
            &quot;&quot;&quot;
            HARD TEMPLATE:
            1. Expand until valid (contains all t chars)
            2. Shrink while still valid (minimize)
            3. Track minimum
            &quot;&quot;&quot;
            from collections import Counter

            if not s or not t:
                return &quot;&quot;

            required = Counter(t)
            needed = len(required)  # Unique chars needed
            formed = 0  # Unique chars satisfied

            window_counts = {}
            left = 0
            min_len = float('inf')
            min_left = 0

            for right in range(len(s)):
                # Expand: add right character
                char = s[right]
                window_counts[char] = window_counts.get(char, 0) + 1

                # Check if this char satisfies requirement
                if char in required and window_counts[char] == required[char]:
                    formed += 1

                # Shrink: while valid (all chars present)
                while formed == needed and left &lt;= right:
                    # Update result
                    if right - left + 1 &lt; min_len:
                        min_len = right - left + 1
                        min_left = left

                    # Remove left character
                    char = s[left]
                    window_counts[char] -= 1
                    if char in required and window_counts[char] &lt; required[char]:
                        formed -= 1

                    left += 1

            return &quot;&quot; if min_len == float('inf') else s[min_left:min_left + min_len]
        </code></pre>
        <p><strong>Time:</strong> O(n + m) | <strong>Space:</strong> O(m) where m = len(t)</p>
        <h3 id="common-traps_2">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Nested Loops</strong>: Should NEVER have nested while loops iterating - only shrink loop inside expand
            </li>
            <li>‚ùå <strong>When to Update Result</strong>:
                <ul>
                    <li>Maximum: Update when valid</li>
                    <li>Minimum: Update while valid (during shrink phase)</li>
                </ul>
            </li>
            <li>‚ùå <strong>Counter Cleanup</strong>: Always <code>del dict[key]</code> when count reaches 0</li>
            <li>‚ùå <strong>Empty Window</strong>: Check <code>if not s: return ""</code></li>
            <li>‚ùå <strong>Fixed vs Dynamic</strong>: Fixed = add/remove one at a time, Dynamic = shrink in while loop</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre><code>Subarray/substring problem?
        ‚îú‚îÄ Fixed size K given?
        ‚îÇ   ‚îî‚îÄ Use Fixed Window (3.1)
        ‚îî‚îÄ Variable size (find longest/shortest)?
            ‚îú‚îÄ Find LONGEST with constraint?
            ‚îÇ   ‚îî‚îÄ Use Dynamic Shrinkable (3.2)
            ‚îÇ       ‚îî‚îÄ Only care about max size? Use Non-shrinkable (3.3)
            ‚îî‚îÄ Find SHORTEST/MINIMUM?
                ‚îî‚îÄ Use Minimum Window (3.4) - shrink while valid
        </code></pre>

        <h3 id="must-know-problems_2">Must-Know Problems</h3>
        <h4 id="easy_1">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to
                    Buy and Sell
                    Stock</a> (121) - Min tracking</li>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to
                    Buy and Sell
                    Stock II</a> (122)</li>
        </ol>
        <h4 id="medium_1">Medium</h4>
        <ol>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest
                    Substring Without Repeating Characters</a> (3) - Classic template ‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-repeating-character-replacement/">Longest
                    Repeating
                    Character Replacement</a> (424) - With K changes</li>
            <li><a target="_blank" href="https://leetcode.com/problems/permutation-in-string/">Permutation in String</a>
                (567) - Fixed
                window variant</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-size-subarray-sum/">Minimum Size Subarray
                    Sum</a> (209) -
                    Minimum window ‚≠ê</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">Find All Anagrams
                            in a String</a> (438) - Optimization of generic template</li>
                    </ol>
                    <h4 id="hard">Hard</h4>
                    <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-window-substring/">Minimum Window
                    Substring</a> (76) -
                    Master template ‚≠ê‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window
                    Maximum</a> (239) - With
                    deque</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">Substring with
                    Concatenation of All Words</a> (30) - Complex fixed window</li>
                    </ol>
                    <hr />
                    <h1 id="phase-2-searching-basic-data-structures">PHASE 2: SEARCHING &amp; BASIC DATA STRUCTURES üîç</h1>
                    <h2 id="4-binary-search">4. BINARY SEARCH üéØ</h2>
                    <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Builds on:</strong> Arrays, Two
                        Pointers</p>
                    <h3 id="core-concept_3">Core Concept</h3>
                    <p>Halve search space on monotonic functions by eliminating impossible halves. Reduces O(n) to O(log n).</p>
                    <h3 id="when-to-use_3">When to Use</h3>
        <ul>
            <li>‚úÖ <strong>Sorted arrays</strong> (ascending/descending)</li>
            <li>‚úÖ Finding boundaries/first/last occurrence</li>
            <li>‚úÖ Search in rotated arrays</li>
            <li>‚úÖ Minimize/maximize answer (answer binary search)</li>
            <li>‚úÖ Implicit sorted search space</li>
            <li><strong>Signal Words:</strong> "sorted", "find position", "minimize maximum", "maximize minimum"</li>
        </ul>
        <h3 id="sub-patterns_3">Sub-Patterns</h3>
        <h4 id="41-standard-binary-search-exact-match">4.1 Standard Binary Search (Exact Match)</h4>
        <p><strong>Use Case:</strong> Find exact target in sorted array</p>
        <pre><code class="language-python">def binary_search(nums, target):
            &quot;&quot;&quot;
            TEMPLATE 1: Find exact value
            - Use when target MUST exist or return -1
            - Loop condition: left &lt;= right (can check single element)
            - Return: mid when found, -1 if not found
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt;= right:
                mid = left + (right - left) // 2  # Avoid overflow in other languages

                if nums[mid] == target:
                    return mid
                elif nums[mid] &lt; target:
                    left = mid + 1  # Search right half
                else:
                    right = mid - 1  # Search left half

            return -1  # Not found
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <p><strong>Key Points:</strong><br />
            - <code>left &lt;= right</code> allows checking single element<br />
            - Move left/right by <code>mid ¬±1</code> to avoid infinite loop<br />
            - Result is at <code>mid</code> or not found</p>
        <h4 id="42-lower-bound-first-target">4.2 Lower Bound (First &gt;= Target)</h4>
        <p><strong>Use Case:</strong> Find first position where value &gt;= target, insertion point</p>
        <pre><code class="language-python">def lower_bound(nums, target):
            &quot;&quot;&quot;
            TEMPLATE 2: Find leftmost position &gt;= target
            - Use for: insertion index, first occurrence
            - Loop condition: left &lt; right (stops when left == right)
            - Return: left (insertion point, may be len(nums))
            &quot;&quot;&quot;
            left, right = 0, len(nums)  # Note: right = len(nums), not len(nums)-1

            while left &lt; right:
                mid = left + (right - left) // 2

                if nums[mid] &lt; target:
                    left = mid + 1  # Answer is to the right
                else:
                    right = mid  # nums[mid] &gt;= target, could be answer, keep it

            return left  # First position where nums[left] &gt;= target

        def search_insert_position(nums, target):
            &quot;&quot;&quot;
            LeetCode 35: Find index to insert target
            Same as lower_bound
            &quot;&quot;&quot;
            return lower_bound(nums, target)

        def first_occurrence(nums, target):
            &quot;&quot;&quot;
            Find first occurrence of target
            &quot;&quot;&quot;
            idx = lower_bound(nums, target)
            if idx &lt; len(nums) and nums[idx] == target:
                return idx
            return -1
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <h4 id="43-upper-bound-first-target">4.3 Upper Bound (First &gt; Target)</h4>
        <p><strong>Use Case:</strong> Find first position where value &gt; target</p>
        <pre><code class="language-python">def upper_bound(nums, target):
            &quot;&quot;&quot;
            TEMPLATE 3: Find leftmost position &gt; target
            - Use for: last occurrence, count of elements
            - Return: left (first position &gt; target)
            &quot;&quot;&quot;
            left, right = 0, len(nums)

    while left &lt; right:
    mid = left + (right - left) // 2

    if nums[mid] &lt;= target: # Note: &lt;= instead of
    left = mid + 1
    else:
    right = mid

    return left

    def last_occurrence(nums, target):
    &quot;&quot;&quot;
    Find last occurrence of target
    &quot;&quot;&quot;
    idx = upper_bound(nums, target) - 1
    if idx &gt;= 0 and nums[idx] == target:
    return idx
    return -1

    def count_occurrences(nums, target):
    &quot;&quot;&quot;
    Count how many times target appears
    &quot;&quot;&quot;
    first = lower_bound(nums, target)
    last = upper_bound(nums, target)
    return last - first # Will be 0 if target not present
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <h4 id="44-binary-search-on-answer">4.4 Binary Search on Answer</h4>
        <p><strong>Use Case:</strong> Minimize maximum, maximize minimum - search space is implicit</p>
        <pre><code class="language-python">def koko_eating_bananas(piles, h):
            &quot;&quot;&quot;
            Find minimum eating speed K such that:
            - Can finish all piles in H hours
            - Search space: [1, max(piles)]

            KEY INSIGHT: If speed K works, then K+1, K+2... also work
            This creates monotonicity for binary search
            &quot;&quot;&quot;
            def can_finish(speed):
                &quot;&quot;&quot;Helper: Can we finish with this speed?&quot;&quot;&quot;
                hours = 0
                for pile in piles:
                    hours += (pile + speed - 1) // speed  # Ceiling division
                return hours &lt;= h

            left, right = 1, max(piles)
            result = right

            while left &lt;= right:
                mid = left + (right - left) // 2

                if can_finish(mid):
                    result = mid  # Valid, try smaller
                    right = mid - 1
                else:
                    left = mid + 1  # Too slow, need faster

            return result

        def split_array_largest_sum(nums, m):
            &quot;&quot;&quot;
            Minimize the largest sum among m subarrays
            Search space: [max(nums), sum(nums)]
            &quot;&quot;&quot;
            def can_split(max_sum):
                &quot;&quot;&quot;Can we split into m subarrays with each sum &lt;= max_sum?&quot;&quot;&quot;
                subarrays = 1
                current_sum = 0
                for num in nums:
                    if current_sum + num &gt; max_sum:
                        subarrays += 1
                        current_sum = num
                        if subarrays &gt; m:
                            return False
                    else:
                        current_sum += num
                return True

            left, right = max(nums), sum(nums)

            while left &lt; right:
                mid = left + (right - left) // 2
                if can_split(mid):
                    right = mid  # Can do it, try smaller max_sum
                else:
                    left = mid + 1  # Can't do it, need larger max_sum

            return left
        </code></pre>
        <p><strong>Time:</strong> O(n log(max-min)) | <strong>Space:</strong> O(1)</p>
        <p><strong>Answer Binary Search Pattern:</strong><br />
            1. Identify search space [min, max]<br />
            2. Define check function: is value X feasible?<br />
            3. Determine monotonicity (if X works, does X+1/X-1 work?)<br />
            4. Apply binary search to find boundary</p>
        <h4 id="45-rotated-array-search">4.5 Rotated Array Search</h4>
        <p><strong>Use Case:</strong> Search in rotated sorted array</p>
        <pre><code class="language-python">def search_rotated(nums, target):
            &quot;&quot;&quot;
            Key insight: One half is always sorted
            - Determine which half is sorted- Check if target in sorted half
            - If yes, search sorted half; else search other half
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt;= right:
                mid = left + (right - left) // 2

                if nums[mid] == target:
                    return mid

                # Determine which half is sorted
                if nums[left] &lt;= nums[mid]:  # Left half is sorted
                    # Check if target in sorted left half
                    if nums[left] &lt;= target &lt; nums[mid]:
                        right = mid - 1
                    else:
                        left = mid + 1
                else:  # Right half is sorted
                    # Check if target in sorted right half
                    if nums[mid] &lt; target &lt;= nums[right]:
                        left = mid + 1
                    else:
                        right = mid - 1

            return -1

        def find_minimum_rotated(nums):
            &quot;&quot;&quot;
            Find minimum in rotated sorted array
            Key: minimum is in unsorted half
            &quot;&quot;&quot;
            left, right = 0, len(nums) - 1

            while left &lt; right:
                mid = left + (right - left) // 2

                if nums[mid] &gt; nums[right]:
                    # Minimum is in right half
                    left = mid + 1
                else:
                    # Minimum is in left half (could be mid)
                    right = mid

            return nums[left]
</code></pre>
        <p><strong>Time:</strong> O(log n) | <strong>Space:</strong> O(1)</p>
        <h3 id="common-traps_3">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Loop Condition Confusion</strong>:
                <ul>
                    <li><code>left &lt;= right</code>: Use when returning mid or -1 (exact search)</li>
                    <li><code>left &lt; right</code>: Use when returning left/right (bound search)</li>
                </ul>
            </li>
            <li>‚ùå <strong>Infinite Loop</strong>: Always use <code>mid + 1</code> or <code>mid - 1</code>, never just
                <code>mid</code>
            </li>
            <li>‚ùå <strong>Overflow</strong>: Use <code>mid = left + (right - left) // 2</code> not
                <code>(left + right) // 2</code>
            </li>
            <li>‚ùå <strong>Off-by-One</strong>:
                <ul>
                    <li>Exact search: <code>right = len(nums) - 1</code>, loop <code>left &lt;= right</code></li>
                    <li>Bound search: <code>right = len(nums)</code>, loop <code>left &lt; right</code></li>
                </ul>
            </li>
            <li>‚ùå <strong>Duplicate Elements</strong>: Standard binary search may not work with duplicates</li>
            </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre><code>What are you looking for?
        ‚îú‚îÄ Exact value (exists or -1)
        ‚îÇ   ‚îî‚îÄ Template 1: left &lt;= right, return mid or -1
        ‚îú‚îÄ First position &gt;= target (insertion point)
        ‚îÇ   ‚îî‚îÄ Template 2: left &lt; right, right = mid, return left
        ‚îú‚îÄ First position &gt; target
        ‚îÇ   ‚îî‚îÄ Template 3: left &lt; right, nums[mid] &lt;= target, return left
        ‚îú‚îÄ Minimize/maximize something
        ‚îÇ   ‚îî‚îÄ Template 4: Binary search on answer with feasibility function
        ‚îî‚îÄ Rotated array
            ‚îî‚îÄ Template 5: Identify sorted half, adjust search
</code></pre>
<h3 id="must-know-problems_3">Must-Know Problems</h3>
<h4 id="easy_2">Easy</h4>
<ol>
    <li><a target="_blank" href="https://leetcode.com/problems/binary-search/">Binary Search</a> (704) -
        Template 1 ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/search-insert-position/">Search Insert
                    Position</a> (35) -
                    Template 2 ‚≠ê</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/sqrtx/">Sqrt(x)</a> (69) - Answer binary search
            </li>
        </ol>
        <h4 id="medium_2">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Search in
                    Rotated Sorted
                    Array</a> (33) - Template 5 ‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find
                    Minimum in Rotated
                    Sorted Array</a> (153) - Rotated variant</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find
                    First and Last Position of Element</a> (34) - Lower/upper bound ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/koko-eating-bananas/">Koko Eating Bananas</a>
                (875) - Answer
                binary search ‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/find-peak-element/">Find Peak Element</a> (162) -
                    Mountain array
                </li>
                <li><a target="_blank" href="https://leetcode.com/problems/search-a-2d-matrix/">Search a 2D Matrix</a> (74)
                    - 2D binary
                    search</li>
            <li><a target="_blank" href="https://leetcode.com/problems/time-based-key-value-store/">Time Based Key-Value
                    Store</a> (981)
                - Lower bound application</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">Capacity To Ship
                    Packages Within D Days</a> (1011) - Answer Binary Search</li>
            <li><a target="_blank" href="https://leetcode.com/problems/snapshot-array/">Snapshot Array</a> (1146) -
                Design + Binary Search</li>
        </ol>
        <h4 id="hard_1">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/median-of-two-sorted-arrays/">Median of Two
                    Sorted Arrays</a> (4)
                - Advanced ‚≠ê‚≠ê‚≠ê</li>
                </ol>
                <hr />
                <h2 id="5-stack">5. STACK üìö</h2>
                <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Foundation Pattern</strong></p>
                <h3 id="core-concept_4">Core Concept</h3>
                <p>LIFO (Last In First Out) structure that simulates recursion, tracks recent elements for
                    matching/monotonicity. Think: "Do I need to remember recent items and process them in reverse?"</p>
                <h3 id="when-to-use_4">When to Use</h3>
                <ul>
                    <li>‚úÖ Matching pairs (parentheses, brackets)</li>
                    <li>‚úÖ Monotonic problems (next greater/smaller)</li>
                    <li>‚úÖ Expression evaluation (postfix, infix)</li>
                    <li>‚úÖ Undo operations, browser history</li>
                    <li>‚úÖ Depth-first traversal simulation</li>
                    <li><strong>Signal Words:</strong> "valid", "matching", "next greater", "nearest", "evaluate expression"
            </li>
        </ul>
        <h3 id="sub-patterns_4">Sub-Patterns</h3>
        <h4 id="51-matchingvalidation-pattern">5.1 Matching/Validation Pattern</h4>
        <p><strong>Use Case:</strong> Valid parentheses, balanced brackets</p>
        <pre><code class="language-python">def is_valid_parentheses(s):
            &quot;&quot;&quot;
            MATCHING TEMPLATE:
            1. Push opening brackets
            2. For closing bracket, check stack top matches
            3. Stack should be empty at end
            &quot;&quot;&quot;
            stack = []
            matching = {')': '(', '}': '{', ']': '['}

            for char in s:
                if char in matching:  # Closing bracket
                    if not stack or stack.pop() != matching[char]:
                        return False
                else:  # Opening bracket
                    stack.append(char)

            return not stack  # Valid if empty

        def remove_outer_parentheses(s):
            &quot;&quot;&quot;
            Remove outer parentheses from each primitive
            Track depth with counter (stack size simulation)
            &quot;&quot;&quot;
            result = []
            depth = 0

            for char in s:
                if char == '(':
                    if depth &gt; 0:  # Not outer
                        result.append(char)
                    depth += 1
                else:  # ')'
                    depth -= 1
                    if depth &gt; 0:  # Not outer
                        result.append(char)

            return ''.join(result)
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="52-monotonic-stack-next-greatersmaller">5.2 Monotonic Stack (Next Greater/Smaller)</h4>
        <p><strong>Use Case:</strong> Next greater element, next warmer temperature, stock span</p>
        <pre><code class="language-python">def next_greater_elements(nums):
            &quot;&quot;&quot;
            MONOTONIC DECREASING STACK TEMPLATE:
            - Maintains decreasing order
            - When encounter larger element, pop all smaller
            - Iterate right-to-left for &quot;next greater to right&quot;

            Key insight: If element A is greater than B,
            B can never be &quot;next greater&quot; for future elements
            &quot;&quot;&quot;
            n = len(nums)
            result = [-1] * n
            stack = []  # Stores indices

            # Iterate from right to left
            for i in range(n - 1, -1, -1):
                # Pop all elements smaller than current
                while stack and nums[stack[-1]] &lt;= nums[i]:
                    stack.pop()

                # Stack top is next greater (if exists)
                if stack:
                    result[i] = nums[stack[-1]]

                stack.append(i)

            return result

        def next_smaller_element(nums):
            &quot;&quot;&quot;
            MONOTONIC INCREASING STACK:
            - For next smaller, maintain increasing order
            - Pop elements &gt;= current
            &quot;&quot;&quot;
            n = len(nums)
            result = [-1] * n
            stack = []

            for i in range(n - 1, -1, -1):
                while stack and nums[stack[-1]] &gt;= nums[i]:
                    stack.pop()

                if stack:
                    result[i] = nums[stack[-1]]

                stack.append(i)

            return result

        def daily_temperatures(temperatures):
            &quot;&quot;&quot;
            How many days until warmer temperature?
            Same as next greater, but return index difference
            &quot;&quot;&quot;
            n = len(temperatures)
            result = [0] * n
            stack = []

            for i in range(n):
                # Pop all days with cooler temperature
                while stack and temperatures[stack[-1]] &lt; temperatures[i]:
                    prev_day = stack.pop()
                    result[prev_day] = i - prev_day

                stack.append(i)

            return result
        </code></pre>
        <p><strong>Time:</strong> O(n) - each element pushed/popped once | <strong>Space:</strong> O(n)</p>
        <p><strong>Monotonic Stack Rules:</strong><br />
            - <strong>Next Greater</strong>: Use decreasing stack, iterate right-to-left<br />
            - <strong>Next Smaller</strong>: Use increasing stack, iterate right-to-left<br />
            - <strong>Previous Greater</strong>: Use decreasing stack, iterate left-to-right<br />
            - <strong>Previous Smaller</strong>: Use increasing stack, iterate left-to-right</p>
        <h4 id="53-expression-evaluation">5.3 Expression Evaluation</h4>
        <p><strong>Use Case:</strong> Calculator, postfix notation, operator precedence</p>
        <pre><code class="language-python">def eval_reverse_polish(tokens):
            &quot;&quot;&quot;
            Postfix (RPN) evaluation
            Operands go on stack, operators pop and compute
            &quot;&quot;&quot;
            stack = []
            operators = {'+', '-', '*', '/'}

            for token in tokens:
                if token in operators:
                    b = stack.pop()
                    a = stack.pop()

                    if token == '+':
                        stack.append(a + b)
                    elif token == '-':
                        stack.append(a - b)
                    elif token == '*':
                        stack.append(a * b)
                    else:  # '/'
                        stack.append(int(a / b))  # Truncate toward zero
                else:
                    stack.append(int(token))

            return stack[0]

        def basic_calculator(s):
            &quot;&quot;&quot;
            Infix with +, -, parentheses
            Use stack for parentheses, track sign
            &quot;&quot;&quot;
            stack = []
            result = 0
            sign = 1
            num = 0

            for char in s:
                if char.isdigit():
                    num = num * 10 + int(char)
                elif char in '+-':
                    result += sign * num
                    num = 0
                    sign = 1 if char == '+' else -1
                elif char == '(':
                    # Push current result and sign onto stack
                    stack.append(result)
                    stack.append(sign)
                    result = 0
                    sign = 1
                elif char == ')':
                    result += sign * num
                    num = 0
                    result *= stack.pop()  # Pop sign
                    result += stack.pop()  # Pop result before '('

            return result + sign * num
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="54-histogramrectangle-pattern">5.4 Histogram/Rectangle Pattern</h4>
        <p><strong>Use Case:</strong> Largest rectangle in histogram, maximal rectangle</p>
        <pre><code class="language-python">def largest_rectangle_histogram(heights):
            &quot;&quot;&quot;
            KEY INSIGHT: For each bar, find left and right boundaries
            where heights are &gt;= current bar's height
            Area = height[i] * (right - left - 1)

            Use monotonic increasing stack
            &quot;&quot;&quot;
            stack = []  # Stores indices
            max_area = 0
            heights.append(0)  # Sentinel to flush stack

            for i in range(len(heights)):
                # While current bar is shorter, calculate area for stack top
                while stack and heights[stack[-1]] &gt; heights[i]:
                    h_idx = stack.pop()
                    height = heights[h_idx]
                    # Width = current index - left boundary - 1
                    width = i if not stack else i - stack[-1] - 1
                    max_area = max(max_area, height * width)

                stack.append(i)

            return max_area

        def trap_rain_water(height):
            &quot;&quot;&quot;
            Can also use stack approach (besides two-pointer)
            Store indices of bars in decreasing order
            &quot;&quot;&quot;
            stack = []
            water = 0

            for i in range(len(height)):
                while stack and height[i] &gt; height[stack[-1]]:
                    bottom = stack.pop()

                    if not stack:
                        break

                    # Water trapped between stack[-1] and i
                    width = i - stack[-1] - 1
                    bounded_height = min(height[i], height[stack[-1]]) - height[bottom]
                    water += width * bounded_height

                stack.append(i)

            return water
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="55-min-stack-max-stack">5.5 Min Stack / Max Stack</h4>
        <p><strong>Use Case:</strong> Stack with O(1) min/max retrieval</p>
        <pre><code class="language-python">class MinStack:
            &quot;&quot;&quot;
            APPROACH 1: Two stacks
            - Main stack stores all values
            - Min stack stores minimums at each level
            &quot;&quot;&quot;
            def __init__(self):
                self.stack = []
                self.min_stack = []

            def push(self, val):
                self.stack.append(val)
                # Push current minimum
                min_val = min(val, self.min_stack[-1] if self.min_stack else val)
                self.min_stack.append(min_val)

            def pop(self):
                self.stack.pop()
                self.min_stack.pop()

            def top(self):
                return self.stack[-1]

            def get_min(self):
                return self.min_stack[-1]

        class MinStackOptimized:
            &quot;&quot;&quot;
            APPROACH 2: Single stack with tuples
            Store (value, current_min) pairs
            &quot;&quot;&quot;
            def __init__(self):
                self.stack = []

            def push(self, val):
                if not self.stack:
                    self.stack.append((val, val))
                else:
                    current_min = min(val, self.stack[-1][1])
                    self.stack.append((val, current_min))

            def pop(self):
                self.stack.pop()

            def top(self):
                return self.stack[-1][0]

            def get_min(self):
                return self.stack[-1][1]
</code></pre>
        <p><strong>Time:</strong> O(1) all operations | <strong>Space:</strong> O(n)</p>
        <h3 id="common-traps_4">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Empty Stack Pop</strong>: Always check <code>if stack:</code> before <code>stack.pop()</code></li>
            <li>‚ùå <strong>LIFO Confusion</strong>: Remember it's Last In First Out, not FIFO (queue)</li>
            <li>‚ùå <strong>Monotonic Direction</strong>:
                <ul>
                    <li>Decreasing stack for "next greater"</li>
                    <li>Increasing stack for "next smaller"</li>
                </ul>
            </li>
            <li>‚ùå <strong>Index vs Value</strong>: For monotonic stack, often better to store indices</li>
            <li>‚ùå <strong>Sentinel Values</strong>: Add sentinel (0 for histogram) to flush remaining elements</li>
            <li>‚ùå <strong>Iterator Direction</strong>: Right-to-left for "next", left-to-right for "previous"</li>
        </ul>
        <h3 id="decision-tree_1">Decision Tree</h3>
        <pre><code>Need to track recent elements?
        ‚îú‚îÄ Matching brackets/tags?
        ‚îÇ   ‚îî‚îÄ Use validation pattern (5.1)
        ‚îú‚îÄ Find next/previous greater/smaller?
        ‚îÇ   ‚îî‚îÄ Use monotonic stack (5.2)
        ‚îú‚îÄ Evaluate expression?
        ‚îÇ   ‚îî‚îÄ Use evaluation pattern (5.3)
        ‚îú‚îÄ Rectangle/histogram problem?
        ‚îÇ   ‚îî‚îÄ Use histogram pattern (5.4)
        ‚îî‚îÄ Need O(1) min/max access?
            ‚îî‚îÄ Use specialized stack (5.5)
</code></pre>
<h3 id="must-know-problems_4">Must-Know Problems</h3>
<h4 id="easy_3">Easy</h4>
<ol>
    <li><a target="_blank" href="https://leetcode.com/problems/valid-parentheses/">Valid Parentheses</a> (20) -
        Matching
        template ‚≠ê‚≠ê</li>
</ol>
<h4 id="medium_3">Medium</h4>
<ol>
    <li><a target="_blank" href="https://leetcode.com/problems/min-stack/">Min Stack</a> (155) - Specialized
        stack ‚≠ê</li>
    <li><a target="_blank" href="https://leetcode.com/problems/daily-temperatures/">Daily Temperatures</a> (739)
        - Monotonic
        stack ‚≠ê‚≠ê</li>
    <li><a target="_blank" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">Evaluate
            Reverse Polish
            Notation</a> (150) - Expression eval</li>
    <li><a target="_blank" href="https://leetcode.com/problems/generate-parentheses/">Generate Parentheses</a>
        (22) - Backtrack
        + validation</li>
    <li><a target="_blank" href="https://leetcode.com/problems/car-fleet/">Car Fleet</a> (853) - Monotonic stack
        application
    </li>
    <li><a target="_blank" href="https://leetcode.com/problems/simplify-path/">Simplify Path</a> (71) - Stack
        for path
        processing</li>
    <li><a target="_blank" href="https://leetcode.com/problems/decode-string/">Decode String</a> (394) - Nested
        structures</li>
    <li><a target="_blank" href="https://leetcode.com/problems/basic-calculator-ii/">Basic Calculator II</a>
        (227) - String Parsing</li>
    <li><a target="_blank" href="https://leetcode.com/problems/asteroid-collision/">Asteroid Collision</a> (735)
        - Collision State</li>
    <li><a target="_blank" href="https://leetcode.com/problems/remove-k-digits/">Remove K Digits</a> (402) -
        Monotonic Greedy</li>
</ol>
<h4 id="hard_2">Hard</h4>
<ol>
    <li><a target="_blank" href="https://leetcode.com/problems/largest-rectangle-in-histogram/">Largest
            Rectangle in
            Histogram</a> (84) - Histogram pattern ‚≠ê‚≠ê‚≠ê</li>
    <li><a target="_blank" href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water</a>
        (42) - Advanced
        monotonic</li>
    <li><a target="_blank" href="https://leetcode.com/problems/basic-calculator/">Basic Calculator</a> (224) -
        Expression with
        parentheses ‚≠ê‚≠ê</li>
    <li><a target="_blank" href="https://leetcode.com/problems/text-justification/">Text Justification</a> (68)
        - Greedy String Handling</li>
</ol>
<hr />
<h2 id="6-linked-list">6. LINKED LIST üîó</h2>
<p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Builds on:</strong> Two
    Pointers</p>
<h3 id="core-concept_5">Core Concept</h3>
<p>Sequential data structure where each node points to next (and optionally previous). Use pointers for O(1)
    insertions/deletions, but O(n) access. Think: "Can I do this in-place without extra space?"</p>
<h3 id="when-to-use_5">When to Use</h3>
        <ul>
            <li>‚úÖ In-place reversals/reordering</li>
            <li>‚úÖ Cycle detection</li>
            <li>‚úÖ Merge sorted lists</li>
            <li>‚úÖ Remove/modify nodes without extra space</li>
            <li>‚úÖ LRU cache (doubly linked list + hash)</li>
            <li><strong>Signal Words:</strong> "linked list", "in-place", "cycle", "reverse", "merge"</li>
        </ul>
        <h3 id="sub-patterns_5">Sub-Patterns</h3>
        <h4 id="61-two-pointer-techniques">6.1 Two Pointer Techniques</h4>
        <h5 id="fast-slow-floyds-cycle-detection">Fast-Slow (Floyd's Cycle Detection)</h5>
        <p><strong>Use Case:</strong> Find middle, detect cycles, find cycle start</p>
        <pre><code class="language-python">class ListNode:
            def __init__(self, val=0, next=None):
                self.val = val
                self.next = next

        def has_cycle(head):
            &quot;&quot;&quot;
            FLOYD'S ALGORITHM:
            - Slow moves 1 step, fast moves 2 steps
            - If cycle exists, they'll meet
            - If no cycle, fast reaches None
            &quot;&quot;&quot;
            if not head:
                return False

            slow = fast = head

            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next

                if slow == fast:
                    return True

            return False

        def detect_cycle_start(head):
            &quot;&quot;&quot;
            Find where cycle starts:
            1. Detect cycle with fast-slow
            2. Reset slow to head
            3. Move both at same speed until they meet
            &quot;&quot;&quot;
            if not head:
                return None

            slow = fast = head

            # Phase 1: Detect cycle
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow == fast:
                    break
            else:
                return None  # No cycle

            # Phase 2: Find start
            slow = head
            while slow != fast:
                slow = slow.next
                fast = fast.next

            return slow

        def find_middle(head):
            &quot;&quot;&quot;
            Find middle node (for palindrome check, merge sort)
            When fast reaches end, slow is at middle
            &quot;&quot;&quot;
            slow = fast = head

            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next

            return slow
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h5 id="remove-nth-from-end">Remove Nth from End</h5>
        <p><strong>Use Case:</strong> Two-pass becomes one-pass with gap technique</p>
        <pre><code class="language-python">def remove_nth_from_end(head, n):
            &quot;&quot;&quot;
            TECHNIQUE: Maintain n-node gap between fast and slow
            When fast reaches end, slow is at (n+1)th from end

            Use dummy node to handle edge cases (removing head)
            &quot;&quot;&quot;
            dummy = ListNode(0, head)
            slow = fast = dummy

            # Move fast n+1 steps ahead
            for _ in range(n + 1):
                fast = fast.next

            # Move both until fast reaches end
            while fast:
                slow = slow.next
                fast = fast.next

            # Remove nth node
            slow.next = slow.next.next

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="62-reversal-patterns">6.2 Reversal Patterns</h4>
        <h5 id="basic-reversal">Basic Reversal</h5>
        <p><strong>Use Case:</strong> Reverse entire list or sublist</p>
        <pre><code class="language-python">def reverse_list(head):
            &quot;&quot;&quot;
            ITERATIVE REVERSAL:
            - Track prev, curr, next
            - Reverse links one by one
            - Return prev (new head)
            &quot;&quot;&quot;
            prev = None
            curr = head

            while curr:
                next_temp = curr.next  # Save next BEFORE reversing
                curr.next = prev       # Reverse the link
                prev = curr            # Move prev forward
                curr = next_temp       # Move curr forward

            return prev  # New head

        def reverse_between(head, left, right):
            &quot;&quot;&quot;
            Reverse nodes from position left to right
            KEY: Need to track connection points
            &quot;&quot;&quot;
            if not head or left == right:
                return head

            dummy = ListNode(0, head)
            prev_left = dummy

            # Move to node before left
            for _ in range(left - 1):
                prev_left = prev_left.next

            # Reverse from left to right
            prev = None
            curr = prev_left.next
            for _ in range(right - left + 1):
                next_temp = curr.next
                curr.next = prev
                prev = curr
                curr = next_temp

            # Reconnect
            prev_left.next.next = curr  # Connect end of reversed to rest
            prev_left.next = prev       # Connect start to reversed part

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h5 id="reversal-in-k-groups">Reversal in K-Groups</h5>
        <p><strong>Use Case:</strong> Reverse every K nodes</p>
        <pre><code class="language-python">def reverse_k_group(head, k):
            &quot;&quot;&quot;
            HARD PATTERN:
            1. Check if k nodes remaining
            2. Reverse k nodes
            3. Recursively handle rest
            4. Connect parts
            &quot;&quot;&quot;
            # Check if k nodes exist
            curr = head
            for _ in range(k):
                if not curr:
                    return head  # Less than k nodes, return as is
                curr = curr.next

            # Reverse first k nodes
            prev = None
            curr = head
            for _ in range(k):
                next_temp = curr.next
                curr.next = prev
                prev = curr
                curr = next_temp

            # Recursively reverse rest and connect
            head.next = reverse_k_group(curr, k)

            return prev  # New head of this group
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n/k) for recursion</p>
        <h4 id="63-merge-pattern">6.3 Merge Pattern</h4>
        <p><strong>Use Case:</strong> Merge sorted lists, merge k lists</p>
        <pre><code class="language-python">def merge_two_lists(l1, l2):
            &quot;&quot;&quot;
            MERGE TEMPLATE:
            - Use dummy node to simplify edge cases
            - Compare and append smaller
            - Attach remaining
            &quot;&quot;&quot;
            dummy = ListNode(0)
            curr = dummy

            while l1 and l2:
                if l1.val &lt;= l2.val:
                    curr.next = l1
                    l1 = l1.next
                else:
                    curr.next = l2
                    l2 = l2.next
                curr = curr.next

            # Attach remaining
            curr.next = l1 if l1 else l2

            return dummy.next

        def merge_k_lists(lists):
            &quot;&quot;&quot;
            DIVIDE &amp; CONQUER:
            - Merge pairs of lists
            - Repeat until one list remains
            Time: O(N log k) where N = total nodes, k = number of lists
            &quot;&quot;&quot;
            if not lists:
                return None

            while len(lists) &gt; 1:
                merged = []
                for i in range(0, len(lists), 2):
                    l1 = lists[i]
                    l2 = lists[i + 1] if i + 1 &lt; len(lists) else None
                    merged.append(merge_two_lists(l1, l2))
                lists = merged

            return lists[0]

        # Alternative: Heap-based O(N log k)
        import heapq

        def merge_k_lists_heap(lists):
            &quot;&quot;&quot;Use min-heap to always merge smallest&quot;&quot;&quot;
            heap = []

            # Initialize heap with first node of each list
            for i, node in enumerate(lists):
                if node:
                    heapq.heappush(heap, (node.val, i, node))

            dummy = ListNode(0)
            curr = dummy

            while heap:
                val, i, node = heapq.heappop(heap)
                curr.next = node
                curr = curr.next

                if node.next:
                    heapq.heappush(heap, (node.next.val, i, node.next))

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(N log k) | <strong>Space:</strong> O(k) for heap</p>
        <h4 id="64-reorder-pattern">6.4 Reorder Pattern</h4>
        <p><strong>Use Case:</strong> Rearrange nodes in specific patterns</p>
        <pre><code class="language-python">def reorder_list(head):
            &quot;&quot;&quot;
            Reorder L0‚ÜíL1‚Üí...‚ÜíLn-1‚ÜíLn to L0‚ÜíLn‚ÜíL1‚ÜíLn-1‚Üí...

            STEPS:
            1. Find middle (fast-slow)
            2. Reverse second half
            3. Merge two halves alternately
            &quot;&quot;&quot;
            if not head or not head.next:
                return

            # Step 1: Find middle
            slow = fast = head
            while fast.next and fast.next.next:
                slow = slow.next
                fast = fast.next.next

            # Step 2: Reverse second half
            second = slow.next
            slow.next = None  # Split into two lists

            prev = None
            while second:
                next_temp = second.next
                second.next = prev
                prev = second
                second = next_temp
            second = prev  # Head of reversed second half

            # Step 3: Merge alternately
            first = head
            while second:
                temp1, temp2 = first.next, second.next
                first.next = second
                second.next = temp1
                first, second = temp1, temp2

        def rotate_right(head, k):
            &quot;&quot;&quot;
            Rotate list to right by k places
            Example: 1‚Üí2‚Üí3‚Üí4‚Üí5, k=2  ‚Üí  4‚Üí5‚Üí1‚Üí2‚Üí3

            TECHNIQUE:
            1. Make it circular
            2. Find new tail (length - k % length - 1)
            3. Break circle
            &quot;&quot;&quot;
            if not head or not head.next or k == 0:
                return head

            # Find length and connect tail to head
            length = 1
            curr = head
            while curr.next:
                curr = curr.next
                length += 1
            curr.next = head  # Make circular

            # Find new tail position
            k = k % length
            steps_to_new_tail = length - k - 1

            new_tail = head
            for _ in range(steps_to_new_tail):
                new_tail = new_tail.next

            new_head = new_tail.next
            new_tail.next = None

            return new_head
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(1)</p>
        <h4 id="65-deep-copy-pattern">6.5 Deep Copy Pattern</h4>
        <p><strong>Use Case:</strong> Clone list with random pointers</p>
        <pre><code class="language-python">def copy_random_list(head):
            &quot;&quot;&quot;
            Clone list where each node has next and random pointer

            APPROACH 1: Hash map
            Pass 1: Create all nodes and store in map
            Pass 2: Set next and random pointers
            &quot;&quot;&quot;
            if not head:
                return None

            # Map old nodes to new nodes
            old_to_new = {}

            # First pass: Create all nodes
            curr = head
            while curr:
                old_to_new[curr] = ListNode(curr.val)
                curr = curr.next

            # Second pass: Set pointers
            curr = head
            while curr:
                if curr.next:
                    old_to_new[curr].next = old_to_new[curr.next]
                if curr.random:
                    old_to_new[curr].random = old_to_new[curr.random]
                curr = curr.next

            return old_to_new[head]

        def copy_random_list_optimal(head):
            &quot;&quot;&quot;
            APPROACH 2: Interweave nodes (no extra space)

            Step 1: Create copy nodes interweaved
            A‚ÜíB‚ÜíC  becomes  A‚ÜíA'‚ÜíB‚ÜíB'‚ÜíC‚ÜíC'

            Step 2: Set random pointers
            A'.random = A.random.next

            Step 3: Separate lists
            &quot;&quot;&quot;
            if not head:
                return None

            # Step 1: Interweave
            curr = head
            while curr:
                copy = ListNode(curr.val)
                copy.next = curr.next
                curr.next = copy
                curr = copy.next

            # Step 2: Set random pointers
            curr = head
            while curr:
                if curr.random:
                    curr.next.random = curr.random.next
                curr = curr.next.next

            # Step 3: Separate
            dummy = ListNode(0)
            copy_curr = dummy
            curr = head
            while curr:
                copy_curr.next = curr.next
                copy_curr = copy_curr.next
                curr.next = curr.next.next
                curr = curr.next

            return dummy.next
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n) for map, O(1) for optimal</p>
        <h3 id="common-traps_5">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Losing References</strong>: Always save <code>next</code> before modifying pointers
                <pre><code class="language-python"># WRONG
                                                        curr.next = prev
                                                        curr = curr.next # Lost reference!

                                                        # RIGHT
                                                        next_temp = curr.next
                                                        curr.next = prev
                                                        curr = next_temp</code></pre>
            </li>
            <li>‚ùå <strong>Dummy Node</strong>: Use for edge cases (empty list, removing head)
                <pre><code class="language-python">dummy = ListNode(0, head)
                # Work with dummy.next
return dummy.next</code></pre>
</li>
<li>‚ùå <strong>Null Checks</strong>: Always check <code>if node:</code> and <code>if node.next:</code></li>
<li>‚ùå <strong>Cycle Bugs</strong>: In cycle detection, check <code>fast and fast.next</code> before accessing
    <code>fast.next.next</code>
</li>
<li>‚ùå <strong>Off-by-One</strong>: For "remove nth from end", move fast <code>n+1</code> steps</li>
</ul>
        <h3 id="pattern-recognition-guide">Pattern Recognition Guide</h3>
        <pre><code>Linked list problem?
        ‚îú‚îÄ Need middle/detect cycle?
        ‚îÇ   ‚îî‚îÄ Fast-slow pointers (6.1)
        ‚îú‚îÄ Reverse list/sublist?
        ‚îÇ   ‚îî‚îÄ Reversal pattern (6.2)
        ‚îú‚îÄ Merge lists?
        ‚îÇ   ‚îî‚îÄ Merge pattern (6.3)
        ‚îú‚îÄ Rearrange/reorder?
        ‚îÇ   ‚îî‚îÄ Reorder pattern (6.4)
        ‚îî‚îÄ Clone with complex pointers?
            ‚îî‚îÄ Deep copy pattern (6.5)
        </code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Traversal?
        ‚îÇ ‚îú‚îÄ Cycle/Middle? ‚Üí Fast/Slow Pointers
        ‚îÇ ‚îî‚îÄ Intersection? ‚Üí Difference in length
        ‚îú‚îÄ Reversal?
        ‚îÇ ‚îú‚îÄ Full? ‚Üí Iterative (3 pointers)
        ‚îÇ ‚îî‚îÄ Partial (k-groups)? ‚Üí Stack or Recursive
        ‚îú‚îÄ Merging?
        ‚îÇ ‚îî‚îÄ Sorted? ‚Üí Merge patterns (Dummy node)
        ‚îî‚îÄ Deep Copy? ‚Üí Hash Map (Old -> New)
        </pre>
        <h3 id="must-know-problems_5">Must-Know Problems</h3>
        <h4 id="easy_4">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List</a>
                (206) - Basic
                reversal ‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle</a> (141) -
                    Floyd's
                    algorithm ‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/merge-
                two-sorted-lists/">Merge Two Sorted Lists</a> (21) - Merge pattern ‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List
                        Elements</a>
                    (203) - Deletion</li>
                <li><a target="_blank" href="https://leetcode.com/problems/palindrome-linked-list/">Palindrome Linked
                        List</a> (234) -
                    Reverse + compare</li>
                </ol>
                <h4 id="medium_4">Medium</h4>
                <ol>
                    <li><a target="_blank" href="https://leetcode.com/problems/reorder-list/">Reorder List</a> (143) -
                        Multi-step pattern ‚≠ê‚≠ê
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth
                    Node From End</a>
                (19) - Gap technique ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/copy-list-with-random-pointer/">Copy List with
                    Random Pointer</a>
                (138) - Deep copy ‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/add-two-numbers/">Add Two Numbers</a> (2) - Carry
                    simulation</li>
                <li><a target="_blank" href="https://leetcode.com/problems/linked-list-cycle-ii/">Linked List Cycle II</a>
                    (142) - Find
                    cycle start</li>
                <li><a target="_blank" href="https://leetcode.com/problems/rotate-list/">Rotate List</a> (61) - Circular
                    technique</li>
                <li><a target="_blank" href="https://leetcode.com/problems/lru-cache/">LRU Cache</a> (146) - Doubly linked +
                    hash ‚≠ê‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-the-duplicate-number/">Find the Duplicate
            <li><a target="_blank" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove
            <li><a target="_blank" href="https://leetcode.com/problems/partition-list/">Partition List</a> (86)</li>
        </ol>
        <h4 id="hard_3">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Reverse Nodes in
                    k-Group</a> (25) -
                    Advanced reversal ‚≠ê‚≠ê‚≠ê</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/merge-k-sorted-lists/">Merge k Sorted Lists</a>
                        (23) - Divide
                        &amp; conquer ‚≠ê‚≠ê</li>
                    </ol>
                    <hr />
                    <h1 id="phase-3-optimization-math">PHASE 3: OPTIMIZATION &amp; MATH ‚ö°</h1>
                    <h2 id="7-greedy">7. GREEDY ‚ö°</h2>
                    <p><strong>Difficulty:</strong> <span style="color: green">‚òÖ‚òÜ‚òÜ</span> | <strong>Optimization Pattern</strong>
                    </p>
                    <h3 id="core-concept_6">Core Concept</h3>
                    <p>Make the locally optimal choice at each step with the hope of finding the global optimum. Unlike DP, you
                        never look back or reconsider choices.</p>
                    <h3 id="when-to-use_6">When to Use</h3>
        <ul>
            <li>‚úÖ <strong>Optimization problems</strong> (min/max)</li>
            <li>‚úÖ <strong>Activity selection/Interval scheduling</strong> (max events)</li>
            <li>‚úÖ <strong>Partitioning</strong> (labels, merge triplets)</li>
            <li>‚úÖ <strong>Huffman Coding</strong> or similar compression</li>
            <li><strong>Signal Words:</strong> "maximum number", "minimum cost", "best fit", "earliest ending"</li>
        </ul>
        <h3 id="sub-patterns_6">Sub-Patterns</h3>
        <h4 id="71-interval-scheduling-earliest-finish-time">7.1 Interval Scheduling (Earliest Finish Time)</h4>
        <p><strong>Use Case:</strong> Maximize number of non-overlapping intervals</p>
        <pre><code class="language-python">def max_non_overlapping(intervals):
            &quot;&quot;&quot;
            GREEDY STRATEGY:
            1. Sort by END time (finish earliest = leave room for more)
            2. Iterate and pick if start &gt;= last_end
            &quot;&quot;&quot;
            # Sort by end time
            intervals.sort(key=lambda x: x[1])

            count = 0
            last_end = float('-inf')

            for start, end in intervals:
                if start &gt;= last_end:
                    count += 1
                    last_end = end

            return count
        </code></pre>
        <p><strong>Time:</strong> O(N log N) for sort | <strong>Space:</strong> O(1)</p>
        <h4 id="72-jump-game-furthest-reach">7.2 Jump Game (Furthest Reach)</h4>
        <p><strong>Use Case:</strong> Can you reach the end? Minimum jumps?</p>
        <pre><code class="language-python">def can_jump(nums):
            &quot;&quot;&quot;
            Track the furthest index reachable from current position.
            If current index &gt; furthest reachable, we're stuck.
            &quot;&quot;&quot;
            furthest = 0
            for i, jump_len in enumerate(nums):
                if i &gt; furthest:
                    return False
                furthest = max(furthest, i + jump_len)

                if furthest &gt;= len(nums) - 1:
                    return True

            return True
</code></pre>
        <p><strong>Time:</strong> O(N) | <strong>Space:</strong> O(1)</p>
        <h4 id="73-kadanes-algorithm-max-subarray">7.3 Kadane's Algorithm (Max Subarray)</h4>
        <p><strong>Use Case:</strong> Maximum sum contiguous subarray</p>
        <pre><code class="language-python">def max_sub_array(nums):
            &quot;&quot;&quot;
            Key insight: If current subarray sum is negative,
            better to reset and start fresh from current element.
            &quot;&quot;&quot;
            current_sum = nums[0]
            max_sum = nums[0]

            for num in nums[1:]:
                # Choice: Continue current subarray OR start new
                current_sum = max(num, current_sum + num)
                max_sum = max(max_sum, current_sum)

            return max_sum
</code></pre>
        <h3 id="common-traps_6">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>False Greedy</strong>: Always prove greedy works (usually by induction). If picking 'largest now'
                limits future options in a bad way, use DP.</li>
            <li>‚ùå <strong>Sorting Key</strong>: Sorting by start vs. end time changes everything.</li>
            <li>‚ùå <strong>Local vs Global</strong>: Greedy fails for "Coin Change" with general coins (requires DP), but works
                for US coins.</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Optimization problem?
        ‚îú‚îÄ Current choice affects future? ‚Üí No (Greedy Property)
        ‚îú‚îÄ Intervals? ‚Üí Sort by end/start time
        ‚îÇ ‚îú‚îÄ Overlap? ‚Üí Merge/Erase
        ‚îÇ ‚îî‚îÄ Meeting Rooms? ‚Üí Min-Heap (end times)
        ‚îú‚îÄ Partitioning labels? ‚Üí Last index map
        ‚îî‚îÄ Huffman/Coding? ‚Üí Min-Heap
        </pre>
        <h3 id="must-know-problems_6">Must-Know Problems</h3>
        <h4 id="medium_5">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a> (53) -
                Kadane's ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/jump-game/">Jump Game</a> (55) - Reachability ‚≠ê
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/jump-game-ii/">Jump Game II</a> (45) - Min jumps
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/gas-station/">Gas Station</a> (134) - Circular
                greedy</li>
            <li><a target="_blank" href="https://leetcode.com/problems/hand-of-straights/">Hand of Straights</a> (846) -
                Ordered map +
                greedy</li>
            <li><a target="_blank" href="https://leetcode.com/problems/partition-labels/">Partition Labels</a> (763) -
                Furthest reach
                variant ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/valid-parenthesis-string/">Valid Parenthesis
                    String</a> (678) -
                    Min/Max open tracking</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/merge-triplets-to-target/">Merge Triplets to Target</a>
                        (1899)</li>
                            </ol>
                            <hr />
                            <h2 id="8-intervals">8. INTERVALS üìä</h2>
                            <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Sorting &amp; Geometry</strong>
                            </p>
                            <h3 id="core-concept_7">Core Concept</h3>
                            <p>Handling overlapping or merging time ranges. Almost always requires sorting by start time first to linearize
                                the problem.</p>
                            <h3 id="when-to-use_7">When to Use</h3>
        <ul>
            <li>‚úÖ <strong>Merging ranges</strong></li>
            <li>‚úÖ <strong>Inserting into sorted intervals</strong></li>
            <li>‚úÖ <strong>Meeting rooms / Resource allocation</strong></li>
            <li><strong>Signal Words:</strong> "start and end times", "overlapping", "merge", "schedule"</li>
        </ul>
        <h3 id="sub-patterns_7">Sub-Patterns</h3>
        <h4 id="81-merge-intervals-pattern">8.1 Merge Intervals Pattern</h4>
        <p><strong>Use Case:</strong> Combine overlapping ranges</p>
        <pre><code class="language-python">def merge_intervals(intervals):
            &quot;&quot;&quot;
            1. Sort by start time.
            2. Iterate: if overlap (current.start &lt;= last.end), merge.
               Else, append new interval.
            &quot;&quot;&quot;
            if not intervals: return []

            intervals.sort(key=lambda x: x[0])
            merged = [intervals[0]]

            for current in intervals[1:]:
                last = merged[-1]

                # Overlap case
                if current[0] &lt;= last[1]:
                    # Merge: extend last end to max of both
                    last[1] = max(last[1], current[1])
                else:
                    # No overlap
                    merged.append(current)

            return merged
</code></pre>
        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
        <h4 id="82-sweep-line-meeting-rooms-ii">8.2 Sweep Line (Meeting Rooms II)</h4>
        <p><strong>Use Case:</strong> Maximum concurrent intervals (Min rooms needed)</p>
        <pre><code class="language-python">def min_meeting_rooms(intervals):
            &quot;&quot;&quot;
            Separate starts and ends, sort both.
            Two pointer sweep.
            &quot;&quot;&quot;
            starts = sorted([i[0] for i in intervals])
            ends = sorted([i[1] for i in intervals])

            count = 0
            max_count = 0
            s, e = 0, 0

            while s &lt; len(intervals):
                if starts[s] &lt; ends[e]:
                    count += 1  # Meeting started
                    s += 1
                else:
                    count -= 1  # Meeting ended
                    e += 1
                max_count = max(max_count, count)

            return max_count
</code></pre>
        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
        <h3 id="common-traps_7">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Edge Cases</strong>: <code>[1,2]</code> and <code>[2,3]</code> - do they touch or overlap? (Usually
                touch = merge).</li>
            <li>‚ùå <strong>Unsorted Input</strong>: Always sort first unless specified.</li>
            <li>‚ùå <strong>Modifying list while iterating</strong>: Create a new <code>merged</code> list result.</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Input text...
        ‚îú‚îÄ Intervals [start, end]? ‚Üí Sort first!
        ‚îú‚îÄ Overlapping?
        ‚îÇ ‚îú‚îÄ Merge? ‚Üí Sort by start, check end
        ‚îÇ ‚îî‚îÄ Insert? ‚Üí Search position, merge
        ‚îú‚îÄ Non-overlapping? ‚Üí Erase Interval (Greedy)
        ‚îî‚îÄ Meeting Rooms? ‚Üí Chronological ordering (Two Arrays/Heap)
        </pre>
        <h3 id="must-know-problems_7">Must-Know Problems</h3>
        <h4 id="easy_intervals">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/meeting-rooms/">Meeting Rooms</a> (252)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/summary-ranges/">Summary Ranges</a> (228)</li>
        </ol>
        <h4 id="medium_6">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/insert-interval/">Insert Interval</a> (57) -
                Linear scan ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a> (56) -
                Sorting ‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/non-overlapping-intervals/">Non-overlapping
                    Intervals</a> (435) -
                    Greedy removal</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/meeting-rooms-ii/">Meeting Rooms II</a> (253) -
                        Sweep line ‚≠ê‚≠ê
            </li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">Minimum Number of
                    Arrows to Burst Balloons</a> (452) - Intersection</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-interval-to-include-each-query/">Minimum
                    Interval to Include Each Query</a> (1851)</li>
                    </ol>
                    <hr />
                    <h2 id="9-bit-manipulation">9. BIT MANIPULATION üî¢</h2>
                    <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Arithmetic Hacks</strong></p>
                    <h3 id="core-concept_8">Core Concept</h3>
                    <p>Manipulate integers at the binary level. XOR is the king of bit manipulation problems.</p>
                    <h3 id="key-operators">Key Operators</h3>
        <ul>
            <li><code>&amp;</code> (AND): Both 1</li>
            <li><code>|</code> (OR): Either 1</li>
            <li><code>^</code> (XOR): Different bits (1 if different, 0 if same)</li>
            <li><code>~</code> (NOT): Invert</li>
            <li><code>&lt;&lt;</code>, <code>&gt;&gt;</code>: Shift</li>
        </ul>
        <h3 id="sub-patterns_8">Sub-Patterns</h3>
        <h4 id="91-xor-property-a-a-0">9.1 XOR Property (a ^ a = 0)</h4>
        <p><strong>Use Case:</strong> Find unique number, missing number</p>
        <pre><code class="language-python">def single_number(nums):
            &quot;&quot;&quot;
            XOR all numbers. Duplicates cancel out (a ^ a = 0).
            Only the unique number remains.
            &quot;&quot;&quot;
            res = 0
            for n in nums:
                res ^= n
            return res
</code></pre>
        <h4 id="92-brian-kernighans-algorithm-count-set-bits">9.2 Brian Kernighan's Algorithm (Count Set Bits)</h4>
        <p><strong>Use Case:</strong> Count 1s (Hamming Weight)</p>
        <pre><code class="language-python">def count_set_bits(n):
            count = 0
            while n:
                n = n &amp; (n - 1)  # Clear the least significant bit set
                count += 1
            return count
</code></pre>
        <h4 id="93-bit-masking">9.3 Bit Masking</h4>
        <p><strong>Use Case:</strong> Track state using bits (e.g., subsets)</p>
        <pre><code class="language-python"># Check if ith bit is set
        is_set = (n &amp; (1 &lt;&lt; i)) != 0

        # Set ith bit
        n = n | (1 &lt;&lt; i)

        # Clear ith bit
        n = n &amp; ~(1 &lt;&lt; i)
        </code></pre>
        <h3 id="common-traps_8">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Operator Precedence</strong>: <code>a &amp; b == 0</code> evaluates as <code>a &amp; (b == 0)</code>.
                <strong>ALWAYS use parentheses</strong>: <code>(a &amp; b) == 0</code>.
            </li>
            <li>‚ùå <strong>Negative Numbers</strong>: Python handles large integers and infinite leading 1s for negatives. Be
                careful using <code>~</code> or checks.</li>
            <li>‚ùå <strong>Overflow</strong>: Python auto-promotes to long, but in Java/C++ checked for MAX_INT.</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Counting 1s? ‚Üí n & (n-1) (Brian Kernighan)
        ‚îú‚îÄ XOR properties?
        ‚îÇ ‚îú‚îÄ Single Number? ‚Üí x ^ x = 0
        ‚îÇ ‚îî‚îÄ Missing Number? ‚Üí XOR all 1..n
        ‚îú‚îÄ Power of 2? ‚Üí n & (n-1) == 0
        ‚îî‚îÄ Reverse Bits? ‚Üí Mask and Shift
        </pre>
        <h3 id="must-know-problems_8">Must-Know Problems</h3>
        <h4 id="easy_5">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/single-number/">Single Number</a> (136) - XOR
                trick ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/number-of-1-bits/">Number of 1 Bits</a> (191) -
                Hamming weight
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/counting-bits/">Counting Bits</a> (338) - DP +
                Bits</li>
            <li><a target="_blank" href="https://leetcode.com/problems/missing-number/">Missing Number</a> (268) - Math
                or XOR</li>
            <li><a target="_blank" href="https://leetcode.com/problems/reverse-bits/">Reverse Bits</a> (190)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/add-binary/">Add Binary</a> (67)</li>
        </ol>
        <h4 id="medium_7">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/sum-of-two-integers/">Sum of Two Integers</a>
                (371) - Adder
                simulation</li>
                <li><a target="_blank" href="https://leetcode.com/problems/reverse-integer/">Reverse Integer</a> (7) -
                    Overflow check</li>
            <li><a target="_blank" href="https://leetcode.com/problems/single-number-ii/">Single Number II</a> (137)
            <li><a target="_blank" href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">Bitwise AND of Numbers
                    Range</a> (201)</li>
        </ol>
        <hr />
        <h2 id="10-math-geometry">10. MATH &amp; GEOMETRY ‚ûó</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Logic &amp; Rules</strong></p>
        <h3 id="core-concept_9">Core Concept</h3>
        <p>Using mathematical properties (modulo, powers, GCD) or matrix coordinates to solve problems efficiently.</p>
        <h3 id="sub-patterns_9">Sub-Patterns</h3>
        <h4 id="101-matrix-traversal">10.1 Matrix Traversal</h4>
        <p><strong>Use Case:</strong> Spiral matrix, Rotate image</p>
        <pre><code class="language-python">def rotate_image(matrix):
            &quot;&quot;&quot;
            Rotate 90 deg clockwise in-place.
            Strategy: Transpose (swap i,j) then Reverse rows.
            &quot;&quot;&quot;
            n = len(matrix)

            # 1. Transpose
            for i in range(n):
                for j in range(i, n):
                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

            # 2. Reverse rows
            for i in range(n):
                matrix[i].reverse()
</code></pre>
        <h4 id="102-fast-power-exponentiation">10.2 Fast Power (Exponentiation)</h4>
        <p><strong>Use Case:</strong> Calculate x^n in O(log n)</p>
        <pre><code class="language-python">def my_pow(x, n):
            def helper(x, n):
                if x == 0: return 0
                if n == 0: return 1

                res = helper(x, n // 2)
                res = res * res

                return x * res if n % 2 else res

            res = helper(x, abs(n))
            return res if n &gt;= 0 else 1 / res
</code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Geometric?
        ‚îÇ ‚îú‚îÄ Rotation? ‚Üí Matrix Transpose + Reverse
        ‚îÇ ‚îî‚îÄ Distance? ‚Üí Euclidean/Manhattan
        ‚îú‚îÄ Number Theory?
        ‚îÇ ‚îú‚îÄ Primes? ‚Üí Sieve of Eratosthenes
        ‚îÇ ‚îî‚îÄ GCD/LCM? ‚Üí Euclidean Algorithm
        ‚îî‚îÄ Pow(x, n)? ‚Üí Binary Exponentiation
        </pre>
        <h3 id="must-know-problems_9">Must-Know Problems</h3>
        <h4 id="easy_6">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/happy-number/">Happy Number</a> (202) - Cycle
                detection (Set/F-S)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/plus-one/">Plus One</a> (66)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindrome-number/">Palindrome Number</a> (9)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/factorial-trailing-zeroes/">Factorial Trailing Zeroes</a>
                (172)</li>
        </ol>
        <h4 id="medium_8">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/rotate-image/">Rotate Image</a> (48) - Matrix
                manipulation ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/spiral-matrix/">Spiral Matrix</a> (54) -
                Simulation ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/set-matrix-zeroes/">Set Matrix Zeroes</a> (73) -
                Space
                optimization</li>
            <li><a target="_blank" href="https://leetcode.com/problems/powx-n/">Pow(x, n)</a> (50) - Recursive log n
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/multiply-strings/">Multiply Strings</a> (43)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/detect-squares/">Detect Squares</a> (2017)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/max-points-on-a-line/">Max Points on a Line</a>
                (149)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/game-of-life/">Game of Life</a> (289)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/random-pick-with-weight/">Random Pick with
                    Weight</a> (528) - Probability/Prefix Sum</li>
            </ol>
            <hr />
            <h2 id="11-heap-priority-queue">11. HEAP / PRIORITY QUEUE üèÜ</h2>
            <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Data Structure</strong></p>
            <h3 id="core-concept_10">Core Concept</h3>
            <p>A tree-based structure that maintains the min (or max) element at the root. Insert/Delete in O(log N), Peek
                in O(1). Python's <code>heapq</code> is a Min-Heap by default.</p>
            <h3 id="when-to-use_8">When to Use</h3>
        <ul>
            <li>‚úÖ <strong>Find top K elements</strong> (largest/smallest/frequent)</li>
            <li>‚úÖ <strong>Merge K sorted structures</strong></li>
            <li>‚úÖ <strong>Median in data stream</strong></li>
            <li><strong>Signal Words:</strong> "kth largest", "top k", "median", "schedule tasks"</li>
        </ul>
        <h3 id="sub-patterns">Sub-Patterns</h3>
        <h4 id="11.1-top-k-elements">11.1 Top K Elements Pattern</h4>
        <pre><code class="language-python">import heapq

        def find_kth_largest(nums, k):
            &quot;&quot;&quot;
            Maintain a Min-Heap of size K.
            The root will be the Kth largest element seen so far.
            &quot;&quot;&quot;
            heap = []
            for num in nums:
                heapq.heappush(heap, num)
                if len(heap) &gt; k:
                    heapq.heappop(heap)

            return heap[0] # Kth largest
</code></pre>
        <h4 id="11.2-two-heaps">11.2 Two Heaps Pattern</h4>
        <p>Maintain two heaps:<br />
            1. <code>small</code>: Max-Heap (stores smaller half of numbers)<br />
            2. <code>large</code>: Min-Heap (stores larger half)</p>
        <p>Balance them so <code>len(small) == len(large)</code> or <code>len(small) == len(large) + 1</code>. Median is
            top of <code>small</code> (or avg of tops).</p>
        <h3 id="common-traps_9">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Max Heap in Python</strong>: Python only has Min Heap. For Max Heap, <strong>negate</strong> numbers
                when pushing, negate back when popping.</li>
            <li>‚ùå <strong>Time Complexity</strong>: Heapify is O(N). Pushing N items is O(N log N).</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Top K elements?
        ‚îÇ ‚îú‚îÄ Largest? ‚Üí Min-Heap (size k)
        ‚îÇ ‚îî‚îÄ Smallest? ‚Üí Max-Heap (size k)
        ‚îú‚îÄ Streaming data?
        ‚îÇ ‚îî‚îÄ Median? ‚Üí Two Heaps (Min + Max)
        ‚îú‚îÄ K-way merge? ‚Üí Min-Heap
        ‚îî‚îÄ Task Scheduling? ‚Üí Max-Heap
        </pre>
        <h3 id="must-know-problems_10">Must-Know Problems</h3>
        <h4 id="easy_7">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/last-stone-weight/">Last Stone Weight</a> (1046)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">Kth Largest
                    Element in a Stream</a> (703)</li>
            </ol>
            <h4 id="medium_9">Medium</h4>
            <ol>
                <li><a target="_blank" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Kth Largest
                        Element in an
                        Array</a> (215) - Selection/Heap ‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/task-scheduler/">Task Scheduler</a> (621) -
                    Greedy + Heap</li>
                <li><a target="_blank" href="https://leetcode.com/problems/design-twitter/">Design Twitter</a> (355) - Merge
                    K sorted</li>
            <li><a target="_blank" href="https://leetcode.com/problems/k-closest-points-to-origin/">K Closest Points to
                    Origin</a> (973)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/">Find K Pairs
                    with Smallest Sums</a> (373)</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/reorganize-string/">Reorganize String</a> (767) -
                        Greedy Heap</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/top-k-frequent-words/">Top K Frequent Words</a>
                        (692) - Trie + Heap</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">Kth
                            Smallest Element in a Sorted Matrix</a> (378) - Binary Search on Answer / Heap</li>
                    </ol>
                    <h4 id="hard_4">Hard</h4>
                    <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/find-median-from-data-stream/">Find Median from
                    Data Stream</a>
                (295) - Two heaps ‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/ipo/">IPO</a> (502)</li>
        </ol>
        <hr />
        <h1 id="phase-4-trees-recursion">PHASE 4: TREES &amp; RECURSION üå≥</h1>
        <h2 id="12-binary-trees">12. BINARY TREES üå≤</h2>
        <p><strong>Difficulty:</strong> <span style="color: orange">‚òÖ‚òÖ‚òÜ</span> | <strong>Foundation for Advanced
                Patterns</strong></p>
        <h3 id="core-concept_11">Core Concept</h3>
        <p>Hierarchical structure where each node has at most two children. Master DFS (pre/in/post order) and BFS
            (level order) traversals. Think recursively: "solve for children, combine for parent."</p>
        <h3 id="when-to-use_9">When to Use</h3>
        <ul>
            <li>‚úÖ Hierarchical data traversal</li>
            <li>‚úÖ Path problems (root to leaf)</li>
            <li>‚úÖ Level-based operations</li>
            <li>‚úÖ Tree validation/construction</li>
            <li>‚úÖ Subtree problems</li>
            <li><strong>Signal Words:</strong> "tree", "root", "ancestor", "depth", "level", "path"</li>
        </ul>
        <h3 id="sub-patterns_10">Sub-Patterns</h3>
        <h4 id="12.1-dfs-traversals">12.1 DFS Traversals (Recursive)</h4>
        <p><strong>Core Templates:</strong></p>
        <pre><code class="language-python">class TreeNode:
            def __init__(self, val=0, left=None, right=None):
                self.val = val
                self.left = left
                self.right = right

        # Preorder: Root ‚Üí Left ‚Üí Right (Top-down)
        def preorder(root):
            if not root:
                return []
            return [root.val] + preorder(root.left) + preorder(root.right)

        # Inorder: Left ‚Üí Root ‚Üí Right (BST gives sorted)
        def inorder(root):
            if not root:
                return []
            return inorder(root.left) + [root.val] + inorder(root.right)

        # Postorder: Left ‚Üí Right ‚Üí Root (Bottom-up)
        def postorder(root):
            if not root:
                return []
            return postorder(root.left) + postorder(root.right) + [root.val]
</code></pre>
        <p><strong>When to use each:</strong><br />
            - <strong>Preorder</strong>: Copy tree, serialize, prefix expression<br />
            - <strong>Inorder</strong>: BST operations (get sorted order)<br />
            - <strong>Postorder</strong>: Delete tree, calculate subtree properties, postfix expression</p>
        <h5 id="depthheight-calculations">Depth/Height Calculations</h5>
        <pre><code class="language-python">def max_depth(root):
            &quot;&quot;&quot;
            BOTTOM-UP (Postorder):
            - Get depth of children
            - Return 1 + max(left, right)
            &quot;&quot;&quot;
            if not root:
                return 0

            left_depth = max_depth(root.left)
            right_depth = max_depth(root.right)

            return 1 + max(left_depth, right_depth)

        def min_depth(root):
            &quot;&quot;&quot;
            Minimum depth to leaf (node with no children)
            CAREFUL: Don't count path to None child!
            &quot;&quot;&quot;
            if not root:
                return 0

            # If one child is None, ignore it
            if not root.left:
                return 1 + min_depth(root.right)
            if not root.right:
                return 1 + min_depth(root.left)

            # Both children exist
            return 1 + min(min_depth(root.left), min_depth(root.right))

        def is_balanced(root):
            &quot;&quot;&quot;
            Check if height-balanced (left and right depth differ by ‚â§ 1)
            &quot;&quot;&quot;
            def check(node):
                if not node:
                    return 0, True  # (height, is_balanced)

                left_h, left_bal = check(node.left)
                if not left_bal:
                    return 0, False

                right_h, right_bal = check(node.right)
                if not right_bal:
                    return 0, False

                balanced = abs(left_h - right_h) &lt;= 1
                height = 1 + max(left_h, right_h)

                return height, balanced

            return check(root)[1]
</code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h) for recursion stack, h = height</p>
        <h5 id="path-sum-problems">Path Sum Problems</h5>
        <pre><code class="language-python">def has_path_sum(root, target_sum):
            &quot;&quot;&quot;
            Check if root-to-leaf path sums to target
            TOP-DOWN: Pass remaining sum down
            &quot;&quot;&quot;
            if not root:
                return False

            # Leaf node
            if not root.left and not root.right:
                return root.val == target_sum

            remaining = target_sum - root.val
            return (has_path_sum(root.left, remaining) or
                    has_path_sum(root.right, remaining))

        def path_sum_all(root, target_sum):
            &quot;&quot;&quot;
            Find ALL root-to-leaf paths that sum to target
            &quot;&quot;&quot;
            def dfs(node, remaining, path, result):
                if not node:
                    return

                path.append(node.val)

                # Check if leaf and sum matches
                if not node.left and not node.right and remaining == node.val:
                    result.append(path[:])  # Copy path!

                # Recurse
                dfs(node.left, remaining - node.val, path, result)
                dfs(node.right, remaining - node.val, path, result)

                path.pop()  # Backtrack

            result = []
            dfs(root, target_sum, [], result)
            return result

        def max_path_sum(root):
            &quot;&quot;&quot;
            HARD: Maximum path sum (any node to any node)
            Can go through root or entirely in one subtree

            TECHNIQUE:
            - Each node decides: include me or not?
            - Track global maximum
            - Return: max single-path sum through this node
            &quot;&quot;&quot;
            max_sum = float('-inf')

            def max_gain(node):
                nonlocal max_sum

                if not node:
                    return 0

                # Max sum from left/right (ignore if negative)
                left_gain = max(max_gain(node.left), 0)
                right_gain = max(max_gain(node.right), 0)

                # Path through this node
                path_sum = node.val + left_gain + right_gain
                max_sum = max(max_sum, path_sum)

                # Return max single branch sum (for parent)
                return node.val + max(left_gain, right_gain)

            max_gain(root)
            return max_sum
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h)</p>
        <h4 id="12.2-bfs-level-order">12.2 BFS (Level Order Traversal)</h4>
        <pre><code class="language-python">from collections import deque

        def level_order(root):
            &quot;&quot;&quot;
            BFS TEMPLATE:
            1. Use queue (deque)
            2. Process level by level
            3. Add children of current level to queue
            &quot;&quot;&quot;
            if not root:
                return []

            result = []
            queue = deque([root])

            while queue:
                level = []
                level_size = len(queue)  # IMPORTANT: Fix size for this level

                for _ in range(level_size):
                    node = queue.popleft()
                    level.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)

                result.append(level)

            return result

        def zigzag_level_order(root):
            &quot;&quot;&quot;
            Alternate left-to-right and right-to-left
            &quot;&quot;&quot;
            if not root:
                return []

            result = []
            queue = deque([root])
            left_to_right = True

            while queue:
                level = []
                level_size = len(queue)

                for _ in range(level_size):
                    node = queue.popleft()
                    level.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)

                # Reverse if right-to-left
                if not left_to_right:
                    level.reverse()

                result.append(level)
                left_to_right = not left_to_right

            return result

        def right_side_view(root):
            &quot;&quot;&quot;
            View from right side = rightmost node at each level
            &quot;&quot;&quot;
            if not root:
                return []

            result = []
            queue = deque([root])

            while queue:
                level_size = len(queue)

                for i in range(level_size):
                    node = queue.popleft()

                    # Rightmost node of this level
                    if i == level_size - 1:
                        result.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)

            return result
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(w) where w = max width of tree</p>
        <h4 id="12.3-tree-construction">12.3 Tree Construction</h4>
        <pre><code class="language-python">def build_tree_pre_in(preorder, inorder):
            &quot;&quot;&quot;
            Construct tree from preorder and inorder

            KEY INSIGHTS:
            - Preorder[0] is root
            - Find root in inorder ‚Üí splits left/right subtrees
            - Recursively build left and right
            &quot;&quot;&quot;
            if not preorder or not inorder:
                return None

            root_val = preorder[0]
            root = TreeNode(root_val)

            # Find root position in inorder
            mid = inorder.index(root_val)

            # Build left and right subtrees
            root.left = build_tree_pre_in(
                preorder[1:mid+1],
                inorder[:mid]
            )
            root.right = build_tree_pre_in(
                preorder[mid+1:],
                inorder[mid+1:]
            )

            return root

        def build_tree_in_post(inorder, postorder):
            &quot;&quot;&quot;
            Construct from inorder and postorder
            Postorder: last element is root
            &quot;&quot;&quot;
            if not inorder or not postorder:
                return None

            root_val = postorder[-1]
            root = TreeNode(root_val)

            mid = inorder.index(root_val)

            root.left = build_tree_in_post(
                inorder[:mid],
                postorder[:mid]
            )
            root.right = build_tree_in_post(
                inorder[mid+1:],
                postorder[mid:-1]
            )

            return root
        </code></pre>
        <p><strong>Time:</strong> O(n¬≤) due to index search, O(n) with hash map | <strong>Space:</strong> O(n)</p>
        <p><strong>Optimization with Hash Map:</strong></p>
        <pre><code class="language-python">def build_tree_optimized(preorder, inorder):
            inorder_map = {val: i for i, val in enumerate(inorder)}

            def helper(pre_left, pre_right, in_left, in_right):
                if pre_left &gt; pre_right:
                    return None

                root_val = preorder[pre_left]
                root = TreeNode(root_val)

                in_root = inorder_map[root_val]
                left_size = in_root - in_left

                root.left = helper(
                    pre_left + 1,
                    pre_left + left_size,
                    in_left,
                    in_root - 1
                )
                root.right = helper(
                    pre_left + left_size + 1,
                    pre_right,
                    in_root + 1,
                    in_right
                )

                return root

            return helper(0, len(preorder) - 1, 0, len(inorder) - 1)
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(n)</p>
        <h4 id="74-tree-comparison-validation">7.4 Tree Comparison &amp; Validation</h4>
        <pre><code class="language-python">def is_same_tree(p, q):
            &quot;&quot;&quot;
            Check if two trees are identical
            &quot;&quot;&quot;
            if not p and not q:
                return True
            if not p or not q:
                return False

            return (p.val == q.val and
                    is_same_tree(p.left, q.left) and
                    is_same_tree(p.right, q.right))

        def is_subtree(root, sub_root):
            &quot;&quot;&quot;
            Check if sub_root is subtree of root
            &quot;&quot;&quot;
            if not root:
                return False

            if is_same_tree(root, sub_root):
                return True

            return (is_subtree(root.left, sub_root) or
                    is_subtree(root.right, sub_root))

        def is_symmetric(root):
            &quot;&quot;&quot;
            Check if tree is mirror of itself
            &quot;&quot;&quot;
            def is_mirror(left, right):
                if not left and not right:
                    return True
                if not left or not right:
                    return False

                return (left.val == right.val and
                        is_mirror(left.left, right.right) and
                        is_mirror(left.right, right.left))

            return is_mirror(root, root)
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h)</p>
        <h4 id="75-lowest-common-ancestor-lca">7.5 Lowest Common Ancestor (LCA)</h4>
        <pre><code class="language-python">def lowest_common_ancestor(root, p, q):
            &quot;&quot;&quot;
            TECHNIQUE:
            - If root is p or q, return root
            - Check left and right subtrees
            - If both return non-null, root is LCA
            - Otherwise, return non-null side
            &quot;&quot;&quot;
            if not root or root == p or root == q:
                return root

            left = lowest_common_ancestor(root.left, p, q)
            right = lowest_common_ancestor(root.right, p, q)

            if left and right:
                return root  # Both sides found, root is LCA

            return left if left else right
        </code></pre>
        <p><strong>Time:</strong> O(n) | <strong>Space:</strong> O(h)</p>
        <h3 id="common-traps_10">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Null Checks</strong>: Always check <code>if not root</code> first</li>
            <li>‚ùå <strong>Leaf vs None</strong>: Leaf has no children, not root.val == None
                <pre><code class="language-python"># Leaf check
                                                if not node.left and not node.right:
                                                    # do something</code></pre>
            </li>
            <li>‚ùå <strong>Recursion Stack</strong>: Deep trees (h &gt; 1000) may cause stack overflow</li>
            <li>‚ùå <strong>Path Copy</strong>: When storing paths, always copy list
                <pre><code class="language-python">result.append(path[:])  # Not path!</code></pre>
            </li>
            <li>‚ùå <strong>Level Order Size</strong>: Fix <code>level_size = len(queue)</code> before loop</li>
            <li>‚ùå <strong>Min Depth</strong>: Don't count path to None child</li>
        </ul>
        <h3 id="traversal-selection-guide">Traversal Selection Guide</h3>
        <pre><code>What do you need?
        ‚îú‚îÄ Process node before children?
        ‚îÇ   ‚îî‚îÄ Preorder (top-down)
        ‚îú‚îÄ Process node between children? (BST sorted order?)
        ‚îÇ   ‚îî‚îÄ Inorder
        ‚îú‚îÄ Process node after children? (bottom-up calculation?)
        ‚îÇ   ‚îî‚îÄ Postorder
        ‚îî‚îÄ Process level by level?
            ‚îî‚îÄ BFS (level order)
        </code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Structure?
        ‚îú‚îÄ Traversals?
        ‚îÇ ‚îú‚îÄ Level Order? ‚Üí BFS (Queue)
        ‚îÇ ‚îî‚îÄ Depth First? ‚Üí DFS (Recursion/Stack)
        ‚îú‚îÄ BST Properties?
        ‚îÇ ‚îú‚îÄ In-order is sorted
        ‚îÇ ‚îî‚îÄ Validate? ‚Üí Range (min, max)
        ‚îú‚îÄ Construction?
        ‚îÇ ‚îî‚îÄ From Pre/In-order? ‚Üí Root is first in Pre
        ‚îî‚îÄ Serialization? ‚Üí Encode structure
        </pre>
        <h3 id="must-know-problems_11">Must-Know Problems</h3>
        <h4 id="easy_8">Easy</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree</a> (226)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/same-tree/">Same Tree</a> (100) - Comparison</li>
            <li><a target="_blank" href="https://leetcode.com/problems/symmetric-tree/">Symmetric Tree</a> (101) -
                Mirror check</li>
            <li><a target="_blank" href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree</a>
                (110) - Height
                check</li>
                <li><a target="_blank" href="https://leetcode.com/problems/path-sum/">Path Sum</a> (112) - DFS path</li>
            <li><a target="_blank" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">Average of
                    Levels in Binary Tree</a> (637)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">Minimum
                    Absolute Difference in BST</a> (530)</li>
                    </ol>
                    <h4 id="medium_10">Medium</h4>
                    <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/diameter-of-binary-tree/">Diameter of Binary
                    Tree</a> (543) -
                    Bottom-up ‚≠ê</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">Lowest
                            Common
                            Ancestor</a> (236) - LCA template ‚≠ê‚≠ê</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Lowest Common
                    Ancestor of a Binary Search Tree</a> (235)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree
                    Level Order
                    Traversal</a> (102) - BFS template ‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-right-side-view/">Binary Tree Right
                    Side View</a>
                (199) - BFS variant</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct
                    Binary Tree from Preorder and Inorder</a> (105) - Construction ‚≠ê‚≠ê</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">Construct
                    Binary Tree from Inorder and Postorder Traversal</a> (106)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary
                    Search Tree</a>
                (98) - Range validation</li>
            <li><a target="_blank" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Kth Smallest in
                    BST</a> (230) -
                Inorder</li>
            <li><a target="_blank" href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/">Count Good
                    Nodes</a> (1448) -
                Path max</li>
            <li><a target="_blank" href="https://leetcode.com/problems/subtree-of-another-tree/">Subtree of Another
                    Tree</a> (572)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">Sum Root to Leaf
                    Numbers</a> (129)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/count-complete-tree-nodes/">Count Complete Tree
                    Nodes</a> (222)</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">Binary
                            Tree Zigzag Level Order Traversal</a> (103)</li>
                    </ol>
                    <h4 id="hard_5">Hard</h4>
                    <ol>
                        <li><a target="_blank" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">Binary Tree
                                Maximum Path Sum</a>
                            (124) - Global max ‚≠ê‚≠ê‚≠ê</li>
                        <li><a target="_blank" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">Serialize
                                and Deserialize
                                Binary Tree</a> (297) - Encoding ‚≠ê‚≠ê</li>
                    </ol>
                    <hr />

        <hr />
        <h2 id="13-tries-">13. TRIES üìù </h2>
        <h3 id="when-to-use-12">When to Use </h3>
        <ul>
            <li>Prefix-based searches/inserts</li>
            <li>Word suggestions/autocomplete</li>
            <li>Validate words in dict</li>
            <li>Longest prefix</li>
            <li>Signal: "prefix" or "trie/dictionary"</li>
        </ul>
        <h3 id="core-concept-12">Core Concept </h3>
        <p>Tree of characters for shared prefixes, enabling O(L) inserts/searches where L is word length, vs O(nL) for
            sets.</p>
        <h3 id="sub-patterns-6">Sub-Patterns </h3>
        <h4 id="13.1-trie-implementation">13.1 Trie Implementation</h4>
        <pre><code class="language-python"><span class="token keyword keyword-class">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>is_end <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>root <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword keyword-for">for</span> char <span class="token keyword keyword-in">in</span> word<span class="token punctuation">:</span>
            <span class="token keyword keyword-if">if</span> char <span class="token keyword keyword-not">not</span> <span class="token keyword keyword-in">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span> <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
        node<span class="token punctuation">.</span>is_end <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
        <span class="token keyword keyword-for">for</span> char <span class="token keyword keyword-in">in</span> word<span class="token punctuation">:</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">.</span>get<span class="token punctuation">(</span>char<span class="token punctuation">)</span>
            <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-not">not</span> node<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">False</span>
        <span class="token keyword keyword-return">return</span> node<span class="token punctuation">.</span>is_end
</code></pre>
        <p><strong>Prefix Search</strong></p>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">starts_with</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
    node <span class="token operator">=</span> self<span class="token punctuation">.</span>root
    <span class="token keyword keyword-for">for</span> char <span class="token keyword keyword-in">in</span> prefix<span class="token punctuation">:</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">.</span>get<span class="token punctuation">(</span>char<span class="token punctuation">)</span>
        <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-not">not</span> node<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">False</span>
    <span class="token keyword keyword-return">return</span> <span class="token boolean">True</span>
</code></pre>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Input...
        ‚îú‚îÄ String prefix queries? ‚Üí Trie
        ‚îú‚îÄ Autocomplete? ‚Üí Trie with frequency/end marks
        ‚îú‚îÄ Word Search II (Grid)? ‚Üí Trie + DFS
        ‚îî‚îÄ Max XOR pair? ‚Üí Bitwise Trie
        </pre>
        <p><strong>Common Pitfalls:</strong></p>
        <ul>
            <li>Case sensitivity</li>
            <li>Empty word</li>
            <li>Memory usage</li>
            <li>Deletion</li>
        </ul>
        <h3 id="must-know-problems_13">Must-Know Problems</h3>
        <h4 id="medium_13">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie
                    (Prefix Tree)</a>
                (208)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">Design Add and
                    Search Words Data Structure</a> (211)</li>
        </ol>
        <h4 id="hard_11">Hard</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/word-search-ii/">Word Search II</a> (212)</li>
        </ol>

        <hr />
        <h2 id="14-backtracking-">14. BACKTRACKING üîÑ </h2>
        <h3 id="when-to-use-13">When to Use </h3>
        <ul>
            <li>Generate combinations/permutations</li>
            <li>Subsets/solutions with choices</li>
            <li>Puzzles (N-Queens, Sudoku)</li>
            <li>Path finding with branches</li>
            <li>Signal: "all possible" or "combinations"</li>
        </ul>
        <h3 id="core-concept-13">Core Concept </h3>
        <p>Systematically explore branches with pruning/undoing choices, bounding exponential space by early
            termination.</p>
        <h3 id="sub-patterns-7">Sub-Patterns </h3>
        <h4 id="14.1-subsets-pattern">14.1 Subsets Pattern</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">subsets</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># Copy!</span>
        <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            backtrack<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span> <span class="token comment"># No reuse</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># Backtrack</span>
    backtrack<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> res
</code></pre>
        <h4 id="14.2-permutations-pattern">14.2 Permutations Pattern</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    used <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-if">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-return">return</span>
        <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword keyword-if">if</span> used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword keyword-continue">continue</span>
            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            backtrack<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>
    backtrack<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> res
</code></pre>
        <h3 id="traps-12">Common Traps üö®</h3>
        <ul>
            <li>‚ùå Reference copy: <code>path[:]</code> not <code>path</code></li>
            <li>‚ùå Duplicates: Sort + <code>if i &gt; start and nums[i] == nums[i-1]: continue</code></li>
            <li>‚ùå Undo state: Always pop/False after recurse</li>
            <li>‚ùå Prune early: If partial invalid, return</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Combinatorial Search?
        ‚îÇ ‚îú‚îÄ Permutations? ‚Üí Order matters
        ‚îÇ ‚îú‚îÄ Combinations? ‚Üí Order doesn't matter
        ‚îÇ ‚îî‚îÄ Subsets? ‚Üí Include/Exclude
        ‚îú‚îÄ Constraints/Games?
        ‚îÇ ‚îú‚îÄ N-Queens? ‚Üí Row/Col/Diag checks
        ‚îÇ ‚îî‚îÄ Sudoku? ‚Üí Grid/Row/Col checks
        ‚îî‚îÄ String Partition? ‚Üí Palindrome Partitioning
        </pre>
        <h3 id="must-know-problems_12">Must-Know Problems</h3>
        <h4 id="medium_12">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/subsets/">Subsets</a> (78)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/combination-sum/">Combination Sum</a> (39)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/permutations/">Permutations</a> (46)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/subsets-ii/">Subsets II</a> (90)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/combination-sum-ii/">Combination Sum II</a> (40)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/word-search/">Word Search</a> (79)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindrome-partitioning/">Palindrome
                    Partitioning</a> (131)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">Letter
                    Combinations of a
                    Phone Number</a> (17)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/combinations/">Combinations</a> (77)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/restore-ip-addresses/">Restore IP Addresses</a>
                (93) - Partitioning String</li>
            </ol>
            <h4 id="hard_10">Hard</h4>
            <ol>
                <li><a target="_blank" href="https://leetcode.com/problems/n-queens/">N-Queens</a> (51)</li>
                <li><a target="_blank" href="https://leetcode.com/problems/n-queens-ii/">N-Queens II</a> (52)</li>
            </ol>

        <hr />
        <h1 id="phase-5-graph-mastery">PHASE 5: GRAPH MASTERY üåê</h1>
        <h2 id="15-graphs-üåê">15. GRAPHS üåê</h2>
        <p>**Difficulty:** <span style="color: red">‚òÖ‚òÖ‚òÖ</span> | **Builds on:** Trees, BFS, DFS, Backtracking</p>
        <h3 id="core-concept">Core Concept</h3>
        <p>Model relationships as nodes (vertices) and edges. Use BFS for shortest paths in unweighted graphs, DFS for
            connectivity/cycles. Master both adjacency list representation and traversal patterns.</p>
        <h3 id="when-to-use">When to Use</h3>
        <ul>
            <li>‚úÖ Connectivity problems (islands, components)</li>
        </ul>
        <ul>
            <li>‚úÖ Shortest path (unweighted: BFS, weighted: Dijkstra)</li>
        </ul>
        <ul>
            <li>‚úÖ Cycle detection, topological sort</li>
            </ul>
            <ul>
                <li>‚úÖ Network flow, dependency resolution</li>
            </ul>
            <ul>
                <li>‚úÖ Matrix traversal (grid graphs)</li>
        </ul>
        <p>- **Signal Words:** "connected", "path", "network", "dependencies", "prerequisites", "islands"</p>
        <h3 id="graph-representations">Graph Representations</h3>
        <pre><code class="language-python">
        # Adjacency List (Most Common)
        graph = {
            'A': ['B', 'C'],
            'B': ['A', 'D'],
            'C': ['A', 'D'],
            'D': ['B', 'C']
        }

        # Or using defaultdict
        from collections import defaultdict
        graph = defaultdict(list)
        graph['A'].append('B')

        # Edge List (for algorithms like Union-Find)
        edges = [('A', 'B'), ('B', 'C'), ('C', 'D')]

        # Adjacency Matrix (for dense graphs)
        matrix = [
            [0, 1, 1, 0],
            [1, 0, 0, 1],
            [1, 0, 0, 1],
            [0, 1, 1, 0]
        ]
        </code></pre>
        <h3 id="sub-patterns">Sub-Patterns</h3>
        <h4 id="151-bfs---shortest-path-&-level-traversal">15.1 BFS - Shortest Path & Level Traversal</h4>
        <pre><code class="language-python">
        from collections import deque

        def bfs_shortest_path(graph, start, end):
            """
            BFS TEMPLATE for shortest path in unweighted graph

            KEY POINTS:
            - Queue for FIFO processing
            - Visited set to avoid cycles
            - Track parent/distance for path reconstruction
            """
            if start == end:
                return 0

            queue = deque([(start, 0)])  # (node, distance)
            visited = {start}

            while queue:
                node, dist = queue.popleft()

                for neighbor in graph[node]:
                    if neighbor in visited:
                        continue

                    if neighbor == end:
                        return dist + 1

                    visited.add(neighbor)
                    queue.append((neighbor, dist + 1))

            return -1  # No path

        def bfs_with_path(graph, start, end):
            """
            Return actual path, not just distance
            Track parent pointers
            """
            if start == end:
                return [start]

            queue = deque([start])
            visited = {start}
            parent = {start: None}

            while queue:
                node = queue.popleft()

                for neighbor in graph[node]:
                    if neighbor in visited:
                        continue

                    visited.add(neighbor)
                    parent[neighbor] = node
                    queue.append(neighbor)

                    if neighbor == end:
                        # Reconstruct path
                        path = []
                        current = end
                        while current is not None:
                            path.append(current)
                            current = parent[current]
                        return path[::-1]

            return []

        def bfs_multi_source(grid):
            """
            Multi-source BFS: Start from multiple sources simultaneously
            Example: Rotting oranges, walls and gates

            TECHNIQUE: Add all sources to queue initially
            """
            rows, cols = len(grid), len(grid[0])
            queue = deque()

            # Add all sources
            for r in range(rows):
                for c in range(cols):
                    if grid[r][c] == 2:  # Source (e.g., rotten orange)
                        queue.append((r, c, 0))  # (row, col, time)

            max_time = 0

            while queue:
                r, c, time = queue.popleft()
                max_time = max(max_time, time)

                for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                    nr, nc = r + dr, c + dc

                    if (0 <= nr < rows and 0 <= nc < cols and
                        grid[nr][nc] == 1):  # Fresh orange
                        grid[nr][nc] = 2  # Make rotten
                        queue.append((nr, nc, time + 1))

            return max_time
        </code></pre>
        <p>**Time:** O(V + E) | **Space:** O(V)</p>
        <h4 id="152-dfs---connectivity-&-cycles">15.2 DFS - Connectivity & Cycles</h4>
        <pre><code class="language-python">
        def dfs_recursive(graph, node, visited):
            """
            BASIC DFS TEMPLATE (Recursive)

            Use for:
            - Finding connected components
            - Detecting cycles
            - Topological sort (with modifications)
            """
            visited.add(node)

            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs_recursive(graph, neighbor, visited)

        def dfs_iterative(graph, start):
            """
            DFS with explicit stack (iterative)
            Useful when recursion depth is concern
            """
            visited = set()
            stack = [start]

            while stack:
                node = stack.pop()

                if node in visited:
                    continue

                visited.add(node)

                # Process node
                print(node)

                # Add neighbors (reverse for same order as recursive)
                for neighbor in reversed(graph[node]):
                    if neighbor not in visited:
                        stack.append(neighbor)

            return visited

        def count_connected_components(n, edges):
            """
            Count number of connected components

            TECHNIQUE: DFS from each unvisited node
            """
            graph = defaultdict(list)
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)

            visited = set()
            count = 0

            def dfs(node):
                visited.add(node)
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        dfs(neighbor)

            for node in range(n):
                if node not in visited:
                    dfs(node)
                    count += 1

            return count

        def has_cycle_undirected(graph, n):
            """
            Detect cycle in undirected graph

            KEY: Track parent to avoid false positive
            Edge back to parent is not a cycle
            """
            visited = set()

            def dfs(node, parent):
                visited.add(node)

                for neighbor in graph[node]:
                    if neighbor not in visited:
                        if dfs(neighbor, node):
                            return True
                    elif neighbor != parent:
                        return True  # Back edge (not to parent) = cycle

                return False

            for node in range(n):
                if node not in visited:
                    if dfs(node, -1):
                        return True

            return False

        def has_cycle_directed(graph, n):
            """
            Detect cycle in directed graph

            KEY: Track recursion stack, not just visited
            Three states: unvisited (0), visiting (1), visited (2)
            """
            state = [0] * n  # 0: unvisited, 1: visiting, 2: visited

            def dfs(node):
                if state[node] == 1:  # In recursion stack
                    return True
                if state[node] == 2:  # Already processed
                    return False

                state[node] = 1  # Mark as visiting

                for neighbor in graph[node]:
                    if dfs(neighbor):
                        return True

                state[node] = 2  # Mark as visited
                return False

            for node in range(n):
                if state[node] == 0:
                    if dfs(node):
                        return True

            return False
        </code></pre>
        <p>**Time:** O(V + E) | **Space:** O(V)</p>
        <h4 id="153-topological-sort">15.3 Topological Sort</h4>
        <pre><code class="language-python">
        def topological_sort_dfs(graph, n):
            """
            APPROACH 1: DFS with postorder

            TECHNIQUE:
            - DFS from each node
            - Add to result AFTER processing all neighbors
            - Reverse result for topological order

            Used for: Course schedule, build order
            """
            visited = set()
            result = []

            def dfs(node):
                visited.add(node)

                for neighbor in graph.get(node, []):
                    if neighbor not in visited:
                        dfs(neighbor)

                result.append(node)  # Add after all descendants

            for node in range(n):
                if node not in visited:
                    dfs(node)

            return result[::-1]  # Reverse for topological order

        def topological_sort_kahn(graph, n):
            """
            APPROACH 2: Kahn's Algorithm (BFS)

            TECHNIQUE:
            - Calculate in-degrees
            - Start with nodes having in-degree 0
            - Remove edges, add new 0-degree nodes

            ADVANTAGE: Detects cycles (if not all nodes processed)
            """
            in_degree = [0] * n

            # Calculate in-degrees
            for node in graph:
                for neighbor in graph[node]:
                    in_degree[neighbor] += 1

            # Queue with 0 in-degree nodes
            queue = deque([i for i in range(n) if in_degree[i] == 0])
            result = []

            while queue:
                node = queue.popleft()
                result.append(node)

                # Remove edges
                for neighbor in graph.get(node, []):
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)

            # Cycle detection
            if len(result) != n:
                return []  # Has cycle

            return result

        def course_schedule(num_courses, prerequisites):
            """
            Can finish all courses given prerequisites?

            This is cycle detection in directed graph
            """
            graph = defaultdict(list)
            for course, prereq in prerequisites:
                graph[prereq].append(course)

            topo_order = topological_sort_kahn(graph, num_courses)
            return len(topo_order) == num_courses

        def course_schedule_ii(num_courses, prerequisites):
            """
            Return order to take all courses

            This is topological sort
            """
            graph = defaultdict(list)
            for course, prereq in prerequisites:
                graph[prereq].append(course)

            return topological_sort_kahn(graph, num_courses)
        </code></pre>
        <p>**Time:** O(V + E) | **Space:** O(V)</p>
        <h4 id="154-union-find-(disjoint-set)">15.4 Union-Find (Disjoint Set)</h4>
        <pre><code class="language-python">
        class UnionFind:
            """
            UNION-FIND / DISJOINT SET

            Operations:
            - Find: O(Œ±(n)) ‚âà O(1) with path compression
            - Union: O(Œ±(n)) ‚âà O(1) with union by rank

            Use for:
            - Dynamic connectivity
            - Cycle detection in undirected graphs
            - Kruskal's MST
            - Number of islands II (dynamic)
            """

            def __init__(self, n):
                self.parent = list(range(n))
                self.rank = [0] * n
                self.components = n

            def find(self, x):
                """
                Find root with PATH COMPRESSION
                Makes tree flatter for faster future operations
                """
                if self.parent[x] != x:
                    self.parent[x] = self.find(self.parent[x])  # Compression
                return self.parent[x]

            def union(self, x, y):
                """
                Union by RANK
                Attach smaller tree under larger tree
                """
                root_x = self.find(x)
                root_y = self.find(y)

                if root_x == root_y:
                    return False  # Already connected

                # Union by rank
                if self.rank[root_x] < self.rank[root_y]:
                    self.parent[root_x] = root_y
                elif self.rank[root_x] > self.rank[root_y]:
                    self.parent[root_y] = root_x
                else:
                    self.parent[root_y] = root_x
                    self.rank[root_x] += 1

                self.components -= 1
                return True

            def connected(self, x, y):
                """Check if x and y are in same component"""
                return self.find(x) == self.find(y)

            def get_components(self):
                """Get number of connected components"""
                return self.components

        def redundant_connection(edges):
            """
            Find edge that creates cycle

            TECHNIQUE: Add edges one by one
            If connecting already-connected nodes, that's the cycle edge
            """
            n = len(edges)
            uf = UnionFind(n + 1)

            for u, v in edges:
                if not uf.union(u, v):
                    return [u, v]  # Creates cycle

            return []

        def number_of_provinces(is_connected):
            """
            Count number of connected components
            Using Union-Find
            """
            n = len(is_connected)
            uf = UnionFind(n)

            for i in range(n):
                for j in range(i + 1, n):
                    if is_connected[i][j]:
                        uf.union(i, j)

            return uf.get_components()
</code></pre>
        <p>**Time:** O(Œ±(n)) per operation | **Space:** O(n)</p>
        <h4 id="155-dijkstra's-algorithm-(weighted-shortest-path)">15.5 Dijkstra's Algorithm (Weighted Shortest Path)
        </h4>
        <pre><code class="language-python">
        import heapq

        def dijkstra(graph, start, n):
            """
            DIJKSTRA'S ALGORITHM
            Shortest path in weighted graph with NON-NEGATIVE weights

            TECHNIQUE:
            - Min-heap with (distance, node)
            - Always process closest unvisited node
            - Relax edges (update distances)

            Time: O((V + E) log V) with heap
            """
            dist = [float('inf')] * n
            dist[start] = 0

            heap = [(0, start)]  # (distance, node)
            visited = set()

            while heap:
                d, node = heapq.heappop(heap)

                if node in visited:
                    continue

                visited.add(node)

                # Relax edges
                for neighbor, weight in graph[node]:
                    new_dist = d + weight

                    if new_dist < dist[neighbor]:
                        dist[neighbor] = new_dist
                        heapq.heappush(heap, (new_dist, neighbor))

            return dist

        def network_delay_time(times, n, k):
            """
            Minimum time for signal to reach all nodes

            This is Dijkstra from source k
            Answer = max distance (or -1 if unreachable)
            """
            graph = defaultdict(list)
            for u, v, w in times:
                graph[u].append((v, w))

            dist = dijkstra(graph, k, n + 1)

            max_dist = max(dist[1:])  # Skip index 0
            return max_dist if max_dist != float('inf') else -1

        def cheapest_flights_k_stops(n, flights, src, dst, k):
            """
            Shortest path with at most k stops

            MODIFIED DIJKSTRA:
            - Track (cost, node, stops)
            - Stop if stops > k
            """
            graph = defaultdict(list)
            for u, v, price in flights:
                graph[u].append((v, price))

            heap = [(0, src, 0)]  # (cost, node, stops)
            visited = {}  # (node, stops) -> min_cost

            while heap:
                cost, node, stops = heapq.heappop(heap)

                if node == dst:
                    return cost

                if stops > k:
                    continue

                # Avoid revisiting with more stops and higher cost
                if (node, stops) in visited and visited[(node, stops)] <= cost:
                    continue
                visited[(node, stops)] = cost

                for neighbor, price in graph[node]:
                    heapq.heappush(heap, (cost + price, neighbor, stops + 1))

            return -1
</code></pre>
        <p>**Time:** O((V + E) log V) | **Space:** O(V)</p>
        <h4 id="156-matrix/grid-as-graph">15.6 Matrix/Grid as Graph</h4>
        <pre><code class="language-python">
        def num_islands(grid):
            """
            COUNT ISLANDS (DFS approach)

            TECHNIQUE:
            - DFS from each unvisited land cell
            - Mark visited cells
            - Each DFS call is one island
            """
            if not grid:
                return 0

            rows, cols = len(grid), len(grid[0])
            count = 0

            def dfs(r, c):
                # Bounds check
                if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':
                    return

                grid[r][c] = '0'  # Mark visited

                # Explore 4 directions
                dfs(r + 1, c)
                dfs(r - 1, c)
                dfs(r, c + 1)
                dfs(r, c - 1)

            for r in range(rows):
                for c in range(cols):
                    if grid[r][c] == '1':
                        dfs(r, c)
                        count += 1

            return count

        def max_area_island(grid):
            """
            Find largest island area
            Track size during DFS
            """
            if not grid:
                return 0

            rows, cols = len(grid), len(grid[0])
            max_area = 0

            def dfs(r, c):
                if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != 1:
                    return 0

                grid[r][c] = 0  # Mark visited

                area = 1
                area += dfs(r + 1, c)
                area += dfs(r - 1, c)
                area += dfs(r, c + 1)
                area += dfs(r, c - 1)

                return area

            for r in range(rows):
                for c in range(cols):
                    if grid[r][c] == 1:
                        max_area = max(max_area, dfs(r, c))

            return max_area

        def surrounded_regions(board):
            """
            Capture surrounded regions

            KEY INSIGHT: Regions connected to border can't be captured

            TECHNIQUE:
            1. DFS from border 'O's, mark as safe
            2. Flip remaining 'O's to 'X' (captured)
            3. Restore safe 'O's
            """
            if not board:
                return

            rows, cols = len(board), len(board[0])

            def dfs(r, c):
                if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'O':
                    return

                board[r][c] = 'S'  # Mark as safe

                dfs(r + 1, c)
                dfs(r - 1, c)
                dfs(r, c + 1)
                dfs(r, c - 1)

            # Mark border-connected 'O's as safe
            for r in range(rows):
                dfs(r, 0)
                dfs(r, cols - 1)

            for c in range(cols):
                dfs(0, c)
                dfs(rows - 1, c)

            # Capture surrounded regions
            for r in range(rows):
                for c in range(cols):
                    if board[r][c] == 'O':
                        board[r][c] = 'X'  # Captured
                    elif board[r][c] == 'S':
                        board[r][c] = 'O'  # Restore safe

        def pacific_atlantic_water_flow(heights):
            """
            Find cells where water can flow to both oceans

            REVERSE THINKING:
            - Start from ocean, flow uphill (reverse direction)
            - Find cells reachable from both oceans
            """
            if not heights:
                return []

            rows, cols = len(heights), len(heights[0])
            pacific = set()
            atlantic = set()

            def dfs(r, c, visited):
                visited.add((r, c))

                for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                    nr, nc = r + dr, c + dc

                    if (0 <= nr < rows and 0 <= nc < cols and
                        (nr, nc) not in visited and
                        heights[nr][nc] >= heights[r][c]):  # Can flow uphill
                        dfs(nr, nc, visited)

            # DFS from Pacific (top and left borders)
            for r in range(rows):
                dfs(r, 0, pacific)
            for c in range(cols):
                dfs(0, c, pacific)

            # DFS from Atlantic (bottom and right borders)
            for r in range(rows):
                dfs(r, cols - 1, atlantic)
            for c in range(cols):
                dfs(rows - 1, c, atlantic)

            # Intersection
            return list(pacific & atlantic)
</code></pre>
        <p>**Time:** O(rows * cols) | **Space:** O(rows * cols)</p>
        <h3 id="common-traps-üö®">Common Traps üö®</h3>
        <ul>
            <li>‚ùå <strong>Graph Representation</strong>: Choose right structure
                <ul>
                    <li>Adjacency list for sparse graphs</li>
                    <li>Matrix for dense graphs or grid problems</li>
                </ul>
            </li>
            <li>‚ùå <strong>Visited Tracking</strong>: Mark visited when adding to queue (BFS), not when processing</li>
            <li>‚ùå <strong>Cycle Detection</strong>:
                <ul>
                    <li>Undirected: Track parent</li>
                    <li>Directed: Track recursion stack (visiting state)</li>
                </ul>
            </li>
            <li>‚ùå <strong>Bidirectional Edges</strong>: For undirected graphs, add edge in both directions</li>
            <li>‚ùå <strong>Topological Sort</strong>: Only works on DAGs (Directed Acyclic Graphs)</li>
            <li>‚ùå <strong>Dijkstra Limitations</strong>: Doesn't work with negative weights (use Bellman-Ford)</li>
            <li>‚ùå <strong>Union-Find</strong>: Remember path compression and union by rank for efficiency</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Graph problem type?
        ‚îú‚îÄ Shortest path?
        ‚îÇ ‚îú‚îÄ Unweighted ‚Üí BFS (15.1)
        ‚îÇ ‚îú‚îÄ Weighted (non-negative) ‚Üí Dijkstra (15.5)
        ‚îÇ ‚îî‚îÄ With constraints (k stops) ‚Üí Modified Dijkstra
        ‚îú‚îÄ Connected components / Connectivity?
        ‚îÇ ‚îú‚îÄ Static ‚Üí DFS (15.2)
        ‚îÇ ‚îî‚îÄ Dynamic (adding edges) ‚Üí Union-Find (15.4)
        ‚îú‚îÄ Cycle detection?
        ‚îÇ ‚îú‚îÄ Undirected ‚Üí DFS with parent or Union-Find
        ‚îÇ ‚îî‚îÄ Directed ‚Üí DFS with recursion stack (15.2)
        ‚îú‚îÄ Dependencies / Ordering?
        ‚îÇ ‚îî‚îÄ Topological Sort (11.3)
        ‚îî‚îÄ Grid/Matrix problem?
          ‚îî‚îÄ Treat as graph, use DFS/BFS (11.6)
        </pre>
        <h3 id="must-know-problems">Must-Know Problems</h3>
        <h4 id="medium">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a> (200) -
                DFS/BFS
                foundation ‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/clone-graph/">Clone Graph</a> (133) - Graph
                traversal + copy</li>
            <li><a target="_blank" href="https://leetcode.com/problems/max-area-of-island/">Max Area of Island</a> (695)
                - DFS with
                count</li>
                <li><a target="_blank" href="https://leetcode.com/problems/surrounded-regions/">Surrounded Regions</a> (130)
                    - Border DFS ‚≠ê
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">Pacific Atlantic
                    Water Flow</a>
                (417) - Reverse thinking ‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/course-schedule/">Course Schedule</a> (207) -
                    Cycle detection ‚≠ê‚≠ê
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a> (210)
                - Topological
                sort ‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/rotting-oranges/">Rotting Oranges</a> (994) -
                    Multi-source BFS ‚≠ê
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/redundant-connection/">Redundant Connection</a>
                (684) -
                Union-Find ‚≠ê</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">Number
                    of
                    Connected Components</a> (323) - Components</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/graph-valid-tree/">Graph Valid Tree</a> (261) -
                        Cycle +
                        connectivity</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/network-delay-time/">Network Delay Time</a> (743)
                        - Dijkstra ‚≠ê‚≠ê
                    </li>
                    <li><a target="_blank" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">Cheapest
                            Flights Within K
                            Stops</a> (787) - Modified Dijkstra ‚≠ê‚≠ê</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/min-cost-to-connect-all-points/">Min Cost to
                            Connect All
                            Points</a> (1584)</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/walls-and-gates/">Walls and Gates</a> (286)</li>
                    <li><a target="_blank" href="https://leetcode.com/problems/snakes-and-ladders/">Snakes and Ladders</a> (909)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/evaluate-division/">Evaluate Division</a> (399)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-genetic-mutation/">Minimum Genetic
                    Mutation</a> (433)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/accounts-merge/">Accounts Merge</a> (721) - Union
                Find / DFS</li>
            <li><a target="_blank" href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">Shortest Path in
                    Binary Matrix</a> (1091) - BFS Level Order</li>
            <li><a target="_blank" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">All Nodes
                    Distance K in Binary Tree</a> (863) - Graph BFS conversion</li>
            </ol>

            <h4 id="hard">Hard</h4>
            <ol>
                <li><a target="_blank" href="https://leetcode.com/problems/word-ladder/">Word Ladder</a> (127) - BFS on word
                    graph ‚≠ê‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/alien-dictionary/">Alien Dictionary</a> (269) -
                    Topological Sort ‚≠ê‚≠ê‚≠ê</li>
                <li><a target="_blank" href="https://leetcode.com/problems/swim-in-rising-water/">Swim in Rising Water</a>
                    (778) - Binary
                    search + BFS</li>
            <li><a target="_blank" href="https://leetcode.com/problems/reconstruct-itinerary/">Reconstruct Itinerary</a>
                (332)</li>
        </ol>
        <hr />
        <h1 id="phase-6-advanced-algorithms">PHASE 6: ADVANCED ALGORITHMS üíé</h1>
        <h2 id="16-dynamic-programming-">16. DYNAMIC PROGRAMMING üíé </h2>
        <h3 id="when-to-use-15">When to Use </h3>
        <ul>
            <li>Overlapping subproblems + optimal structure</li>
            <li>Counts/paths/min-max costs</li>
            <li>Subsequences/strings</li>
            <li>Knapsack decisions</li>
            <li>Signal: "ways/max" + recursion hints</li>
        </ul>
        <h3 id="recognition">Recognition </h3>
        <ul>
            <li>Max/min/ways with choices</li>
            <li>Subproblems repeat (memoize)</li>
            <li>Bottom-up fill table</li>
        </ul>
        <h3 id="core-concept-15">Core Concept </h3>
        <p>Break into subproblems, store solutions to avoid recompute, building bottom-up from bases to optimize
            recursive exponential calls.</p>
        <h3 id="sub-patternss-7">Sub-Patternss </h3>
        <h4 id="16.1-1d-dp">16.1 1D Dynamic Programming</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-not">not</span> nums<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token number">0</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># Skip or take</span>
    <span class="token keyword keyword-return">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token comment"># Space opt: prev2, prev1 vars</span>
</code></pre>
        <h4 id="16.2-2d-dp">16.2 2D Dynamic Programming</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">longest_common_subsequence</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    m<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>text1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>text2<span class="token punctuation">)</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> _ <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-for">for</span> j <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword keyword-if">if</span> text1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword keyword-else">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
</code></pre>
        <h3 id="5-steps">5 Steps </h3>
        <ol>
            <li>State: dp[i][j] = max profit up to i</li>
            <li>Recur: dp[i] = max(dp[i-1], dp[i-2] + val)</li>
            <li>Base: dp[0]=0, dp[1]=val[0]</li>
            <li>Order: For i in 1 to n (dependencies first)</li>
            <li>Space: 2D‚Üí1D if row-only deps</li>
        </ol>
        <h3 id="traps-14">Common Traps üö®</h3>
        <ul>
            <li>‚ùå Base cases wrong (off-by-one in init)</li>
            <li>‚ùå Iteration order: Compute small to large</li>
            <li>‚ùå Bounds: Use n+1 sizing</li>
            <li>‚ùå Space: Optimize to O(min(m,n)) when possible</li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Optimization (Min/Max)?
        ‚îú‚îÄ Counting ways?
        ‚îî‚îÄ Decision making with state?
           ‚îú‚îÄ 1D Array? ‚Üí Linear DP (House Robber)
           ‚îú‚îÄ 2D Grid/Strings? ‚Üí LCS / Unique Paths
           ‚îú‚îÄ Decisions (Unbounded)? ‚Üí Knapsack (Coin Change)
           ‚îî‚îÄ Intervals? ‚Üí MCM / Burst Balloons
        </pre>
        <h3 id="must-know-1d">Must-Know 1D </h3>
        <h4 id="easy-11">Easy </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a> (70)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/min-cost-climbing-stairs/">Min Cost Climbing
                    Stairs</a> (746)
            </li>
        </ol>
        <h4 id="medium-14">Medium </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/house-robber/">House Robber</a> (198)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/house-robber-ii/">House Robber II</a> (213)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-palindromic-substring/">Longest
                    Palindromic Substring</a>
                (5)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/palindromic-substrings/">Palindromic
                    Substrings</a> (647)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/decode-ways/">Decode Ways</a> (91)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/coin-change/">Coin Change</a> (322)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/maximum-product-subarray/">Maximum Product
                    Subarray</a> (152)
            </li>
            <li><a target="_blank" href="https://leetcode.com/problems/word-break/">Word Break</a> (139)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest
                    Increasing
                    Subsequence</a> (300)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/partition-equal-subset-sum/">Partition Equal
                    Subset Sum</a> (416)
            </li>
        </ol>
        <h3 id="2d">2D </h3>
        <h4 id="medium-15">Medium </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/unique-paths/">Unique Paths</a> (62)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-common-subsequence/">Longest Common
                    Subsequence</a>
                (1143)</li>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Best Time
                    Buy/Sell with Cooldown</a> (309)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/coin-change-ii/">Coin Change II</a> (518)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/target-sum/">Target Sum</a> (494)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/interleaving-string/">Interleaving String</a>
                (97)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/triangle/">Triangle</a> (120)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a> (64)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a> (63)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/edit-distance/">Edit Distance</a> (72)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/maximal-square/">Maximal Square</a> (221)</li>
        </ol>
        <h4 id="hard-12">Hard </h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">Longest
                    Increasing Path in
                    Matrix</a> (329)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/distinct-subsequences/">Distinct Subsequences</a>
                (115)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/burst-balloons/">Burst Balloons</a> (312)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/regular-expression-matching/">Regular Expression
                    Matching</a>
                (10)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/wildcard-matching/">Wildcard Matching</a> (44) -
                DP Pattern ‚≠ê‚≠ê</li>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">Best Time
                    to Buy and Sell
                    Stock III</a> (123)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to
                    Buy and Sell
                    Stock IV</a> (188)</li>
        </ol>

        <hr />
        <h2 id="17-divide--conquer-">17. DIVIDE &amp; CONQUER üî™ </h2>
        <h3 id="when-to-use-16">When to Use </h3>
        <ul>
            <li>Merge sorted data</li>
            <li>Tree building from arrays</li>
            <li>Large sort/inversions</li>
            <li>Matrix multiply</li>
            <li>Signal: "sorted input" + "merge halves"</li>
        </ul>
        <h3 id="core-concept-16">Core Concept </h3>
        <p>Recur on halves, conquer by merging solutions, achieving log factors for balanced divides like sorting or
            tree construction.</p>
        <h3 id="sub-patterns-8">Sub-Patterns </h3>
        <h4 id="17.1-merge-sort-pattern">17.1 Merge Sort Pattern</h4>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-if">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> arr<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment"># Inversions</span>
    mid <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    left<span class="token punctuation">,</span> inv_l <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
    right<span class="token punctuation">,</span> inv_r <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    merged<span class="token punctuation">,</span> inv_m <span class="token operator">=</span> merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> merged<span class="token punctuation">,</span> inv_l <span class="token operator">+</span> inv_r <span class="token operator">+</span> inv_m
<span class="token keyword keyword-def">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
    merged <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    inv <span class="token operator">=</span> i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword keyword-while">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token keyword keyword-and">and</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-if">if</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            merged<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword keyword-else">else</span><span class="token punctuation">:</span>
            merged<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            inv <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token comment"># All remaining left &gt; right[j]</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword keyword-return">return</span> merged <span class="token operator">+</span> left<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inv
</code></pre>
        <p><strong>Sorted Array to BST</strong></p>
        <pre><code class="language-python"><span class="token keyword keyword-def">def</span> <span class="token function">sorted_array_to_bst</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-def">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword keyword-if">if</span> left <span class="token operator">&gt;</span> right<span class="token punctuation">:</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">None</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> helper<span class="token punctuation">(</span>left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> helper<span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> root
    <span class="token keyword keyword-return">return</span> helper<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
        <h3 id="traps-15">Common Traps üö®</h3>
        <ul>
            <li>‚ùå Recursion depth: O(log n) ok, but stack overflow on n=10^5</li>
            <li>‚ùå Merge efficiency: O(n) per level, total O(n log n)</li>
            <li>‚ùå Off-mid: Balance tree with mid choice</li>
            <li>‚ùå Base: <code>left &gt; right</code> not <code>==</code></li>
        </ul>
        <h3 id="decision-tree">Decision Tree</h3>
        <pre>
        Problem involves...
        ‚îú‚îÄ Splitting input?
        ‚îÇ ‚îú‚îÄ Merge Sort? ‚Üí Split, Sort, Merge
        ‚îÇ ‚îî‚îÄ Quick Sort? ‚Üí Partition around pivot
        ‚îî‚îÄ Multiplication?
           ‚îî‚îÄ Karatsuba / Strassen
        </pre>
        <h3 id="must-know-problems_17">Must-Know Problems</h3>
        <h4 id="easy_12">Easy</h4>
        <ol>
            <li><a target="_blank"
                    href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted
                    Array
                    to Binary Search Tree</a> (108)</li>
        </ol>
        <h4 id="medium_16">Medium</h4>
        <ol>
            <li><a target="_blank" href="https://leetcode.com/problems/sort-list/">Sort List</a> (148)</li>
            <li><a target="_blank" href="https://leetcode.com/problems/construct-quad-tree/">Construct Quad Tree</a>
                (427)</li>
        </ol>
        <h4 id="hard_13">Hard</h4>
        <ol>
        </ol>

        <hr />

    </div>
</body>

</html>
